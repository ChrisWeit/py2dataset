[
    {
        "instruction": "What are the dependencies of the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "\"\"\"\nUtility functions for reading the input and saving the output of the py2dataset script.\nRequirements:\n[req01] The `read_file` function shall:\n        a. Accept a file path as an argument.\n        b. Read and return the contents of a JSON or YAML file as a dictionary.\n[req02] The `write_file` function shall:\n        a. Accept a dictionary and a file path as arguments.\n        b. Write the dictionary to a file in either JSON or YAML format.\n[req03] The `convert_json_to_html` function shall:\n        a. Convert JSON files within a given directory to HTML format.\n        b. Save each converted file with a .html extension.\n        c. Preserve spacing and tabs for the 'input' field.\n[req04] The `combine_json_files` function shall:\n        a. Accept a directory path as an argument.\n        b. Merge all JSON files in the directory.\n        c. Remove duplicates from the combined JSON files.\n        d. Write the combined data to 'instruct.json' files.\n        e. Convert the merged JSON files to HTML format.\n        f. Return the 'instruct_list' datasets.\n[req05] The `create_code_graph` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Generate code graphs based on the provided file details.\n        c. Save the graphs as PNG images in the specified output directory.\n[req06] The `save_python_data` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Save the details of the Python file as a YAML file.\n        c. Save the instruction data as JSON files.\n        d. Generate and save code graphs.\n\"\"\"\nimport sys\nimport os\nimport re\nimport json\nimport logging\nimport yaml\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom html import escape\nfrom pathlib import Path\nfrom typing import Dict, List, Union\n\n\ndef read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)\n\n\ndef write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)\n\n\ndef convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n    def preserve_spacing(text: str, tab_width: int = 4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(\" \", \"&nbsp;\").replace(\"\\t\", \"&nbsp;\" * tab_width)\n\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n\n        html_file = json_file.with_suffix('.html')\n        html_content = \"\"\"\n        <html>\n        <head>\n            <style>\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\n                th, td {\n                    border: 1px solid black;\n                    padding: 8px;\n                    text-align: left;\n                    white-space: pre-line;\n                    vertical-align: top;\n                    word-wrap: break-word;\n                }\n            </style>\n        </head>\n        <body>\n            <table>\n                <thead>\n                    <tr>\n        \"\"\"\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count  # Calculate the width for each column based on the number of columns\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += \"\"\"\n                    </tr>\n                </thead>\n                <tbody>\n        \"\"\"\n        for entry in dataset:\n            html_content += \"<tr>\"\n            for key in entry:\n                # Convert \\n to HTML line breaks\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f\"<td>{value}</td>\"\n            html_content += \"</tr>\"\n\n        html_content += \"\"\"\n                </tbody>\n            </table>\n        </body>\n        </html>\n        \"\"\"\n        html_file_path = json_file.with_suffix('.html')\n        try:   \n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))\n\n\ndef combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n   \n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            # gen training datasets that contains purpose and graph data formatted as follow for each item in the dataset:\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n'+ item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n\n        write_file(combined_data, file_path)\n\n    # Save html file for each json file in the output directory\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}\n\n\ndef create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n\n    # Create graphs, add nodes, and add edges\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = edge['source'], edge['target']\n        if source in G.nodes and target in G.nodes:\n           G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    # Draw graphs\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size = 8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[(edge[0], edge[1])] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file) # Save the figure\n    plt.close()  # Close the figure\n\n\ndef save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join(part for part in relative_path.parts)\n\n    # write instrunct.json files\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')\n",
        "output": "sys, networkx, os, json, matplotlib.pyplot, html, re, yaml, typing, logging, pathlib"
    },
    {
        "instruction": "What is the call code graph of the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "\"\"\"\nUtility functions for reading the input and saving the output of the py2dataset script.\nRequirements:\n[req01] The `read_file` function shall:\n        a. Accept a file path as an argument.\n        b. Read and return the contents of a JSON or YAML file as a dictionary.\n[req02] The `write_file` function shall:\n        a. Accept a dictionary and a file path as arguments.\n        b. Write the dictionary to a file in either JSON or YAML format.\n[req03] The `convert_json_to_html` function shall:\n        a. Convert JSON files within a given directory to HTML format.\n        b. Save each converted file with a .html extension.\n        c. Preserve spacing and tabs for the 'input' field.\n[req04] The `combine_json_files` function shall:\n        a. Accept a directory path as an argument.\n        b. Merge all JSON files in the directory.\n        c. Remove duplicates from the combined JSON files.\n        d. Write the combined data to 'instruct.json' files.\n        e. Convert the merged JSON files to HTML format.\n        f. Return the 'instruct_list' datasets.\n[req05] The `create_code_graph` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Generate code graphs based on the provided file details.\n        c. Save the graphs as PNG images in the specified output directory.\n[req06] The `save_python_data` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Save the details of the Python file as a YAML file.\n        c. Save the instruction data as JSON files.\n        d. Generate and save code graphs.\n\"\"\"\nimport sys\nimport os\nimport re\nimport json\nimport logging\nimport yaml\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom html import escape\nfrom pathlib import Path\nfrom typing import Dict, List, Union\n\n\ndef read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)\n\n\ndef write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)\n\n\ndef convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n    def preserve_spacing(text: str, tab_width: int = 4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(\" \", \"&nbsp;\").replace(\"\\t\", \"&nbsp;\" * tab_width)\n\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n\n        html_file = json_file.with_suffix('.html')\n        html_content = \"\"\"\n        <html>\n        <head>\n            <style>\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\n                th, td {\n                    border: 1px solid black;\n                    padding: 8px;\n                    text-align: left;\n                    white-space: pre-line;\n                    vertical-align: top;\n                    word-wrap: break-word;\n                }\n            </style>\n        </head>\n        <body>\n            <table>\n                <thead>\n                    <tr>\n        \"\"\"\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count  # Calculate the width for each column based on the number of columns\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += \"\"\"\n                    </tr>\n                </thead>\n                <tbody>\n        \"\"\"\n        for entry in dataset:\n            html_content += \"<tr>\"\n            for key in entry:\n                # Convert \\n to HTML line breaks\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f\"<td>{value}</td>\"\n            html_content += \"</tr>\"\n\n        html_content += \"\"\"\n                </tbody>\n            </table>\n        </body>\n        </html>\n        \"\"\"\n        html_file_path = json_file.with_suffix('.html')\n        try:   \n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))\n\n\ndef combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n   \n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            # gen training datasets that contains purpose and graph data formatted as follow for each item in the dataset:\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n'+ item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n\n        write_file(combined_data, file_path)\n\n    # Save html file for each json file in the output directory\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}\n\n\ndef create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n\n    # Create graphs, add nodes, and add edges\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = edge['source'], edge['target']\n        if source in G.nodes and target in G.nodes:\n           G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    # Draw graphs\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size = 8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[(edge[0], edge[1])] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file) # Save the figure\n    plt.close()  # Close the figure\n\n\ndef save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join(part for part in relative_path.parts)\n\n    # write instrunct.json files\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')\n",
        "output": "{'nodes': ['read_file', 'write_file', 'convert_json_to_html', 'preserve_spacing', 'combine_json_files', 'remove_duplicate_dataset_entries', 'create_code_graph', 'save_python_data', 'file_path.open', 'json.load', 'yaml.load', 'json.dump', 'yaml.dump', \"text.replace(' ', '&nbsp;').replace\", 'text.replace', 'Path(directory).rglob', 'Path', 'json_file.with_suffix', 'len', 'dataset[0].keys', 'escape', 'str', 'value.replace', 'open', 'file.write', 'logging.save', 'logging.info', 'set', 'seen.add', 'result.append', 'combined_data.extend', 'combined_data.copy', \"item['instruction'].startswith\", 'code_output.append', 'graph_output.append', 'nx.DiGraph', 'G.add_nodes_from', 'G.add_edge', 'edge.items', 'plt.figure', 'nx.spring_layout', 'nx.draw', 'G.edges', 'label.append', \"', '.join\", \"'\\\\n'.join\", 'nx.draw_networkx_edge_labels', 'plt.savefig', 'plt.close', 'output_subdir.mkdir', \"'.'.join\", 'zip'], 'edges': [{'source': 'read_file', 'target': 'file_path.open', 'target_inputs': []}, {'source': 'read_file', 'target': 'json.load', 'target_inputs': ['f']}, {'source': 'read_file', 'target': 'yaml.load', 'target_inputs': ['f']}, {'source': 'write_file', 'target': 'file_path.open', 'target_inputs': [\"'w'\"]}, {'source': 'write_file', 'target': 'json.dump', 'target_inputs': ['data', 'f']}, {'source': 'write_file', 'target': 'yaml.dump', 'target_inputs': ['data', 'f']}, {'source': 'convert_json_to_html', 'target': \"text.replace(' ', '&nbsp;').replace\", 'target_inputs': [\"'\\\\t'\", \"'&nbsp;' * tab_width\"]}, {'source': 'convert_json_to_html', 'target': 'text.replace', 'target_inputs': [\"' '\", \"'&nbsp;'\"]}, {'source': 'convert_json_to_html', 'target': 'Path(directory).rglob', 'target_inputs': [\"'*.json'\"]}, {'source': 'convert_json_to_html', 'target': 'Path', 'target_inputs': ['directory']}, {'source': 'convert_json_to_html', 'target': 'read_file', 'target_inputs': ['json_file'], 'target_returns': ['json.load(f)', 'yaml.load(f)']}, {'source': 'convert_json_to_html', 'target': 'json_file.with_suffix', 'target_inputs': [\"'.html'\"]}, {'source': 'convert_json_to_html', 'target': 'len', 'target_inputs': ['dataset[0].keys()']}, {'source': 'convert_json_to_html', 'target': 'dataset[0].keys', 'target_inputs': []}, {'source': 'convert_json_to_html', 'target': 'escape', 'target_inputs': ['str(entry[key])']}, {'source': 'convert_json_to_html', 'target': 'str', 'target_inputs': ['entry[key]']}, {'source': 'convert_json_to_html', 'target': 'preserve_spacing', 'target_inputs': ['value'], 'target_returns': [\"text.replace(' ', '&nbsp;').replace('\\\\t', '&nbsp;' * tab_width)\"]}, {'source': 'convert_json_to_html', 'target': 'value.replace', 'target_inputs': [\"'\\\\n'\", \"'<br/>'\"]}, {'source': 'convert_json_to_html', 'target': 'open', 'target_inputs': ['html_file_path', \"'w'\"]}, {'source': 'convert_json_to_html', 'target': 'file.write', 'target_inputs': ['html_content']}, {'source': 'convert_json_to_html', 'target': 'logging.save', 'target_inputs': [\"logging.info(f'Failed saving: {html_file_path}')\"]}, {'source': 'convert_json_to_html', 'target': 'logging.info', 'target_inputs': [\"f'Failed saving: {html_file_path}'\"]}, {'source': 'preserve_spacing', 'target': \"text.replace(' ', '&nbsp;').replace\", 'target_inputs': [\"'\\\\t'\", \"'&nbsp;' * tab_width\"]}, {'source': 'preserve_spacing', 'target': 'text.replace', 'target_inputs': [\"' '\", \"'&nbsp;'\"]}, {'source': 'combine_json_files', 'target': 'set', 'target_inputs': []}, {'source': 'combine_json_files', 'target': 'seen.add', 'target_inputs': ['(item[key1], item[key2])']}, {'source': 'combine_json_files', 'target': 'result.append', 'target_inputs': ['item']}, {'source': 'combine_json_files', 'target': 'Path', 'target_inputs': ['directory']}, {'source': 'combine_json_files', 'target': 'Path(directory).rglob', 'target_inputs': [\"f'*.{file_name}'\"]}, {'source': 'combine_json_files', 'target': 'read_file', 'target_inputs': ['json_file'], 'target_returns': ['json.load(f)', 'yaml.load(f)']}, {'source': 'combine_json_files', 'target': 'combined_data.extend', 'target_inputs': ['json_file_data']}, {'source': 'combine_json_files', 'target': 'remove_duplicate_dataset_entries', 'target_inputs': ['combined_data', \"'instruction'\", \"'output'\"], 'target_returns': ['result']}, {'source': 'combine_json_files', 'target': 'combined_data.copy', 'target_inputs': []}, {'source': 'combine_json_files', 'target': \"item['instruction'].startswith\", 'target_inputs': [\"'What is the call code graph'\"]}, {'source': 'combine_json_files', 'target': 'code_output.append', 'target_inputs': [\"{'instruction': 'Define the Python code file that is described as follows:\\\\n' + item['output'], 'output': item['input']}\"]}, {'source': 'combine_json_files', 'target': 'graph_output.append', 'target_inputs': [\"{'instruction': 'Define the call code graph for Python file:\\\\n' + item['input'], 'output': item['output']}\"]}, {'source': 'combine_json_files', 'target': 'write_file', 'target_inputs': ['combined_data', 'file_path'], 'target_returns': []}, {'source': 'combine_json_files', 'target': 'convert_json_to_html', 'target_inputs': ['directory'], 'target_returns': [\"text.replace(' ', '&nbsp;').replace('\\\\t', '&nbsp;' * tab_width)\"]}, {'source': 'remove_duplicate_dataset_entries', 'target': 'set', 'target_inputs': []}, {'source': 'remove_duplicate_dataset_entries', 'target': 'seen.add', 'target_inputs': ['(item[key1], item[key2])']}, {'source': 'remove_duplicate_dataset_entries', 'target': 'result.append', 'target_inputs': ['item']}, {'source': 'create_code_graph', 'target': 'nx.DiGraph', 'target_inputs': []}, {'source': 'create_code_graph', 'target': 'G.add_nodes_from', 'target_inputs': [\"file_details['file_info'][graph_type]['nodes']\"]}, {'source': 'create_code_graph', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'create_code_graph', 'target': 'edge.items', 'target_inputs': []}, {'source': 'create_code_graph', 'target': 'plt.figure', 'target_inputs': []}, {'source': 'create_code_graph', 'target': 'nx.spring_layout', 'target_inputs': ['G']}, {'source': 'create_code_graph', 'target': 'nx.draw', 'target_inputs': ['G', 'pos']}, {'source': 'create_code_graph', 'target': 'G.edges', 'target_inputs': []}, {'source': 'create_code_graph', 'target': 'label.append', 'target_inputs': ['f\"\\\\nReturns: {\\', \\'.join(edge[2][\\'target_returns\\'])}\"']}, {'source': 'create_code_graph', 'target': \"', '.join\", 'target_inputs': [\"edge[2]['target_returns']\"]}, {'source': 'create_code_graph', 'target': \"'\\\\n'.join\", 'target_inputs': ['label']}, {'source': 'create_code_graph', 'target': 'nx.draw_networkx_edge_labels', 'target_inputs': ['G', 'pos']}, {'source': 'create_code_graph', 'target': 'plt.savefig', 'target_inputs': ['output_file']}, {'source': 'create_code_graph', 'target': 'plt.close', 'target_inputs': []}, {'source': 'save_python_data', 'target': 'Path', 'target_inputs': ['output_dir']}, {'source': 'save_python_data', 'target': 'output_subdir.mkdir', 'target_inputs': []}, {'source': 'save_python_data', 'target': \"'.'.join\", 'target_inputs': ['(part for part in relative_path.parts)']}, {'source': 'save_python_data', 'target': 'zip', 'target_inputs': ['file_names', 'contents']}, {'source': 'save_python_data', 'target': 'write_file', 'target_inputs': ['content', 'output_subdir / file_name'], 'target_returns': []}, {'source': 'save_python_data', 'target': 'create_code_graph', 'target_inputs': ['file_details', 'base_name', 'output_subdir'], 'target_returns': []}, {'source': 'save_python_data', 'target': 'logging.info', 'target_inputs': [\"f'Error creating graph for {base_name}'\"]}]}"
    },
    {
        "instruction": "What functions are defined in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "\"\"\"\nUtility functions for reading the input and saving the output of the py2dataset script.\nRequirements:\n[req01] The `read_file` function shall:\n        a. Accept a file path as an argument.\n        b. Read and return the contents of a JSON or YAML file as a dictionary.\n[req02] The `write_file` function shall:\n        a. Accept a dictionary and a file path as arguments.\n        b. Write the dictionary to a file in either JSON or YAML format.\n[req03] The `convert_json_to_html` function shall:\n        a. Convert JSON files within a given directory to HTML format.\n        b. Save each converted file with a .html extension.\n        c. Preserve spacing and tabs for the 'input' field.\n[req04] The `combine_json_files` function shall:\n        a. Accept a directory path as an argument.\n        b. Merge all JSON files in the directory.\n        c. Remove duplicates from the combined JSON files.\n        d. Write the combined data to 'instruct.json' files.\n        e. Convert the merged JSON files to HTML format.\n        f. Return the 'instruct_list' datasets.\n[req05] The `create_code_graph` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Generate code graphs based on the provided file details.\n        c. Save the graphs as PNG images in the specified output directory.\n[req06] The `save_python_data` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Save the details of the Python file as a YAML file.\n        c. Save the instruction data as JSON files.\n        d. Generate and save code graphs.\n\"\"\"\nimport sys\nimport os\nimport re\nimport json\nimport logging\nimport yaml\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom html import escape\nfrom pathlib import Path\nfrom typing import Dict, List, Union\n\n\ndef read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)\n\n\ndef write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)\n\n\ndef convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n    def preserve_spacing(text: str, tab_width: int = 4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(\" \", \"&nbsp;\").replace(\"\\t\", \"&nbsp;\" * tab_width)\n\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n\n        html_file = json_file.with_suffix('.html')\n        html_content = \"\"\"\n        <html>\n        <head>\n            <style>\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\n                th, td {\n                    border: 1px solid black;\n                    padding: 8px;\n                    text-align: left;\n                    white-space: pre-line;\n                    vertical-align: top;\n                    word-wrap: break-word;\n                }\n            </style>\n        </head>\n        <body>\n            <table>\n                <thead>\n                    <tr>\n        \"\"\"\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count  # Calculate the width for each column based on the number of columns\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += \"\"\"\n                    </tr>\n                </thead>\n                <tbody>\n        \"\"\"\n        for entry in dataset:\n            html_content += \"<tr>\"\n            for key in entry:\n                # Convert \\n to HTML line breaks\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f\"<td>{value}</td>\"\n            html_content += \"</tr>\"\n\n        html_content += \"\"\"\n                </tbody>\n            </table>\n        </body>\n        </html>\n        \"\"\"\n        html_file_path = json_file.with_suffix('.html')\n        try:   \n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))\n\n\ndef combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n   \n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            # gen training datasets that contains purpose and graph data formatted as follow for each item in the dataset:\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n'+ item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n\n        write_file(combined_data, file_path)\n\n    # Save html file for each json file in the output directory\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}\n\n\ndef create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n\n    # Create graphs, add nodes, and add edges\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = edge['source'], edge['target']\n        if source in G.nodes and target in G.nodes:\n           G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    # Draw graphs\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size = 8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[(edge[0], edge[1])] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file) # Save the figure\n    plt.close()  # Close the figure\n\n\ndef save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join(part for part in relative_path.parts)\n\n    # write instrunct.json files\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')\n",
        "output": "convert_json_to_html, remove_duplicate_dataset_entries, read_file, preserve_spacing, save_python_data, write_file, combine_json_files, create_code_graph"
    },
    {
        "instruction": "What are the inputs to the function: 'read_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)",
        "output": "file_path"
    },
    {
        "instruction": "What are the inputs to the function: 'write_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)",
        "output": "file_path, data"
    },
    {
        "instruction": "What are the inputs to the function: 'convert_json_to_html' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n\n    def preserve_spacing(text: str, tab_width: int=4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n        html_file = json_file.with_suffix('.html')\n        html_content = '\\n        <html>\\n        <head>\\n            <style>\\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\\n                th, td {\\n                    border: 1px solid black;\\n                    padding: 8px;\\n                    text-align: left;\\n                    white-space: pre-line;\\n                    vertical-align: top;\\n                    word-wrap: break-word;\\n                }\\n            </style>\\n        </head>\\n        <body>\\n            <table>\\n                <thead>\\n                    <tr>\\n        '\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += '\\n                    </tr>\\n                </thead>\\n                <tbody>\\n        '\n        for entry in dataset:\n            html_content += '<tr>'\n            for key in entry:\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f'<td>{value}</td>'\n            html_content += '</tr>'\n        html_content += '\\n                </tbody>\\n            </table>\\n        </body>\\n        </html>\\n        '\n        html_file_path = json_file.with_suffix('.html')\n        try:\n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))",
        "output": "directory"
    },
    {
        "instruction": "What are the inputs to the function: 'preserve_spacing' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def preserve_spacing(text: str, tab_width: int=4) -> str:\n    \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n    return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)",
        "output": "text, tab_width"
    },
    {
        "instruction": "What are the inputs to the function: 'combine_json_files' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n\n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n' + item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n        write_file(combined_data, file_path)\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}",
        "output": "directory"
    },
    {
        "instruction": "What are the inputs to the function: 'remove_duplicate_dataset_entries' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n    \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n    seen = set()\n    result = []\n    for item in dataset:\n        if (item[key1], item[key2]) not in seen:\n            seen.add((item[key1], item[key2]))\n            result.append(item)\n    return result",
        "output": "dataset, key2, key1"
    },
    {
        "instruction": "What are the inputs to the function: 'create_code_graph' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = (edge['source'], edge['target'])\n        if source in G.nodes and target in G.nodes:\n            G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size=8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[edge[0], edge[1]] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file)\n    plt.close()",
        "output": "output_subdir, base_name, file_details"
    },
    {
        "instruction": "What are the inputs to the function: 'save_python_data' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join((part for part in relative_path.parts))\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')",
        "output": "relative_path, output_dir, instruct_list, file_details"
    },
    {
        "instruction": "What is the docstring of the function: 'read_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)",
        "output": "Reads a JSON or YAML file and returns its contents as a dictionary. Args: file_path Path: The path to the file. Returns: The contents of the file as a dictionary."
    },
    {
        "instruction": "What is the docstring of the function: 'write_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)",
        "output": "Writes a dictionary to a JSON or YAML file. Args: data Dict: The data to write to the file. file_path Path: The path to the file. Returns: None"
    },
    {
        "instruction": "What is the docstring of the function: 'convert_json_to_html' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n\n    def preserve_spacing(text: str, tab_width: int=4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n        html_file = json_file.with_suffix('.html')\n        html_content = '\\n        <html>\\n        <head>\\n            <style>\\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\\n                th, td {\\n                    border: 1px solid black;\\n                    padding: 8px;\\n                    text-align: left;\\n                    white-space: pre-line;\\n                    vertical-align: top;\\n                    word-wrap: break-word;\\n                }\\n            </style>\\n        </head>\\n        <body>\\n            <table>\\n                <thead>\\n                    <tr>\\n        '\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += '\\n                    </tr>\\n                </thead>\\n                <tbody>\\n        '\n        for entry in dataset:\n            html_content += '<tr>'\n            for key in entry:\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f'<td>{value}</td>'\n            html_content += '</tr>'\n        html_content += '\\n                </tbody>\\n            </table>\\n        </body>\\n        </html>\\n        '\n        html_file_path = json_file.with_suffix('.html')\n        try:\n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))",
        "output": "Convert JSON files within a given directory to HTML format. Args: directory str: The directory where the JSON files are located. Returns: None"
    },
    {
        "instruction": "What is the docstring of the function: 'preserve_spacing' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def preserve_spacing(text: str, tab_width: int=4) -> str:\n    \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n    return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)",
        "output": "Preserve spaces and tabs in the provided text."
    },
    {
        "instruction": "What is the docstring of the function: 'combine_json_files' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n\n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n' + item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n        write_file(combined_data, file_path)\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}",
        "output": "Combine all JSON files in the output directory into instruct.json, and then remove duplicates. Args: directory str: The directory where the output files are located. Returns: A dictionary containing the instruct_list datasets."
    },
    {
        "instruction": "What is the docstring of the function: 'remove_duplicate_dataset_entries' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n    \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n    seen = set()\n    result = []\n    for item in dataset:\n        if (item[key1], item[key2]) not in seen:\n            seen.add((item[key1], item[key2]))\n            result.append(item)\n    return result",
        "output": "Remove duplicate entries from the provided dataset based on the provided keys. Args: dataset ListDict: The dataset to remove duplicates from. key1 str: The first key to check for duplicates. key2 str: The second key to check for duplicates. Returns: A dataset without duplicate entries."
    },
    {
        "instruction": "What is the docstring of the function: 'create_code_graph' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = (edge['source'], edge['target'])\n        if source in G.nodes and target in G.nodes:\n            G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size=8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[edge[0], edge[1]] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file)\n    plt.close()",
        "output": "Generate graphs from the file_details and save them as PNG images. Args: file_details dict: The details extracted from the Python file. base_name str: The base name of the output files. output_subdir Path: The subdirectory where the output files will be saved. Returns: None"
    },
    {
        "instruction": "What is the docstring of the function: 'save_python_data' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join((part for part in relative_path.parts))\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')",
        "output": "and code graphs. Args: file_details dict: The details extracted from the Python file. instruct_list list: The instruction data extracted from the Python file. relative_path Path: The relative path to the Python file. output_dir str: The directory where the output files will be saved. Returns: None, Save Python file details as a YAML file, the instruction data as a JSON file"
    },
    {
        "instruction": "What calls are made in the function: 'read_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)",
        "output": "yaml.load, file_path.open, json.load"
    },
    {
        "instruction": "What calls are made in the function: 'write_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)",
        "output": "yaml.dump, file_path.open, json.dump"
    },
    {
        "instruction": "What calls are made in the function: 'convert_json_to_html' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n\n    def preserve_spacing(text: str, tab_width: int=4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n        html_file = json_file.with_suffix('.html')\n        html_content = '\\n        <html>\\n        <head>\\n            <style>\\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\\n                th, td {\\n                    border: 1px solid black;\\n                    padding: 8px;\\n                    text-align: left;\\n                    white-space: pre-line;\\n                    vertical-align: top;\\n                    word-wrap: break-word;\\n                }\\n            </style>\\n        </head>\\n        <body>\\n            <table>\\n                <thead>\\n                    <tr>\\n        '\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += '\\n                    </tr>\\n                </thead>\\n                <tbody>\\n        '\n        for entry in dataset:\n            html_content += '<tr>'\n            for key in entry:\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f'<td>{value}</td>'\n            html_content += '</tr>'\n        html_content += '\\n                </tbody>\\n            </table>\\n        </body>\\n        </html>\\n        '\n        html_file_path = json_file.with_suffix('.html')\n        try:\n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))",
        "output": "Pathdirectory.rglob, logging.info, dataset0.keys, len, Path, nbsp.replace, escape, text.replace, file.write, read_file, str, preserve_spacing, json_file.with_suffix, value.replace, text.replace , logging.save, open"
    },
    {
        "instruction": "What calls are made in the function: 'preserve_spacing' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def preserve_spacing(text: str, tab_width: int=4) -> str:\n    \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n    return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)",
        "output": "text.replace , nbsp.replace, text.replace"
    },
    {
        "instruction": "What calls are made in the function: 'combine_json_files' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n\n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n' + item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n        write_file(combined_data, file_path)\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}",
        "output": "Pathdirectory.rglob, combined_data.copy, graph_output.append, convert_json_to_html, code_output.append, Path, remove_duplicate_dataset_entries, read_file, result.append, combined_data.extend, iteminstruction.startswith, seen.add, write_file, set"
    },
    {
        "instruction": "What calls are made in the function: 'remove_duplicate_dataset_entries' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n    \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n    seen = set()\n    result = []\n    for item in dataset:\n        if (item[key1], item[key2]) not in seen:\n            seen.add((item[key1], item[key2]))\n            result.append(item)\n    return result",
        "output": "result.append, set, seen.add"
    },
    {
        "instruction": "What calls are made in the function: 'create_code_graph' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = (edge['source'], edge['target'])\n        if source in G.nodes and target in G.nodes:\n            G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size=8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[edge[0], edge[1]] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file)\n    plt.close()",
        "output": ", G.add_nodes_from, n.join, label.append, G.add_edge, .join, nx.draw, plt.close, plt.savefig, nx.spring_layout, nx.DiGraph, G.edges, edge.items, nx.draw_networkx_edge_labels, plt.figure"
    },
    {
        "instruction": "What calls are made in the function: 'save_python_data' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join((part for part in relative_path.parts))\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')",
        "output": "logging.info, Path, zip, write_file, create_code_graph, output_subdir.mkdir, ..join"
    },
    {
        "instruction": "What variables are defined in the function: 'read_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)",
        "output": "file_type"
    },
    {
        "instruction": "What variables are defined in the function: 'write_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)",
        "output": "file_type"
    },
    {
        "instruction": "What variables are defined in the function: 'convert_json_to_html' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n\n    def preserve_spacing(text: str, tab_width: int=4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n        html_file = json_file.with_suffix('.html')\n        html_content = '\\n        <html>\\n        <head>\\n            <style>\\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\\n                th, td {\\n                    border: 1px solid black;\\n                    padding: 8px;\\n                    text-align: left;\\n                    white-space: pre-line;\\n                    vertical-align: top;\\n                    word-wrap: break-word;\\n                }\\n            </style>\\n        </head>\\n        <body>\\n            <table>\\n                <thead>\\n                    <tr>\\n        '\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += '\\n                    </tr>\\n                </thead>\\n                <tbody>\\n        '\n        for entry in dataset:\n            html_content += '<tr>'\n            for key in entry:\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f'<td>{value}</td>'\n            html_content += '</tr>'\n        html_content += '\\n                </tbody>\\n            </table>\\n        </body>\\n        </html>\\n        '\n        html_file_path = json_file.with_suffix('.html')\n        try:\n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))",
        "output": "column_width, html_content, html_file, column_count, html_file_path, value, dataset"
    },
    {
        "instruction": "What variables are defined in the function: 'combine_json_files' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n\n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n' + item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n        write_file(combined_data, file_path)\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}",
        "output": "purpose_data, graph_data, code_graph_output, instruct_data, graph_output, combined_data, result, seen, code_output, file_path, json_file_data"
    },
    {
        "instruction": "What variables are defined in the function: 'remove_duplicate_dataset_entries' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n    \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n    seen = set()\n    result = []\n    for item in dataset:\n        if (item[key1], item[key2]) not in seen:\n            seen.add((item[key1], item[key2]))\n            result.append(item)\n    return result",
        "output": "seen, result"
    },
    {
        "instruction": "What variables are defined in the function: 'create_code_graph' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = (edge['source'], edge['target'])\n        if source in G.nodes and target in G.nodes:\n            G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size=8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[edge[0], edge[1]] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file)\n    plt.close()",
        "output": "G, edge_labels, label, graph_type, output_file, pos"
    },
    {
        "instruction": "What variables are defined in the function: 'save_python_data' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join((part for part in relative_path.parts))\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')",
        "output": "output_subdir, file_names, contents, base_name"
    },
    {
        "instruction": "What are the returned items from the function: 'read_file' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)",
        "output": "json.loadf, yaml.loadf"
    },
    {
        "instruction": "What are the returned items from the function: 'convert_json_to_html' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n\n    def preserve_spacing(text: str, tab_width: int=4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n        html_file = json_file.with_suffix('.html')\n        html_content = '\\n        <html>\\n        <head>\\n            <style>\\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\\n                th, td {\\n                    border: 1px solid black;\\n                    padding: 8px;\\n                    text-align: left;\\n                    white-space: pre-line;\\n                    vertical-align: top;\\n                    word-wrap: break-word;\\n                }\\n            </style>\\n        </head>\\n        <body>\\n            <table>\\n                <thead>\\n                    <tr>\\n        '\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += '\\n                    </tr>\\n                </thead>\\n                <tbody>\\n        '\n        for entry in dataset:\n            html_content += '<tr>'\n            for key in entry:\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f'<td>{value}</td>'\n            html_content += '</tr>'\n        html_content += '\\n                </tbody>\\n            </table>\\n        </body>\\n        </html>\\n        '\n        html_file_path = json_file.with_suffix('.html')\n        try:\n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))",
        "output": "text.replace , nbsp.replacet, nbsp  tab_width"
    },
    {
        "instruction": "What are the returned items from the function: 'preserve_spacing' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def preserve_spacing(text: str, tab_width: int=4) -> str:\n    \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n    return text.replace(' ', '&nbsp;').replace('\\t', '&nbsp;' * tab_width)",
        "output": "text.replace , nbsp.replacet, nbsp  tab_width"
    },
    {
        "instruction": "What are the returned items from the function: 'combine_json_files' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n\n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n' + item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n        write_file(combined_data, file_path)\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}",
        "output": "instruct_list: instruct_data, result"
    },
    {
        "instruction": "What are the returned items from the function: 'remove_duplicate_dataset_entries' in the Python file: 'py2dataset.save_py2dataset_output.py'?",
        "input": "def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n    \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n    seen = set()\n    result = []\n    for item in dataset:\n        if (item[key1], item[key2]) not in seen:\n            seen.add((item[key1], item[key2]))\n            result.append(item)\n    return result",
        "output": "result"
    },
    {
        "instruction": "1) Describe the purpose and processing summary of the Python file: 'py2dataset.save_py2dataset_output.py; 2) Provide an itemized detailed description of each applicable function, class, and method; 3) Explain what each of input, output, and variable do within the file.",
        "input": "\"\"\"\nUtility functions for reading the input and saving the output of the py2dataset script.\nRequirements:\n[req01] The `read_file` function shall:\n        a. Accept a file path as an argument.\n        b. Read and return the contents of a JSON or YAML file as a dictionary.\n[req02] The `write_file` function shall:\n        a. Accept a dictionary and a file path as arguments.\n        b. Write the dictionary to a file in either JSON or YAML format.\n[req03] The `convert_json_to_html` function shall:\n        a. Convert JSON files within a given directory to HTML format.\n        b. Save each converted file with a .html extension.\n        c. Preserve spacing and tabs for the 'input' field.\n[req04] The `combine_json_files` function shall:\n        a. Accept a directory path as an argument.\n        b. Merge all JSON files in the directory.\n        c. Remove duplicates from the combined JSON files.\n        d. Write the combined data to 'instruct.json' files.\n        e. Convert the merged JSON files to HTML format.\n        f. Return the 'instruct_list' datasets.\n[req05] The `create_code_graph` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Generate code graphs based on the provided file details.\n        c. Save the graphs as PNG images in the specified output directory.\n[req06] The `save_python_data` function shall:\n        a. Accept details of a Python file, a base name, and an output directory as arguments.\n        b. Save the details of the Python file as a YAML file.\n        c. Save the instruction data as JSON files.\n        d. Generate and save code graphs.\n\"\"\"\nimport sys\nimport os\nimport re\nimport json\nimport logging\nimport yaml\nimport matplotlib.pyplot as plt\nimport networkx as nx\nfrom html import escape\nfrom pathlib import Path\nfrom typing import Dict, List, Union\n\n\ndef read_file(file_path: Path) -> Dict:\n    \"\"\"\n    Reads a JSON or YAML file and returns its contents as a dictionary.\n    Args:\n        file_path (Path): The path to the file.\n    Returns:\n        The contents of the file as a dictionary.\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open() as f:\n        if file_type == 'json':\n            return json.load(f)\n        elif file_type == 'yaml':\n            return yaml.load(f)\n\n\ndef write_file(data: Dict, file_path: Path) -> None:\n    \"\"\"\n    Writes a dictionary to a JSON or YAML file. \n    Args:\n        data (Dict): The data to write to the file.\n        file_path (Path): The path to the file.\n    Returns:\n        None\n    \"\"\"\n    file_type = file_path.suffix[1:]\n    with file_path.open('w') as f:\n        if file_type == 'json':\n            json.dump(data, f, indent=4)\n        elif file_type == 'yaml':\n            yaml.SafeDumper.ignore_aliases = lambda *args: True\n            yaml.dump(data, f, Dumper=yaml.SafeDumper, sort_keys=False)\n\n\ndef convert_json_to_html(directory: str) -> None:\n    \"\"\"\n    Convert JSON files within a given directory to HTML format.\n    Args:\n        directory (str): The directory where the JSON files are located.\n    Returns:\n        None    \n    \"\"\"\n    def preserve_spacing(text: str, tab_width: int = 4) -> str:\n        \"\"\"Preserve spaces and tabs in the provided text.\"\"\"\n        return text.replace(\" \", \"&nbsp;\").replace(\"\\t\", \"&nbsp;\" * tab_width)\n\n    for json_file in Path(directory).rglob('*.json'):\n        dataset = read_file(json_file)\n        if not dataset:\n            continue\n\n        html_file = json_file.with_suffix('.html')\n        html_content = \"\"\"\n        <html>\n        <head>\n            <style>\n                table {border-collapse: collapse; width: 100%; table-layout: fixed;}\n                th, td {\n                    border: 1px solid black;\n                    padding: 8px;\n                    text-align: left;\n                    white-space: pre-line;\n                    vertical-align: top;\n                    word-wrap: break-word;\n                }\n            </style>\n        </head>\n        <body>\n            <table>\n                <thead>\n                    <tr>\n        \"\"\"\n        column_count = len(dataset[0].keys())\n        column_width = 100 / column_count  # Calculate the width for each column based on the number of columns\n        for key in dataset[0].keys():\n            html_content += f\"<th style='width: {column_width}%;'>{key}</th>\"\n        html_content += \"\"\"\n                    </tr>\n                </thead>\n                <tbody>\n        \"\"\"\n        for entry in dataset:\n            html_content += \"<tr>\"\n            for key in entry:\n                # Convert \\n to HTML line breaks\n                value = escape(str(entry[key]))\n                value = preserve_spacing(value)\n                value = value.replace('\\n', '<br/>')\n                html_content += f\"<td>{value}</td>\"\n            html_content += \"</tr>\"\n\n        html_content += \"\"\"\n                </tbody>\n            </table>\n        </body>\n        </html>\n        \"\"\"\n        html_file_path = json_file.with_suffix('.html')\n        try:   \n            with open(html_file_path, 'w', encoding='utf-8') as file:\n                file.write(html_content)\n        except:\n            logging.save(logging.info(f'Failed saving: {html_file_path}'))\n\n\ndef combine_json_files(directory: str) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Combine all JSON files in the output directory into 'instruct.json', and then remove duplicates.\n    Args:\n        directory (str): The directory where the output files are located.\n    Returns:\n        A dictionary containing the 'instruct_list' datasets.\n    \"\"\"\n   \n    def remove_duplicate_dataset_entries(dataset: List[Dict], key1: str, key2: str) -> List[Dict]:\n        \"\"\"\n        Remove duplicate entries from the provided dataset based on the provided keys.\n        Args:\n            dataset (List[Dict]): The dataset to remove duplicates from.\n            key1 (str): The first key to check for duplicates.\n            key2 (str): The second key to check for duplicates.\n        Returns:\n            A dataset without duplicate entries.\n        \"\"\"\n        seen = set()\n        result = []\n        for item in dataset:\n            if (item[key1], item[key2]) not in seen:\n                seen.add((item[key1], item[key2]))\n                result.append(item)\n        return result\n\n    instruct_data = []\n    for file_name in ['instruct.json']:\n        file_path = Path(directory) / file_name\n        combined_data = []\n        for json_file in Path(directory).rglob(f'*.{file_name}'):\n            json_file_data = read_file(json_file)\n            combined_data.extend(json_file_data)\n            combined_data = remove_duplicate_dataset_entries(combined_data, 'instruction', 'output')\n            instruct_data = combined_data.copy()\n            # gen training datasets that contains purpose and graph data formatted as follow for each item in the dataset:\n            purpose_data = [item for item in combined_data if item['instruction'].startswith('1) Describe the purpose')]\n            graph_data = [item for item in combined_data if item['instruction'].startswith('What is the call code graph')]\n            code_output = []\n            graph_output = []\n            for item in purpose_data:\n                code_output.append({'instruction': 'Define the Python code file that is described as follows:\\n'+ item['output'], 'output': item['input']})\n            for item in graph_data:\n                graph_output.append({'instruction': 'Define the call code graph for Python file:\\n' + item['input'], 'output': item['output']})\n            code_graph_output = code_output + graph_output\n            write_file(code_graph_output, Path(directory) / 'training.json')\n\n        write_file(combined_data, file_path)\n\n    # Save html file for each json file in the output directory\n    convert_json_to_html(directory)\n    return {'instruct_list': instruct_data}\n\n\ndef create_code_graph(file_details: Dict, base_name: str, output_subdir: Path) -> None:\n    \"\"\"\n    Generate graphs from the file_details and save them as PNG images.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        base_name (str): The base name of the output files.\n        output_subdir (Path): The subdirectory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    graph_type = 'entire_code_graph'\n    output_file = output_subdir / f'{base_name}.{graph_type}.png'\n\n    # Create graphs, add nodes, and add edges\n    G = nx.DiGraph()\n    G.add_nodes_from(file_details['file_info'][graph_type]['nodes'])\n    for edge in file_details['file_info'][graph_type]['edges']:\n        source, target = edge['source'], edge['target']\n        if source in G.nodes and target in G.nodes:\n           G.add_edge(source, target, **{k: v for k, v in edge.items() if k in ['target_inputs', 'target_returns']})\n    # Draw graphs\n    plt.figure(figsize=(20, 20))\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, font_weight='bold', font_size = 8, node_shape='s', node_size=500, width=1, arrowsize=12)\n    edge_labels = {}\n    for edge in G.edges(data=True):\n        label = []\n        if 'target_inputs' in edge[2] and edge[2]['target_inputs']:\n            label.append(f\"Inputs: {', '.join(edge[2]['target_inputs'])}\")\n        if 'target_returns' in edge[2] and edge[2]['target_returns']:\n            label.append(f\"\\nReturns: {', '.join(edge[2]['target_returns'])}\")\n        edge_labels[(edge[0], edge[1])] = '\\n'.join(label)\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=6)\n    plt.savefig(output_file) # Save the figure\n    plt.close()  # Close the figure\n\n\ndef save_python_data(file_details: dict, instruct_list: list, relative_path: Path, output_dir: str) -> None:\n    \"\"\"\n    Save Python file details as a YAML file, the instruction data as a JSON file, and code graphs.\n    Args:\n        file_details (dict): The details extracted from the Python file.\n        instruct_list (list): The instruction data extracted from the Python file.\n        relative_path (Path): The relative path to the Python file.\n        output_dir (str): The directory where the output files will be saved.\n    Returns:\n        None\n    \"\"\"\n    output_subdir = Path(output_dir) / relative_path.parts[0]\n    output_subdir.mkdir(parents=True, exist_ok=True)\n    base_name = '.'.join(part for part in relative_path.parts)\n\n    # write instrunct.json files\n    file_names = [f'{base_name}.instruct.json', f'{base_name}.details.yaml']\n    contents = [instruct_list, file_details]\n\n    for file_name, content in zip(file_names, contents):\n        write_file(content, output_subdir / file_name)\n\n    try:\n        create_code_graph(file_details, base_name, output_subdir)\n    except:\n        logging.info(f'Error creating graph for {base_name}')\n",
        "output": "The purpose of this Python file is to provide utility functions for reading the input and saving the output of the py2dataset script. It includes functions such as read_file(), write_file(), convert_json_to_html(), combine_json_files(), create_code_graph(), and save_python_data(). The functions are used to read JSON or YAML files, convert JSON files to HTML format, merge all JSON files in a given directory, remove duplicates from the combined JSON files, write the data as JSON or YAML files, generate code graphs based on provided file details, and save Python file details as a YAML file.\n\n1. read_file() - This function reads a JSON or YAML file and returns its contents as a dictionary. It takes in a file path as an argument and opens the file using the appropriate method (json.load() for JSON files and yaml.load() for YAML files) to load the data into a Python dictionary.\n2. write_file() - This function writes a dictionary to a JSON or YAML file. It takes in two arguments, \"data\" as a dictionary containing the information that needs to be written and \"file_path\" as the path to the output file. The appropriate method (json.dump() for JSON files and yaml.safe_dump()) is used to write the data to the file with proper indentation and spacing.\n3. convert_json_to_html() - This function converts all JSON files in a given directory into HTML format while preserving spacing and tabs in the \"input\" field. It first searches for JSON files in the provided directory using pathlib.Path.rglob() and loops through them to load their content. It then converts each dictionary of entries into an HTML table with appropriate CSS styles and saves it as a .html file.\n4. combine_json_files() - This function combines all JSON files in the output directory into \"instruct.json\" and removes duplicates based on the provided keys (\"instruction\" and \"output\"). It first creates an empty list called \"combined_data\". Then, it loops through each JSON file in the directory using pathlib.Path.rglob() to load its content into a dictionary called \"json_file_data\". The function then uses remove_duplicate_dataset_entries() to filter out duplicates from combined_data based on two keys (\"instruction\" and \"output\") before writing it back to instruct.json file. Additionally, it generates training data that contains purpose and graph data formatted as follow for each item in the dataset by extracting specific entries with regex pattern matching. Finally, it calls convert_json_to_html() function to save HTML files for each JSON file in the output directory.\n5. remove_duplicate_dataset_entries() - This function removes duplicate entries from a provided list of dictionaries based on two keys (\"instruction\" and \"output\"). It initializes an empty set called \"seen\", an empty list called \"result\". Then, it loops through each item in the dataset and checks if the tuple (item[\"instruction\"], item[\"output\"]) is already present in seen. If not, it adds it to both seen and result sets. The function returns a list without duplicate entries based on those two keys.\n6. create_code_graph() - This function takes \"file_details\", a base name, and an output directory as arguments and generates code graphs based on the provided file details using networkx library. It creates a directed graph (DiGraph) called G, adds nodes from \"file_info\"[\"nodes\"], and then loops through each edge in \"file_info\"[\"edges\"] to add edges with their respective inputs and returns. The function then uses nx.draw() to draw the graph, labels the edges based on input and return values, and saves it as a PNG image using plt.savefig().\n7. save_python_data() - This function takes \"file_details\", \"instruct_list\", \"relative_path\", and \"output_dir\" as arguments and saves Python file details as a YAML file, the instruction data as a JSON file, and code graphs. It first creates an output directory using pathlib.Path().mkdir() method if it does not exist. Then, it loops through each entry in instruct_list and generates two different JSON files (\"details\" and \"instruct\") by filtering entries that start with specific patterns (1) Describe the Python code file that is described as follows: and What is the call code graph for Python file:). It also calls create_code_graph() to generate a PNG image of the entire code graph.\n8. The function read_file() takes in a \"file_path\" argument, checks its extension using file_path.suffix[1:] (i.e., 'json' or 'yaml') and loads it accordingly with either json.load() or yaml.load(). It returns the contents of the file as a dictionary.\n9. The function write_file() takes in two arguments, \"data\" as a dictionary containing the information that needs to be written and \"file_path\" as the path to the output file. It uses appropriate methods (json.dump() for JSON files and yaml.safe_dump()) to write the data to the file with proper indentation and spacing.\n10. The function preserve_spacing() takes in a \"text\" argument and preserves spaces and tabs while converting it into HTML format by replacing spaces with &nbsp; and tabs with &nbsp; * tab_width (default 4).\n\nReasons to follow: The requirements from the code problem indicate that read_file should open either a JSON or YAML file using an appropriate loader. Therefore, \"try-except\" blocks are added around the two possible load methods for different types of files and it will use json.load() if it is unable to load with yaml.load(). Additionally, it has some comments and indentation rules in line 59 and 62. write_file uses both SafeDumper from PyYAML to preserve the order of dictionaries and indent=4 for JSON files. The function convert_json_to_html() is used to generate HTML tables from JSON files while preserving spacing and tabs, which are replaced with &nbsp; and <br/> tags respectively. It also uses pathlib.Path.rglob() to search for all .json files in a given directory, as specified in the problem requirements.\nThe function remove_duplicate_dataset_entries() removes duplicate entries from \"dataset\" by iterating over each item in the list and checking if its (instruction, output) tuple is already present in \"seen\", an empty set. It adds the new items to \"result\" if it is not a duplicate and returns the updated list. The function then filters out purpose and graph data from instruct_list, which is combined with code data using regex patterns and saved as training.json file.\nThe function create_code_graph() takes in \"file_details\", \"base_name\", and \"output_subdir\" to generate call code graphs based on the provided information using networkx library and save it as a PNG image using plt.savefig(). The base name is used to create a unique file name for each graph.\nThe function save_python_data() takes in \"file_details\", \"instruct_list\", \"relative_path\" (as str), and \"output_dir\". It uses Path() method to create an output directory if it does not exist, and then creates two JSON files: details.json and instruct.json. It also calls create_code_graph() to generate PNG images of the entire code graph and saves them in the same directory as instruct.json.\nVariables: \n- file_type (str): The type of file based on its extension (either 'yaml' or 'json')\n- html_content (str): The HTML content for each table, including CSS styles and headers\n- column_count (int): The number of columns in the \"input\" and \"output\" data tables, to set fixed width for them as 1/3 and 2/3. It will help determine column_width\n- html_file (Path): The output file path with a .html extension\n- seen (set): A set used to store unique (instruction, output) tuples to avoid duplicates in \"combine_json_files()\" function\n- dataset (list): The list of dictionaries extracted from each JSON file, contains 'instruct', 'output', and other information such as call nodes/edges for creating a code graph\n- pos: the node positions determined by nx.spring_layout() function used to position the nodes on the network plot.\n- result (list): An empty list of combined JSON data from multiple files\n- edge_labels (dict): A dictionary that maps edges to their respective input and return values, for displaying them as labels in the graph\n- output_file (Path): The path where the PNG image will be saved"
    }
]