file_info:
  file_code: "\"\"\"\nUse AST to extract details from a Python file, determine the\
    \ code call graph and return it as a dictionary.\nRequirements:\n[req01] The get_all_calls\
    \ function shall:\n        a. Accept a node of type ast.AST as an argument.\n\
    \        b. Recursively find all function calls in the subtree rooted at the node.\n\
    \        c. Return a dictionary of all function calls in the subtree rooted at\
    \ the node with the function names as keys and their respective arguments as values.\n\
    [req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input\
    \ when instantiated.\n        b. Use the AST to extract details about the code.\n\
    \        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the `visit_FunctionDef`\
    \ method to gather details about functions.\n        e. Implement the `visit_ClassDef`\
    \ method to gather details about classes.\n        f. Implement the `extract_details`\
    \ method to parse information about a given node and return a dictionary containing\
    \ relevant details.\n        g. Implement the `analyze` method to traverse the\
    \ AST, list all nodes within the current file, and populate the 'file_info' attribute\
    \ with comprehensive file details.\n        h. Maintain a current class context\
    \ using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n\
    \        a. Accept the file summary as input.\n        b. Construct a directed\
    \ graph with nodes and edges that illustrate code relationships using the networkx\
    \ library.\n        c. Define elements such as function nodes, class nodes, and\
    \ method nodes.\n        d. Specify edges to represent relationships like function\
    \ calls, method calls, and class inheritance.\n        e. Return a dictionary\
    \ representation of the code graph, aiding in understanding the code's structure\
    \ and inter-relationships.\n[req04] The `get_python_file_details` function shall:\n\
    \        a. Accept a file path as an argument.\n        b. Extract detailed information\
    \ from the specified Python file using the AST and the `CodeVisitor` class.\n\
    \        c. Include the entire code graph in the returned details.\n        d.\
    \ Return a dictionary encompassing the extracted file details or None if there's\
    \ an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments`\
    \ function shall:\n        a. Accept a Python code string as an argument.\n  \
    \      b. Remove docstrings and comments from the provided code.\n        c. Return\
    \ the sanitized code string.\n\"\"\"\nimport ast\nimport re\nimport json\nimport\
    \ astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List,\
    \ Optional, Union\n\ndef remove_docs_and_comments(code: str) -> str:\n    \"\"\
    \"\n    Remove docstrings and comments from the provided code.\n    Args:\n  \
    \      code: str: The source code.\n    Returns:\n        str: The sanitized code.\n\
    \    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n\
    \        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value,\
    \ (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n  \
    \      elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n\
    \            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n\
    \    return astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST)\
    \ -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls\
    \ in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node\
    \ to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary\
    \ with function calls as keys and their arguments as values.\n    \"\"\"\n   \
    \ calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child,\
    \ ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for\
    \ arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls\n\
    \n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing\
    \ an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n\
    \        code (str): The source code.\n        functions(Dict): details about\
    \ functions in the code.\n        classes (Dict): details about classes in the\
    \ code.\n        file_info (Dict): details about the file.\n    Methods:\n   \
    \     visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract\
    \ details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\
    \ \n            Extract details about a class.\n        extract_details(node:\
    \ ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n           \
    \ Extract details about a node.\n        analyze(node: ast.AST) -> None: \n  \
    \          Populate file_info with details about the file.\n    \"\"\"\n    def\
    \ __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance\
    \ of the class.\n        Args:\n            code: str: The source code.\n    \
    \    Returns:\n            None\n        \"\"\"\n        self.code: str = code\n\
    \        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n  \
    \      self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n      \
    \  self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class:\
    \ str = None\n    \n    def visit_FunctionDef(self, node: ast.FunctionDef) ->\
    \ None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n\
    \            node: ast.FunctionDef: The node to visit.\n        Returns:\n   \
    \         None\n        \"\"\"\n        details = self.extract_details(node, 'method'\
    \ if self.current_class else 'function')\n        if self.current_class:\n   \
    \         self.classes[self.current_class][f'class_method_{node.name}'] = details\n\
    \        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\
    \n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n\
    \        Extract details about a class.\n        Args:\n            node: ast.ClassDef:\
    \ The node to visit.\n        Returns:\n            None\n        \"\"\"\n   \
    \     self.classes[node.name] = self.extract_details(node, 'class') # populate\
    \ class dictionary when class definition found in AST\n        self.current_class\
    \ = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)\
    \ # continue AST traversal to the next node\n        self.current_class = None\
    \  # reset current_class when finished with this class\n    \n    def extract_details(self,\
    \ node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n      \
    \  \"\"\"\n        Extract details about a node.\n        Args:\n            node:\
    \ ast.AST: The node to extract details from.\n            node_type: str: The\
    \ type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]:\
    \ The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n\
    \        call_data = get_all_calls(node)\n        details = {\n            f'{node_type}_name':\
    \ node.name, \n            f'{node_type}_code': ast.unparse(node),\n         \
    \   f'{node_type}_ast': ast.dump(node), \n            f'{node_type}_docstring':\
    \ next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value,\
    \ ast.Str)), None),\n            f'{node_type}_inputs': [arg.arg for arg in node.args.args]\
    \ if node_type in ['function', 'method'] else None,\n            f'{node_type}_defaults':\
    \ [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method']\
    \ else None,\n            f'{node_type}_returns': [ast.unparse(subnode.value)\
    \ if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode,\
    \ ast.Return)],\n            f'{node_type}_calls': list(call_data.keys()),\n \
    \           f'{node_type}_call_inputs': call_data, \n            f'{node_type}_variables':\
    \ list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign)\
    \ for target in subnode.targets if isinstance(target, ast.Name)}),\n         \
    \   f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list}\
    \ if node.decorator_list else set()),\n            f'{node_type}_annotations':\
    \ list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode,\
    \ ast.AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties':\
    \ list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute)\
    \ and isinstance(subnode.ctx, ast.Store)}),\n        }  \n        if node_type\
    \ in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\
    \ # find attributes defined as self.attribute\n                attributes = [target.attr\
    \ for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets\
    \ if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name)\
    \ and target.value.id == 'self']\n                self.classes[self.current_class].setdefault('class_attributes',\
    \ []).extend(attributes)\n            if node_type == 'class':\n             \
    \   details.update({\n                    'class_attributes': [target.attr for\
    \ subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets\
    \ if isinstance(target, ast.Attribute)],\n                    'class_methods':\
    \ [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)\
    \ and subnode.name != \"__init__\"],\n                    'class_inheritance':\
    \ [ast.unparse(base) for base in node.bases] if node.bases else [],\n        \
    \            'class_static_methods': [subnode.name for subnode in node.body if\
    \ isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator,\
    \ ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n\
    \                    })\n        return details\n\n    def analyze(self, node:\
    \ ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node',\
    \ create a list of all nodes within the current file, and populate 'file_info'\
    \ with file details\n        Args:\n            node: ast.AST: The node to analyze.\n\
    \        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n\
    \        self.visit(node)\n        self.file_info = {\n            'file_code':\
    \ self.code,\n            'file_ast' : ast.dump(node),\n            'file_dependencies':\
    \ list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import)\
    \ for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode,\
    \ ast.ImportFrom)}),\n            'file_functions': list(self.functions.keys()),\n\
    \            'file_classes': list(self.classes.keys()),\n        }\n        \n\
    \        # add file_summary to file_info\n        function_defs = [{func_name:\
    \ {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs':\
    \ details['function_call_inputs'], 'returns': details['function_returns']}} for\
    \ func_name, details in self.functions.items()]\n        class_defs = []\n   \
    \     for class_name, class_details in self.classes.items():\n            method_defs\
    \ = {}\n            for method_name, details in class_details.items():\n     \
    \           if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]]\
    \ = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs':\
    \ details['method_call_inputs'], 'returns': details['method_returns']}\n     \
    \       class_defs.append({class_name: {'method_defs': method_defs}})\n      \
    \  self.file_info['file_summary'] = { 'dependencies': self.file_info['file_dependencies'],\
    \ 'function_defs' : function_defs, 'class_defs' : class_defs}\n        \n    \
    \    file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n    \
    \    self.file_info['file_code_simplified'] = file_code_simplified\n\n\ndef code_graph(file_summary:\
    \ Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n\
    \    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n\
    \        file_summary: Dict[str, Union[Dict, str]]: The details extracted from\
    \ the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing\
    \ the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create\
    \ lookup dictionaries for function and class method details\n    function_details_lookup\
    \ = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n\
    \    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n\
    \        for class_name, class_details in class_def.items(): # Extract class name\
    \ and details\n            G.add_node(class_name) # Add class as a graph node\n\
    \            for method_name, method_details in class_details['method_defs'].items():\n\
    \                qualified_method_name = f'{class_name}.{method_name}' # Create\
    \ method fully qualified name\n                G.add_node(qualified_method_name)\
    \ # Add method as a graph node\n                class_method_details_lookup[qualified_method_name]\
    \ = method_details  # Store method details \n                G.add_edge(class_name,\
    \ qualified_method_name) # Add edge from class to method\n\n    # Helper function\
    \ to extract edge data from target details\n    def get_edge_data_from_details(target_details:\
    \ dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n\
    \        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n\
    \            edge_data['target_returns'] = list(set(target_details.get('returns',\
    \ [])))\n        if source_details and 'call_inputs' in source_details and target\
    \ in source_details['call_inputs']:\n            edge_data['target_inputs'] =\
    \ source_details['call_inputs'][target]     \n        return edge_data\n\n   \
    \ # Helper function to add edge with data\n    def add_edge_with_data(source:\
    \ str, target: str, init_method: Optional[str] = None) -> None:\n        target_details\
    \ = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n\
    \        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n\
    \        G.add_edge(source, target, **get_edge_data_from_details(target_details,\
    \ source_details, target))\n\n    # Helper function to add edges for function\
    \ or class method calls\n    def add_edges_for_calls(source_name, calls):\n  \
    \      class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n\
    \        for called in calls:\n            called_class_name = called.split('.')[0]\n\
    \            if called.startswith(\"self.\"):\n                method_name = called.replace(\"\
    self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
    \n                if fully_qualified_name in class_method_details_lookup:\n  \
    \                  add_edge_with_data(source_name, fully_qualified_name)\n   \
    \                 continue\n            if (\n                called in function_details_lookup\
    \ or \n                called in class_method_details_lookup or \n           \
    \     f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup\n\
    \            ):\n                add_edge_with_data(source_name, called)\n   \
    \         elif called_class_name in class_names:\n                init_method\
    \ = None\n                init_method_name = f\"{called}.__init__\"\n        \
    \        if init_method_name in class_method_details_lookup:\n               \
    \     init_method = init_method_name\n                add_edge_with_data(source_name,\
    \ called, init_method)\n            else:\n                G.add_node(called)\n\
    \                add_edge_with_data(source_name, called)\n\n    # Add function\
    \ nodes to graph and edges for function calls\n    for function_name in function_details_lookup.keys():\n\
    \        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n\
    \        add_edges_for_calls(func_name, details['calls'])\n\n    # Add edges for\
    \ method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n\
    \        add_edges_for_calls(qualified_method_name, details['calls'])\n\n    #\
    \ Add edge data to edges and create node and edges to return\n    for edge in\
    \ G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target)\
    \ or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source)\
    \ or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details,\
    \ source_details, target)\n        G[source][target].update(edge_data)\n    nodes\
    \ = list(G.nodes)\n    edges = [{\"source\": edge[0], \"target\": edge[1], **edge[2]}\
    \ for edge in G.edges.data()]\n    return {\"nodes\": nodes, \"edges\": edges}\n\
    \n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n\
    \    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path:\
    \ str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict,\
    \ str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with\
    \ open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n        \
    \    code = f.read()\n            tree = ast.parse(code)\n    except:\n      \
    \  logging.warning(f\"Permission denied or syntax error in file: {file_path}\"\
    )\n        return None \n\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n\
    \    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions,\
    \ 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph']\
    \ = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary']\
    \ = json.dumps(file_details['file_info']['file_summary']).replace('\\\"','')\n\
    \    return file_details"
  file_ast: 'Module(body=[Expr(value=Constant(value="\nUse AST to extract details
    from a Python file, determine the code call graph and return it as a dictionary.\nRequirements:\n[req01]
    The get_all_calls function shall:\n        a. Accept a node of type ast.AST as
    an argument.\n        b. Recursively find all function calls in the subtree rooted
    at the node.\n        c. Return a dictionary of all function calls in the subtree
    rooted at the node with the function names as keys and their respective arguments
    as values.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source
    code as input when instantiated.\n        b. Use the AST to extract details about
    the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the
    `visit_FunctionDef` method to gather details about functions.\n        e. Implement
    the `visit_ClassDef` method to gather details about classes.\n        f. Implement
    the `extract_details` method to parse information about a given node and return
    a dictionary containing relevant details.\n        g. Implement the `analyze`
    method to traverse the AST, list all nodes within the current file, and populate
    the ''file_info'' attribute with comprehensive file details.\n        h. Maintain
    a current class context using the attribute ''current_class''.\n[req03] The `code_graph`
    function shall:\n        a. Accept the file summary as input.\n        b. Construct
    a directed graph with nodes and edges that illustrate code relationships using
    the networkx library.\n        c. Define elements such as function nodes, class
    nodes, and method nodes.\n        d. Specify edges to represent relationships
    like function calls, method calls, and class inheritance.\n        e. Return a
    dictionary representation of the code graph, aiding in understanding the code''s
    structure and inter-relationships.\n[req04] The `get_python_file_details` function
    shall:\n        a. Accept a file path as an argument.\n        b. Extract detailed
    information from the specified Python file using the AST and the `CodeVisitor`
    class.\n        c. Include the entire code graph in the returned details.\n        d.
    Return a dictionary encompassing the extracted file details or None if there''s
    an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments`
    function shall:\n        a. Accept a Python code string as an argument.\n        b.
    Remove docstrings and comments from the provided code.\n        c. Return the
    sanitized code string.\n")), Import(names=[alias(name=''ast'')]), Import(names=[alias(name=''re'')]),
    Import(names=[alias(name=''json'')]), Import(names=[alias(name=''astor'')]), Import(names=[alias(name=''logging'')]),
    Import(names=[alias(name=''networkx'', asname=''nx'')]), ImportFrom(module=''typing'',
    names=[alias(name=''Dict''), alias(name=''List''), alias(name=''Optional''), alias(name=''Union'')],
    level=0), FunctionDef(name=''remove_docs_and_comments'', args=arguments(posonlyargs=[],
    args=[arg(arg=''code'', annotation=Name(id=''str'', ctx=Load()))], kwonlyargs=[],
    kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Remove docstrings
    and comments from the provided code.\n    Args:\n        code: str: The source
    code.\n    Returns:\n        str: The sanitized code.\n    '')), Assign(targets=[Name(id=''parsed'',
    ctx=Store())], value=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''parse'',
    ctx=Load()), args=[Name(id=''code'', ctx=Load())], keywords=[])), For(target=Name(id=''node'',
    ctx=Store()), iter=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''walk'',
    ctx=Load()), args=[Name(id=''parsed'', ctx=Load())], keywords=[]), body=[If(test=BoolOp(op=And(),
    values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''node'',
    ctx=Load()), Tuple(elts=[Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Expr'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Constant'',
    ctx=Load())], ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'', ctx=Load()),
    args=[Attribute(value=Name(id=''node'', ctx=Load()), attr=''value'', ctx=Load()),
    Tuple(elts=[Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Str'', ctx=Load()),
    Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Bytes'', ctx=Load())], ctx=Load())],
    keywords=[])]), body=[Assign(targets=[Attribute(value=Name(id=''node'', ctx=Load()),
    attr=''value'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Constant'', ctx=Load()), args=[], keywords=[keyword(arg=''value'',
    value=Constant(value=''''))]))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''node'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Constant'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Attribute(value=Name(id=''node'', ctx=Load()), attr=''value'',
    ctx=Load()), Name(id=''str'', ctx=Load())], keywords=[])]), body=[Assign(targets=[Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''value'', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''value'', ctx=Load()), attr=''replace'', ctx=Load()), args=[Constant(value=''"""''),
    Constant(value='''')], keywords=[]), attr=''replace'', ctx=Load()), args=[Constant(value="''''''"),
    Constant(value='''')], keywords=[]))], orelse=[])])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id=''astor'',
    ctx=Load()), attr=''to_source'', ctx=Load()), args=[Name(id=''parsed'', ctx=Load())],
    keywords=[]), attr=''strip'', ctx=Load()), args=[], keywords=[]))], decorator_list=[],
    returns=Name(id=''str'', ctx=Load())), FunctionDef(name=''get_all_calls'', args=arguments(posonlyargs=[],
    args=[arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''AST'', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Recursively
    find all function calls in the subtree rooted at `node`.\n    Args:\n        node
    (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str,
    List[str]]: A dictionary with function calls as keys and their arguments as values.\n    '')),
    Assign(targets=[Name(id=''calls'', ctx=Store())], value=Dict(keys=[], values=[])),
    For(target=Name(id=''child'', ctx=Store()), iter=Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''iter_child_nodes'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
    keywords=[]), body=[If(test=Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''child'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Call'', ctx=Load())],
    keywords=[]), body=[Assign(targets=[Subscript(value=Name(id=''calls'', ctx=Load()),
    slice=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''unparse'',
    ctx=Load()), args=[Attribute(value=Name(id=''child'', ctx=Load()), attr=''func'',
    ctx=Load())], keywords=[]), ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''arg'', ctx=Load())],
    keywords=[]), generators=[comprehension(target=Name(id=''arg'', ctx=Store()),
    iter=Attribute(value=Name(id=''child'', ctx=Load()), attr=''args'', ctx=Load()),
    ifs=[], is_async=0)]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id=''calls'',
    ctx=Load()), attr=''update'', ctx=Load()), args=[Call(func=Name(id=''get_all_calls'',
    ctx=Load()), args=[Name(id=''child'', ctx=Load())], keywords=[])], keywords=[]))],
    orelse=[]), Return(value=Name(id=''calls'', ctx=Load()))], decorator_list=[],
    returns=Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
    ctx=Load()), Subscript(value=Name(id=''List'', ctx=Load()), slice=Name(id=''str'',
    ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), ClassDef(name=''CodeVisitor'',
    bases=[Attribute(value=Name(id=''ast'', ctx=Load()), attr=''NodeVisitor'', ctx=Load())],
    keywords=[], body=[Expr(value=Constant(value=''\n    Visitor class for traversing
    an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code
    (str): The source code.\n        functions(Dict): details about functions in the
    code.\n        classes (Dict): details about classes in the code.\n        file_info
    (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node:
    ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node:
    ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node:
    ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract
    details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate
    file_info with details about the file.\n    '')), FunctionDef(name=''__init__'',
    args=arguments(posonlyargs=[], args=[arg(arg=''self''), arg(arg=''code'', annotation=Name(id=''str'',
    ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n        Initialize
    a new instance of the class.\n        Args:\n            code: str: The source
    code.\n        Returns:\n            None\n        '')), AnnAssign(target=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''code'', ctx=Store()), annotation=Name(id=''str'', ctx=Load()),
    value=Name(id=''code'', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''functions'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Dict'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
    ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())],
    ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]),
    simple=0), AnnAssign(target=Attribute(value=Name(id=''self'', ctx=Load()), attr=''classes'',
    ctx=Store()), annotation=Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
    ctx=Load()), Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
    ctx=Load()), Subscript(value=Name(id=''Union'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
    ctx=Load()), Subscript(value=Name(id=''List'', ctx=Load()), slice=Name(id=''str'',
    ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())],
    ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''file_info'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
    ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())],
    ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''current_class'', ctx=Store()), annotation=Name(id=''str'',
    ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name=''visit_FunctionDef'',
    args=arguments(posonlyargs=[], args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''FunctionDef'', ctx=Load()))], kwonlyargs=[], kw_defaults=[],
    defaults=[]), body=[Expr(value=Constant(value=''\n        Extract details about
    a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        '')),
    Assign(targets=[Name(id=''details'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''extract_details'', ctx=Load()), args=[Name(id=''node'', ctx=Load()),
    IfExp(test=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
    ctx=Load()), body=Constant(value=''method''), orelse=Constant(value=''function''))],
    keywords=[])), If(test=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
    ctx=Load()), body=[Assign(targets=[Subscript(value=Subscript(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''current_class'', ctx=Load()), ctx=Load()), slice=JoinedStr(values=[Constant(value=''class_method_''),
    FormattedValue(value=Attribute(value=Name(id=''node'', ctx=Load()), attr=''name'',
    ctx=Load()), conversion=-1)]), ctx=Store())], value=Name(id=''details'', ctx=Load()))],
    orelse=[Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'', ctx=Load()),
    attr=''functions'', ctx=Load()), slice=Attribute(value=Name(id=''node'', ctx=Load()),
    attr=''name'', ctx=Load()), ctx=Store())], value=Name(id=''details'', ctx=Load()))]),
    Expr(value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()), attr=''generic_visit'',
    ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[]))], decorator_list=[],
    returns=Constant(value=None)), FunctionDef(name=''visit_ClassDef'', args=arguments(posonlyargs=[],
    args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''ClassDef'', ctx=Load()))], kwonlyargs=[], kw_defaults=[],
    defaults=[]), body=[Expr(value=Constant(value=''\n        Extract details about
    a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        '')),
    Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'', ctx=Load()),
    attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''node'', ctx=Load()),
    attr=''name'', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''extract_details'', ctx=Load()), args=[Name(id=''node'', ctx=Load()),
    Constant(value=''class'')], keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''current_class'', ctx=Store())], value=Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''name'', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''generic_visit'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
    keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'', ctx=Load()),
    attr=''current_class'', ctx=Store())], value=Constant(value=None))], decorator_list=[],
    returns=Constant(value=None)), FunctionDef(name=''extract_details'', args=arguments(posonlyargs=[],
    args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''AST'', ctx=Load())), arg(arg=''node_type'', annotation=Name(id=''str'',
    ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n        Extract
    details about a node.\n        Args:\n            node: ast.AST: The node to extract
    details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str,
    Union[str, List[str]]]: The details extracted from the node.\n        '')), Assign(targets=[Name(id=''node_walk'',
    ctx=Store())], value=Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''walk'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
    keywords=[])], keywords=[])), Assign(targets=[Name(id=''call_data'', ctx=Store())],
    value=Call(func=Name(id=''get_all_calls'', ctx=Load()), args=[Name(id=''node'',
    ctx=Load())], keywords=[])), Assign(targets=[Name(id=''details'', ctx=Store())],
    value=Dict(keys=[JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_name'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_code'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_ast'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_docstring'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_inputs'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_defaults'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_returns'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_calls'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_call_inputs'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_variables'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_decorators'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_annotations'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
    ctx=Load()), conversion=-1), Constant(value=''_properties'')])], values=[Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''name'', ctx=Load()), Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
    keywords=[]), Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''dump'',
    ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[]), Call(func=Name(id=''next'',
    ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Attribute(value=Name(id=''n'',
    ctx=Load()), attr=''value'', ctx=Load()), attr=''s'', ctx=Load()), generators=[comprehension(target=Name(id=''n'',
    ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''n'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Expr'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Attribute(value=Name(id=''n'', ctx=Load()), attr=''value'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Str'', ctx=Load())],
    keywords=[])])], is_async=0)]), Constant(value=None)], keywords=[]), IfExp(test=Compare(left=Name(id=''node_type'',
    ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''function''),
    Constant(value=''method'')], ctx=Load())]), body=ListComp(elt=Attribute(value=Name(id=''arg'',
    ctx=Load()), attr=''arg'', ctx=Load()), generators=[comprehension(target=Name(id=''arg'',
    ctx=Store()), iter=Attribute(value=Attribute(value=Name(id=''node'', ctx=Load()),
    attr=''args'', ctx=Load()), attr=''args'', ctx=Load()), ifs=[], is_async=0)]),
    orelse=Constant(value=None)), IfExp(test=Compare(left=Name(id=''node_type'', ctx=Load()),
    ops=[In()], comparators=[List(elts=[Constant(value=''function''), Constant(value=''method'')],
    ctx=Load())]), body=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''unparse'', ctx=Load()), args=[Name(id=''d'', ctx=Load())], keywords=[]),
    generators=[comprehension(target=Name(id=''d'', ctx=Store()), iter=Attribute(value=Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''args'', ctx=Load()), attr=''defaults'', ctx=Load()), ifs=[],
    is_async=0)]), orelse=Constant(value=None)), ListComp(elt=IfExp(test=Compare(left=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''value'', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]),
    body=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''unparse'',
    ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''value'',
    ctx=Load())], keywords=[]), orelse=Constant(value=''None'')), generators=[comprehension(target=Name(id=''subnode'',
    ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Return'', ctx=Load())], keywords=[])], is_async=0)]), Call(func=Name(id=''list'',
    ctx=Load()), args=[Call(func=Attribute(value=Name(id=''call_data'', ctx=Load()),
    attr=''keys'', ctx=Load()), args=[], keywords=[])], keywords=[]), Name(id=''call_data'',
    ctx=Load()), Call(func=Name(id=''list'', ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''target'', ctx=Load())],
    keywords=[]), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
    iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Assign'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
    ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
    ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''target'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'', ctx=Load())],
    keywords=[])], is_async=0)])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()),
    args=[IfExp(test=Attribute(value=Name(id=''node'', ctx=Load()), attr=''decorator_list'',
    ctx=Load()), body=SetComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''unparse'', ctx=Load()), args=[Name(id=''decorator'', ctx=Load())], keywords=[]),
    generators=[comprehension(target=Name(id=''decorator'', ctx=Store()), iter=Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''decorator_list'', ctx=Load()), ifs=[], is_async=0)]), orelse=Call(func=Name(id=''set'',
    ctx=Load()), args=[], keywords=[]))], keywords=[]), Call(func=Name(id=''list'',
    ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''unparse'', ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()),
    attr=''annotation'', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id=''subnode'',
    ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''AnnAssign'', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''annotation'', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])])],
    is_async=0)])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''subnode'', ctx=Load())],
    keywords=[]), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
    iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Attribute'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''ctx'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Store'', ctx=Load())],
    keywords=[])])], is_async=0)])], keywords=[])])), If(test=Compare(left=Name(id=''node_type'',
    ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''class''), Constant(value=''method'')],
    ctx=Load())]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id=''node_type'',
    ctx=Load()), ops=[Eq()], comparators=[Constant(value=''method'')]), Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''current_class'', ctx=Load())]), body=[Assign(targets=[Name(id=''attributes'',
    ctx=Store())], value=ListComp(elt=Attribute(value=Name(id=''target'', ctx=Load()),
    attr=''attr'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
    ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Assign'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
    ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
    ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'', ctx=Load()),
    args=[Name(id=''target'', ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''Attribute'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Attribute(value=Name(id=''target'', ctx=Load()), attr=''value'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'', ctx=Load())],
    keywords=[]), Compare(left=Attribute(value=Attribute(value=Name(id=''target'',
    ctx=Load()), attr=''value'', ctx=Load()), attr=''id'', ctx=Load()), ops=[Eq()],
    comparators=[Constant(value=''self'')])])], is_async=0)])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''current_class'', ctx=Load()), ctx=Load()), attr=''setdefault'',
    ctx=Load()), args=[Constant(value=''class_attributes''), List(elts=[], ctx=Load())],
    keywords=[]), attr=''extend'', ctx=Load()), args=[Name(id=''attributes'', ctx=Load())],
    keywords=[]))], orelse=[]), If(test=Compare(left=Name(id=''node_type'', ctx=Load()),
    ops=[Eq()], comparators=[Constant(value=''class'')]), body=[Expr(value=Call(func=Attribute(value=Name(id=''details'',
    ctx=Load()), attr=''update'', ctx=Load()), args=[Dict(keys=[Constant(value=''class_attributes''),
    Constant(value=''class_methods''), Constant(value=''class_inheritance''), Constant(value=''class_static_methods'')],
    values=[ListComp(elt=Attribute(value=Name(id=''target'', ctx=Load()), attr=''attr'',
    ctx=Load()), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
    iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'', ctx=Load()),
    ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Assign'', ctx=Load())],
    keywords=[])], is_async=0), comprehension(target=Name(id=''target'', ctx=Store()),
    iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'', ctx=Load()),
    ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''target'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Attribute'',
    ctx=Load())], keywords=[])], is_async=0)]), ListComp(elt=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
    ctx=Store()), iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'',
    ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'', ctx=Load()),
    args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''FunctionDef'', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''name'', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=''__init__'')])])],
    is_async=0)]), IfExp(test=Attribute(value=Name(id=''node'', ctx=Load()), attr=''bases'',
    ctx=Load()), body=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''unparse'', ctx=Load()), args=[Name(id=''base'', ctx=Load())], keywords=[]),
    generators=[comprehension(target=Name(id=''base'', ctx=Store()), iter=Attribute(value=Name(id=''node'',
    ctx=Load()), attr=''bases'', ctx=Load()), ifs=[], is_async=0)]), orelse=List(elts=[],
    ctx=Load())), ListComp(elt=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''name'',
    ctx=Load()), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
    iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'', ctx=Load()),
    ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''FunctionDef'',
    ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''name'', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=''__init__'')]),
    Call(func=Name(id=''any'', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(),
    values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''decorator'',
    ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'', ctx=Load())],
    keywords=[]), Compare(left=Attribute(value=Name(id=''decorator'', ctx=Load()),
    attr=''id'', ctx=Load()), ops=[Eq()], comparators=[Constant(value=''staticmethod'')])]),
    generators=[comprehension(target=Name(id=''decorator'', ctx=Store()), iter=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''decorator_list'', ctx=Load()), ifs=[], is_async=0)])], keywords=[])])],
    is_async=0)])])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id=''details'',
    ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id=''Dict'', ctx=Load()),
    slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
    ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())],
    ctx=Load()), ctx=Load())), FunctionDef(name=''analyze'', args=arguments(posonlyargs=[],
    args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''AST'', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]),
    body=[Expr(value=Constant(value="\n        Traverse the AST rooted at ''node'',
    create a list of all nodes within the current file, and populate ''file_info''
    with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        ")),
    Assign(targets=[Name(id=''node_walk'', ctx=Store())], value=Call(func=Name(id=''list'',
    ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''walk'',
    ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])], keywords=[])),
    Expr(value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()), attr=''visit'',
    ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''file_info'', ctx=Store())], value=Dict(keys=[Constant(value=''file_code''),
    Constant(value=''file_ast''), Constant(value=''file_dependencies''), Constant(value=''file_functions''),
    Constant(value=''file_classes'')], values=[Attribute(value=Name(id=''self'', ctx=Load()),
    attr=''code'', ctx=Load()), Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
    attr=''dump'', ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[]),
    Call(func=Name(id=''list'', ctx=Load()), args=[BinOp(left=SetComp(elt=Attribute(value=Name(id=''alias'',
    ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
    ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''Import'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''alias'',
    ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''names'',
    ctx=Load()), ifs=[], is_async=0)]), op=BitOr(), right=SetComp(elt=Attribute(value=Name(id=''subnode'',
    ctx=Load()), attr=''module'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
    ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
    ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
    ctx=Load()), attr=''ImportFrom'', ctx=Load())], keywords=[])], is_async=0)]))],
    keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''functions'', ctx=Load()), attr=''keys'', ctx=Load()), args=[],
    keywords=[])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''classes'', ctx=Load()), attr=''keys'', ctx=Load()), args=[],
    keywords=[])], keywords=[])])), Assign(targets=[Name(id=''function_defs'', ctx=Store())],
    value=ListComp(elt=Dict(keys=[Name(id=''func_name'', ctx=Load())], values=[Dict(keys=[Constant(value=''inputs''),
    Constant(value=''calls''), Constant(value=''call_inputs''), Constant(value=''returns'')],
    values=[Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_inputs''),
    ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_calls''),
    ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_call_inputs''),
    ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_returns''),
    ctx=Load())])]), generators=[comprehension(target=Tuple(elts=[Name(id=''func_name'',
    ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''functions'', ctx=Load()), attr=''items'', ctx=Load()), args=[],
    keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id=''class_defs'',
    ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id=''class_name'',
    ctx=Store()), Name(id=''class_details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''classes'', ctx=Load()), attr=''items'', ctx=Load()), args=[],
    keywords=[]), body=[Assign(targets=[Name(id=''method_defs'', ctx=Store())], value=Dict(keys=[],
    values=[])), For(target=Tuple(elts=[Name(id=''method_name'', ctx=Store()), Name(id=''details'',
    ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_details'',
    ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id=''method_name'',
    ctx=Load()), attr=''startswith'', ctx=Load()), args=[Constant(value=''class_method_'')],
    keywords=[]), body=[Assign(targets=[Subscript(value=Name(id=''method_defs'', ctx=Load()),
    slice=Subscript(value=Name(id=''method_name'', ctx=Load()), slice=Slice(lower=Call(func=Name(id=''len'',
    ctx=Load()), args=[Constant(value=''class_method_'')], keywords=[])), ctx=Load()),
    ctx=Store())], value=Dict(keys=[Constant(value=''inputs''), Constant(value=''calls''),
    Constant(value=''call_inputs''), Constant(value=''returns'')], values=[Subscript(value=Name(id=''details'',
    ctx=Load()), slice=Constant(value=''method_inputs''), ctx=Load()), Subscript(value=Name(id=''details'',
    ctx=Load()), slice=Constant(value=''method_calls''), ctx=Load()), Subscript(value=Name(id=''details'',
    ctx=Load()), slice=Constant(value=''method_call_inputs''), ctx=Load()), Subscript(value=Name(id=''details'',
    ctx=Load()), slice=Constant(value=''method_returns''), ctx=Load())]))], orelse=[])],
    orelse=[]), Expr(value=Call(func=Attribute(value=Name(id=''class_defs'', ctx=Load()),
    attr=''append'', ctx=Load()), args=[Dict(keys=[Name(id=''class_name'', ctx=Load())],
    values=[Dict(keys=[Constant(value=''method_defs'')], values=[Name(id=''method_defs'',
    ctx=Load())])])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_summary''),
    ctx=Store())], value=Dict(keys=[Constant(value=''dependencies''), Constant(value=''function_defs''),
    Constant(value=''class_defs'')], values=[Subscript(value=Attribute(value=Name(id=''self'',
    ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_dependencies''),
    ctx=Load()), Name(id=''function_defs'', ctx=Load()), Name(id=''class_defs'', ctx=Load())])),
    Assign(targets=[Name(id=''file_code_simplified'', ctx=Store())], value=Call(func=Name(id=''remove_docs_and_comments'',
    ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''unparse'',
    ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])], keywords=[])),
    Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'', ctx=Load()),
    attr=''file_info'', ctx=Load()), slice=Constant(value=''file_code_simplified''),
    ctx=Store())], value=Name(id=''file_code_simplified'', ctx=Load()))], decorator_list=[],
    returns=Constant(value=None))], decorator_list=[]), FunctionDef(name=''code_graph'',
    args=arguments(posonlyargs=[], args=[arg(arg=''file_summary'', annotation=Subscript(value=Name(id=''Dict'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''Dict'', ctx=Load()), Name(id=''str'',
    ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[],
    kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Create a
    dictionary representation of file details.\n    Args:\n        file_summary: Dict[str,
    Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict:
    A dictionary with nodes and edges representing the relationships in the code.\n    '')),
    Assign(targets=[Name(id=''G'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''nx'',
    ctx=Load()), attr=''DiGraph'', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id=''function_details_lookup'',
    ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id=''function_def'',
    ctx=Store()), iter=Subscript(value=Name(id=''file_summary'', ctx=Load()), slice=Constant(value=''function_defs''),
    ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id=''function_details_lookup'',
    ctx=Load()), attr=''update'', ctx=Load()), args=[Name(id=''function_def'', ctx=Load())],
    keywords=[]))], orelse=[]), Assign(targets=[Name(id=''class_method_details_lookup'',
    ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id=''class_def'',
    ctx=Store()), iter=Subscript(value=Name(id=''file_summary'', ctx=Load()), slice=Constant(value=''class_defs''),
    ctx=Load()), body=[For(target=Tuple(elts=[Name(id=''class_name'', ctx=Store()),
    Name(id=''class_details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_def'',
    ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''class_name'', ctx=Load())],
    keywords=[])), For(target=Tuple(elts=[Name(id=''method_name'', ctx=Store()), Name(id=''method_details'',
    ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Subscript(value=Name(id=''class_details'',
    ctx=Load()), slice=Constant(value=''method_defs''), ctx=Load()), attr=''items'',
    ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id=''qualified_method_name'',
    ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id=''class_name'',
    ctx=Load()), conversion=-1), Constant(value=''.''), FormattedValue(value=Name(id=''method_name'',
    ctx=Load()), conversion=-1)])), Expr(value=Call(func=Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''qualified_method_name'',
    ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id=''class_method_details_lookup'',
    ctx=Load()), slice=Name(id=''qualified_method_name'', ctx=Load()), ctx=Store())],
    value=Name(id=''method_details'', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''add_edge'', ctx=Load()), args=[Name(id=''class_name'', ctx=Load()),
    Name(id=''qualified_method_name'', ctx=Load())], keywords=[]))], orelse=[])],
    orelse=[])], orelse=[]), FunctionDef(name=''get_edge_data_from_details'', args=arguments(posonlyargs=[],
    args=[arg(arg=''target_details'', annotation=Name(id=''dict'', ctx=Load())), arg(arg=''source_details'',
    annotation=Name(id=''dict'', ctx=Load())), arg(arg=''target'', annotation=Name(id=''str'',
    ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id=''edge_data'',
    ctx=Store())], value=Dict(keys=[], values=[])), If(test=Name(id=''target_details'',
    ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id=''edge_data'', ctx=Load()),
    slice=Constant(value=''target_inputs''), ctx=Store())], value=Call(func=Attribute(value=Name(id=''target_details'',
    ctx=Load()), attr=''get'', ctx=Load()), args=[Constant(value=''inputs'')], keywords=[])),
    Assign(targets=[Subscript(value=Name(id=''edge_data'', ctx=Load()), slice=Constant(value=''target_returns''),
    ctx=Store())], value=Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Name(id=''set'',
    ctx=Load()), args=[Call(func=Attribute(value=Name(id=''target_details'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Constant(value=''returns''), List(elts=[], ctx=Load())],
    keywords=[])], keywords=[])], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(),
    values=[Name(id=''source_details'', ctx=Load()), Compare(left=Constant(value=''call_inputs''),
    ops=[In()], comparators=[Name(id=''source_details'', ctx=Load())]), Compare(left=Name(id=''target'',
    ctx=Load()), ops=[In()], comparators=[Subscript(value=Name(id=''source_details'',
    ctx=Load()), slice=Constant(value=''call_inputs''), ctx=Load())])]), body=[Assign(targets=[Subscript(value=Name(id=''edge_data'',
    ctx=Load()), slice=Constant(value=''target_inputs''), ctx=Store())], value=Subscript(value=Subscript(value=Name(id=''source_details'',
    ctx=Load()), slice=Constant(value=''call_inputs''), ctx=Load()), slice=Name(id=''target'',
    ctx=Load()), ctx=Load()))], orelse=[]), Return(value=Name(id=''edge_data'', ctx=Load()))],
    decorator_list=[], returns=Name(id=''dict'', ctx=Load())), FunctionDef(name=''add_edge_with_data'',
    args=arguments(posonlyargs=[], args=[arg(arg=''source'', annotation=Name(id=''str'',
    ctx=Load())), arg(arg=''target'', annotation=Name(id=''str'', ctx=Load())), arg(arg=''init_method'',
    annotation=Subscript(value=Name(id=''Optional'', ctx=Load()), slice=Name(id=''str'',
    ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]),
    body=[Assign(targets=[Name(id=''target_details'', ctx=Store())], value=BoolOp(op=Or(),
    values=[Call(func=Attribute(value=Name(id=''class_method_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id=''init_method'',
    ctx=Load()), Name(id=''target'', ctx=Load())])], keywords=[]), Call(func=Attribute(value=Name(id=''function_details_lookup'',
    ctx=Load()), attr=''get'', ctx=Load()), args=[Name(id=''target'', ctx=Load())],
    keywords=[])])), Assign(targets=[Name(id=''source_details'', ctx=Store())], value=BoolOp(op=Or(),
    values=[Call(func=Attribute(value=Name(id=''function_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())], keywords=[]),
    Call(func=Attribute(value=Name(id=''class_method_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())], keywords=[])])),
    Expr(value=Call(func=Attribute(value=Name(id=''G'', ctx=Load()), attr=''add_edge'',
    ctx=Load()), args=[Name(id=''source'', ctx=Load()), Name(id=''target'', ctx=Load())],
    keywords=[keyword(value=Call(func=Name(id=''get_edge_data_from_details'', ctx=Load()),
    args=[Name(id=''target_details'', ctx=Load()), Name(id=''source_details'', ctx=Load()),
    Name(id=''target'', ctx=Load())], keywords=[]))]))], decorator_list=[], returns=Constant(value=None)),
    FunctionDef(name=''add_edges_for_calls'', args=arguments(posonlyargs=[], args=[arg(arg=''source_name''),
    arg(arg=''calls'')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id=''class_names'',
    ctx=Store())], value=ListComp(elt=Subscript(value=Call(func=Name(id=''list'',
    ctx=Load()), args=[Call(func=Attribute(value=Name(id=''class_def'', ctx=Load()),
    attr=''keys'', ctx=Load()), args=[], keywords=[])], keywords=[]), slice=Constant(value=0),
    ctx=Load()), generators=[comprehension(target=Name(id=''class_def'', ctx=Store()),
    iter=Subscript(value=Name(id=''file_summary'', ctx=Load()), slice=Constant(value=''class_defs''),
    ctx=Load()), ifs=[], is_async=0)])), For(target=Name(id=''called'', ctx=Store()),
    iter=Name(id=''calls'', ctx=Load()), body=[Assign(targets=[Name(id=''called_class_name'',
    ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id=''called'',
    ctx=Load()), attr=''split'', ctx=Load()), args=[Constant(value=''.'')], keywords=[]),
    slice=Constant(value=0), ctx=Load())), If(test=Call(func=Attribute(value=Name(id=''called'',
    ctx=Load()), attr=''startswith'', ctx=Load()), args=[Constant(value=''self.'')],
    keywords=[]), body=[Assign(targets=[Name(id=''method_name'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''called'',
    ctx=Load()), attr=''replace'', ctx=Load()), args=[Constant(value=''self.''), Constant(value='''')],
    keywords=[])), Assign(targets=[Name(id=''fully_qualified_name'', ctx=Store())],
    value=JoinedStr(values=[FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id=''source_name'',
    ctx=Load()), attr=''split'', ctx=Load()), args=[Constant(value=''.'')], keywords=[]),
    slice=Constant(value=0), ctx=Load()), conversion=-1), Constant(value=''.''), FormattedValue(value=Name(id=''method_name'',
    ctx=Load()), conversion=-1)])), If(test=Compare(left=Name(id=''fully_qualified_name'',
    ctx=Load()), ops=[In()], comparators=[Name(id=''class_method_details_lookup'',
    ctx=Load())]), body=[Expr(value=Call(func=Name(id=''add_edge_with_data'', ctx=Load()),
    args=[Name(id=''source_name'', ctx=Load()), Name(id=''fully_qualified_name'',
    ctx=Load())], keywords=[])), Continue()], orelse=[])], orelse=[]), If(test=BoolOp(op=Or(),
    values=[Compare(left=Name(id=''called'', ctx=Load()), ops=[In()], comparators=[Name(id=''function_details_lookup'',
    ctx=Load())]), Compare(left=Name(id=''called'', ctx=Load()), ops=[In()], comparators=[Name(id=''class_method_details_lookup'',
    ctx=Load())]), Compare(left=JoinedStr(values=[FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id=''source_name'',
    ctx=Load()), attr=''split'', ctx=Load()), args=[Constant(value=''.'')], keywords=[]),
    slice=Constant(value=0), ctx=Load()), conversion=-1), Constant(value=''.''), FormattedValue(value=Name(id=''called'',
    ctx=Load()), conversion=-1)]), ops=[In()], comparators=[Name(id=''class_method_details_lookup'',
    ctx=Load())])]), body=[Expr(value=Call(func=Name(id=''add_edge_with_data'', ctx=Load()),
    args=[Name(id=''source_name'', ctx=Load()), Name(id=''called'', ctx=Load())],
    keywords=[]))], orelse=[If(test=Compare(left=Name(id=''called_class_name'', ctx=Load()),
    ops=[In()], comparators=[Name(id=''class_names'', ctx=Load())]), body=[Assign(targets=[Name(id=''init_method'',
    ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id=''init_method_name'',
    ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id=''called'',
    ctx=Load()), conversion=-1), Constant(value=''.__init__'')])), If(test=Compare(left=Name(id=''init_method_name'',
    ctx=Load()), ops=[In()], comparators=[Name(id=''class_method_details_lookup'',
    ctx=Load())]), body=[Assign(targets=[Name(id=''init_method'', ctx=Store())], value=Name(id=''init_method_name'',
    ctx=Load()))], orelse=[]), Expr(value=Call(func=Name(id=''add_edge_with_data'',
    ctx=Load()), args=[Name(id=''source_name'', ctx=Load()), Name(id=''called'', ctx=Load()),
    Name(id=''init_method'', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''called'', ctx=Load())],
    keywords=[])), Expr(value=Call(func=Name(id=''add_edge_with_data'', ctx=Load()),
    args=[Name(id=''source_name'', ctx=Load()), Name(id=''called'', ctx=Load())],
    keywords=[]))])])], orelse=[])], decorator_list=[]), For(target=Name(id=''function_name'',
    ctx=Store()), iter=Call(func=Attribute(value=Name(id=''function_details_lookup'',
    ctx=Load()), attr=''keys'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''function_name'',
    ctx=Load())], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id=''func_name'',
    ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''function_details_lookup'',
    ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id=''add_edges_for_calls'',
    ctx=Load()), args=[Name(id=''func_name'', ctx=Load()), Subscript(value=Name(id=''details'',
    ctx=Load()), slice=Constant(value=''calls''), ctx=Load())], keywords=[]))], orelse=[]),
    For(target=Tuple(elts=[Name(id=''qualified_method_name'', ctx=Store()), Name(id=''details'',
    ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_method_details_lookup'',
    ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id=''add_edges_for_calls'',
    ctx=Load()), args=[Name(id=''qualified_method_name'', ctx=Load()), Subscript(value=Name(id=''details'',
    ctx=Load()), slice=Constant(value=''calls''), ctx=Load())], keywords=[]))], orelse=[]),
    For(target=Name(id=''edge'', ctx=Store()), iter=Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''edges'', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id=''source'',
    ctx=Store()), Name(id=''target'', ctx=Store())], ctx=Store())], value=Name(id=''edge'',
    ctx=Load())), Assign(targets=[Name(id=''target_details'', ctx=Store())], value=BoolOp(op=Or(),
    values=[Call(func=Attribute(value=Name(id=''function_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Name(id=''target'', ctx=Load())], keywords=[]),
    Call(func=Attribute(value=Name(id=''class_method_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Name(id=''target'', ctx=Load())], keywords=[])])),
    Assign(targets=[Name(id=''source_details'', ctx=Store())], value=BoolOp(op=Or(),
    values=[Call(func=Attribute(value=Name(id=''function_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())], keywords=[]),
    Call(func=Attribute(value=Name(id=''class_method_details_lookup'', ctx=Load()),
    attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())], keywords=[])])),
    Assign(targets=[Name(id=''edge_data'', ctx=Store())], value=Call(func=Name(id=''get_edge_data_from_details'',
    ctx=Load()), args=[Name(id=''target_details'', ctx=Load()), Name(id=''source_details'',
    ctx=Load()), Name(id=''target'', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Subscript(value=Name(id=''G'',
    ctx=Load()), slice=Name(id=''source'', ctx=Load()), ctx=Load()), slice=Name(id=''target'',
    ctx=Load()), ctx=Load()), attr=''update'', ctx=Load()), args=[Name(id=''edge_data'',
    ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id=''nodes'', ctx=Store())],
    value=Call(func=Name(id=''list'', ctx=Load()), args=[Attribute(value=Name(id=''G'',
    ctx=Load()), attr=''nodes'', ctx=Load())], keywords=[])), Assign(targets=[Name(id=''edges'',
    ctx=Store())], value=ListComp(elt=Dict(keys=[Constant(value=''source''), Constant(value=''target''),
    None], values=[Subscript(value=Name(id=''edge'', ctx=Load()), slice=Constant(value=0),
    ctx=Load()), Subscript(value=Name(id=''edge'', ctx=Load()), slice=Constant(value=1),
    ctx=Load()), Subscript(value=Name(id=''edge'', ctx=Load()), slice=Constant(value=2),
    ctx=Load())]), generators=[comprehension(target=Name(id=''edge'', ctx=Store()),
    iter=Call(func=Attribute(value=Attribute(value=Name(id=''G'', ctx=Load()), attr=''edges'',
    ctx=Load()), attr=''data'', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])),
    Return(value=Dict(keys=[Constant(value=''nodes''), Constant(value=''edges'')],
    values=[Name(id=''nodes'', ctx=Load()), Name(id=''edges'', ctx=Load())]))], decorator_list=[],
    returns=Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
    ctx=Load()), Subscript(value=Name(id=''Union'', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id=''List'',
    ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load()), Subscript(value=Name(id=''Dict'',
    ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
    ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())],
    ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name=''get_python_file_details'',
    args=arguments(posonlyargs=[], args=[arg(arg=''file_path'', annotation=Name(id=''str'',
    ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Extract
    details from a Python file.\n    Args:\n        file_path: str: The path to the
    Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted
    from the file.\n    '')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id=''open'',
    ctx=Load()), args=[Name(id=''file_path'', ctx=Load()), Constant(value=''r'')],
    keywords=[keyword(arg=''encoding'', value=Constant(value=''utf-8'')), keyword(arg=''errors'',
    value=Constant(value=''ignore''))]), optional_vars=Name(id=''f'', ctx=Store()))],
    body=[Assign(targets=[Name(id=''code'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''f'',
    ctx=Load()), attr=''read'', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id=''tree'',
    ctx=Store())], value=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''parse'',
    ctx=Load()), args=[Name(id=''code'', ctx=Load())], keywords=[]))])], handlers=[ExceptHandler(body=[Expr(value=Call(func=Attribute(value=Name(id=''logging'',
    ctx=Load()), attr=''warning'', ctx=Load()), args=[JoinedStr(values=[Constant(value=''Permission
    denied or syntax error in file: ''), FormattedValue(value=Name(id=''file_path'',
    ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=None))])],
    orelse=[], finalbody=[]), Assign(targets=[Name(id=''visitor'', ctx=Store())],
    value=Call(func=Name(id=''CodeVisitor'', ctx=Load()), args=[Name(id=''code'',
    ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id=''visitor'',
    ctx=Load()), attr=''analyze'', ctx=Load()), args=[Name(id=''tree'', ctx=Load())],
    keywords=[])), Assign(targets=[Name(id=''file_details'', ctx=Store())], value=Dict(keys=[Constant(value=''file_info''),
    Constant(value=''functions''), Constant(value=''classes'')], values=[Attribute(value=Name(id=''visitor'',
    ctx=Load()), attr=''file_info'', ctx=Load()), Attribute(value=Name(id=''visitor'',
    ctx=Load()), attr=''functions'', ctx=Load()), Attribute(value=Name(id=''visitor'',
    ctx=Load()), attr=''classes'', ctx=Load())])), Assign(targets=[Subscript(value=Subscript(value=Name(id=''file_details'',
    ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''entire_code_graph''),
    ctx=Store())], value=Call(func=Name(id=''code_graph'', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id=''file_details'',
    ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''file_summary''),
    ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Subscript(value=Name(id=''file_details'',
    ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''file_summary''),
    ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id=''json'',
    ctx=Load()), attr=''dumps'', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id=''file_details'',
    ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''file_summary''),
    ctx=Load())], keywords=[]), attr=''replace'', ctx=Load()), args=[Constant(value=''"''),
    Constant(value='''')], keywords=[])), Return(value=Name(id=''file_details'', ctx=Load()))],
    decorator_list=[], returns=Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
    ctx=Load()), Subscript(value=Name(id=''Union'', ctx=Load()), slice=Tuple(elts=[Name(id=''Dict'',
    ctx=Load()), Name(id=''str'', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()),
    ctx=Load()))], type_ignores=[])'
  file_dependencies:
  - typing
  - json
  - networkx
  - re
  - logging
  - astor
  - ast
  file_functions:
  - remove_docs_and_comments
  - get_all_calls
  - code_graph
  - get_edge_data_from_details
  - add_edge_with_data
  - add_edges_for_calls
  - get_python_file_details
  file_classes:
  - CodeVisitor
  file_summary: '{dependencies: [typing, json, networkx, re, logging, astor, ast],
    function_defs: [{remove_docs_and_comments: {inputs: [code], calls: [ast.parse,
    ast.walk, isinstance, ast.Constant, node.value.replace(''\\\'', '''').replace,
    node.value.replace, astor.to_source(parsed).strip, astor.to_source], call_inputs:
    {ast.parse: [code], ast.walk: [parsed], isinstance: [node.value, str], ast.Constant:
    [], node.value.replace(''\\\'', '''').replace: [\''''''\, ''''], node.value.replace:
    [''\\\'', ''''], astor.to_source(parsed).strip: [], astor.to_source: [parsed]},
    returns: [astor.to_source(parsed).strip()]}}, {get_all_calls: {inputs: [node],
    calls: [ast.iter_child_nodes, isinstance, ast.unparse, calls.update, get_all_calls],
    call_inputs: {ast.iter_child_nodes: [node], isinstance: [child, ast.Call], ast.unparse:
    [arg], calls.update: [get_all_calls(child)], get_all_calls: [child]}, returns:
    [calls]}}, {code_graph: {inputs: [file_summary], calls: [nx.DiGraph, function_details_lookup.update,
    class_def.items, G.add_node, class_details[''method_defs''].items, G.add_edge,
    target_details.get, list, set, class_method_details_lookup.get, function_details_lookup.get,
    get_edge_data_from_details, class_def.keys, called.split, called.startswith, called.replace,
    source_name.split, add_edge_with_data, function_details_lookup.keys, function_details_lookup.items,
    add_edges_for_calls, class_method_details_lookup.items, G[source][target].update,
    G.edges.data], call_inputs: {nx.DiGraph: [], function_details_lookup.update: [function_def],
    class_def.items: [], G.add_node: [function_name], class_details[''method_defs''].items:
    [], G.add_edge: [source, target], target_details.get: [''returns'', []], list:
    [G.nodes], set: [target_details.get(''returns'', [])], class_method_details_lookup.get:
    [source], function_details_lookup.get: [source], get_edge_data_from_details: [target_details,
    source_details, target], class_def.keys: [], called.split: [''.''], called.startswith:
    [''self.''], called.replace: [''self.'', ''''], source_name.split: [''.''], add_edge_with_data:
    [source_name, called], function_details_lookup.keys: [], function_details_lookup.items:
    [], add_edges_for_calls: [qualified_method_name, details[''calls'']], class_method_details_lookup.items:
    [], G[source][target].update: [edge_data], G.edges.data: []}, returns: [{''nodes'':
    nodes, ''edges'': edges}, edge_data]}}, {get_edge_data_from_details: {inputs:
    [target_details, source_details, target], calls: [target_details.get, list, set],
    call_inputs: {target_details.get: [''returns'', []], list: [set(target_details.get(''returns'',
    []))], set: [target_details.get(''returns'', [])]}, returns: [edge_data]}}, {add_edge_with_data:
    {inputs: [source, target, init_method], calls: [class_method_details_lookup.get,
    function_details_lookup.get, G.add_edge, get_edge_data_from_details], call_inputs:
    {class_method_details_lookup.get: [source], function_details_lookup.get: [source],
    G.add_edge: [source, target], get_edge_data_from_details: [target_details, source_details,
    target]}, returns: []}}, {add_edges_for_calls: {inputs: [source_name, calls],
    calls: [list, class_def.keys, called.split, called.startswith, called.replace,
    source_name.split, add_edge_with_data, G.add_node], call_inputs: {list: [class_def.keys()],
    class_def.keys: [], called.split: [''.''], called.startswith: [''self.''], called.replace:
    [''self.'', ''''], source_name.split: [''.''], add_edge_with_data: [source_name,
    called], G.add_node: [called]}, returns: []}}, {get_python_file_details: {inputs:
    [file_path], calls: [open, f.read, ast.parse, logging.warning, CodeVisitor, visitor.analyze,
    code_graph, json.dumps(file_details[''file_info''][''file_summary'']).replace,
    json.dumps], call_inputs: {open: [file_path, ''r''], f.read: [], ast.parse: [code],
    logging.warning: [f''Permission denied or syntax error in file: {file_path}''],
    CodeVisitor: [code], visitor.analyze: [tree], code_graph: [file_details[''file_info''][''file_summary'']],
    json.dumps(file_details[''file_info''][''file_summary'']).replace: [''\'', ''''],
    json.dumps: [file_details[''file_info''][''file_summary'']]}, returns: [file_details,
    None]}}], class_defs: [{CodeVisitor: {method_defs: {__init__: {inputs: [self,
    code], calls: [], call_inputs: {}, returns: []}, visit_FunctionDef: {inputs: [self,
    node], calls: [self.extract_details, self.generic_visit], call_inputs: {self.extract_details:
    [node, ''method'' if self.current_class else ''function''], self.generic_visit:
    [node]}, returns: []}, visit_ClassDef: {inputs: [self, node], calls: [self.extract_details,
    self.generic_visit], call_inputs: {self.extract_details: [node, ''class''], self.generic_visit:
    [node]}, returns: []}, extract_details: {inputs: [self, node, node_type], calls:
    [list, ast.walk, get_all_calls, ast.unparse, ast.dump, next, isinstance, call_data.keys,
    set, self.classes[self.current_class].setdefault(''class_attributes'', []).extend,
    self.classes[self.current_class].setdefault, details.update, any], call_inputs:
    {list: [{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode,
    ast.Attribute) and isinstance(subnode.ctx, ast.Store)}], ast.walk: [node], get_all_calls:
    [node], ast.unparse: [base], ast.dump: [node], next: [(n.value.s for n in node_walk
    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None], isinstance:
    [decorator, ast.Name], call_data.keys: [], set: [], self.classes[self.current_class].setdefault(''class_attributes'',
    []).extend: [attributes], self.classes[self.current_class].setdefault: [''class_attributes'',
    []], details.update: [{''class_attributes'': [target.attr for subnode in node.body
    if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target,
    ast.Attribute)], ''class_methods'': [subnode.name for subnode in node.body if
    isinstance(subnode, ast.FunctionDef) and subnode.name != ''__init__''], ''class_inheritance'':
    [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'':
    [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)
    and subnode.name != ''__init__'' and any((isinstance(decorator, ast.Name) and
    decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}],
    any: [(isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for
    decorator in subnode.decorator_list)]}, returns: [details]}, analyze: {inputs:
    [self, node], calls: [list, ast.walk, self.visit, ast.dump, isinstance, self.functions.keys,
    self.classes.keys, self.functions.items, self.classes.items, class_details.items,
    method_name.startswith, len, class_defs.append, remove_docs_and_comments, ast.unparse],
    call_inputs: {list: [self.classes.keys()], ast.walk: [node], self.visit: [node],
    ast.dump: [node], isinstance: [subnode, ast.ImportFrom], self.functions.keys:
    [], self.classes.keys: [], self.functions.items: [], self.classes.items: [], class_details.items:
    [], method_name.startswith: [''class_method_''], len: [''class_method_''], class_defs.append:
    [{class_name: {''method_defs'': method_defs}}], remove_docs_and_comments: [ast.unparse(node)],
    ast.unparse: [node]}, returns: []}}}}]}'
  file_code_simplified: "\"\"\"\"\"\"\nimport ast\nimport re\nimport json\nimport\
    \ astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List,\
    \ Optional, Union\n\n\ndef remove_docs_and_comments(code: str) ->str:\n    \"\"\
    \"\"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n  \
    \      if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.\n  \
    \          value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n\
    \        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n\
    \            node.value = node.value.replace('', '').replace('', '')\n    return\
    \ astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST) ->Dict[str,\
    \ List[str]]:\n    \"\"\"\"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n\
    \        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)]\
    \ = [ast.unparse(arg) for arg in\n                child.args]\n        calls.update(get_all_calls(child))\n\
    \    return calls\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\"\"\"\n\
    \n    def __init__(self, code: str):\n        \"\"\"\"\"\"\n        self.code:\
    \ str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]]\
    \ = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n\
    \        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class:\
    \ str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) ->None:\n\
    \        \"\"\"\"\"\"\n        details = self.extract_details(node, 'method' if\
    \ self.current_class\n             else 'function')\n        if self.current_class:\n\
    \            self.classes[self.current_class][f'class_method_{node.name}'\n  \
    \              ] = details\n        else:\n            self.functions[node.name]\
    \ = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self,\
    \ node: ast.ClassDef) ->None:\n        \"\"\"\"\"\"\n        self.classes[node.name]\
    \ = self.extract_details(node, 'class')\n        self.current_class = node.name\n\
    \        self.generic_visit(node)\n        self.current_class = None\n\n    def\
    \ extract_details(self, node: ast.AST, node_type: str) ->Dict[str,\n        Union[str,\
    \ List[str]]]:\n        \"\"\"\"\"\"\n        node_walk = list(ast.walk(node))\n\
    \        call_data = get_all_calls(node)\n        details = {f'{node_type}_name':\
    \ node.name, f'{node_type}_code': ast\n            .unparse(node), f'{node_type}_ast':\
    \ ast.dump(node),\n            f'{node_type}_docstring': next((n.value.s for n\
    \ in node_walk if\n            isinstance(n, ast.Expr) and isinstance(n.value,\
    \ ast.Str)), None\n            ), f'{node_type}_inputs': [arg.arg for arg in node.args.args]\
    \ if\n            node_type in ['function', 'method'] else None,\n           \
    \ f'{node_type}_defaults': [ast.unparse(d) for d in node.args.\n            defaults]\
    \ if node_type in ['function', 'method'] else None,\n            f'{node_type}_returns':\
    \ [(ast.unparse(subnode.value) if subnode\n            .value is not None else\
    \ 'None') for subnode in node_walk if\n            isinstance(subnode, ast.Return)],\
    \ f'{node_type}_calls': list(\n            call_data.keys()), f'{node_type}_call_inputs':\
    \ call_data,\n            f'{node_type}_variables': list({ast.unparse(target)\
    \ for subnode in\n            node_walk if isinstance(subnode, ast.Assign) for\
    \ target in\n            subnode.targets if isinstance(target, ast.Name)}),\n\
    \            f'{node_type}_decorators': list({ast.unparse(decorator) for\n   \
    \         decorator in node.decorator_list} if node.decorator_list else\n    \
    \        set()), f'{node_type}_annotations': list({ast.unparse(subnode.\n    \
    \        annotation) for subnode in node_walk if isinstance(subnode, ast\n   \
    \         .AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties':\
    \ list({ast.unparse(subnode) for\n            subnode in node_walk if isinstance(subnode,\
    \ ast.Attribute) and\n            isinstance(subnode.ctx, ast.Store)})}\n    \
    \    if node_type in ['class', 'method']:\n            if node_type == 'method'\
    \ and self.current_class:\n                attributes = [target.attr for subnode\
    \ in node_walk if\n                    isinstance(subnode, ast.Assign) for target\
    \ in subnode.\n                    targets if isinstance(target, ast.Attribute)\
    \ and\n                    isinstance(target.value, ast.Name) and target.value.id\
    \ ==\n                    'self']\n                self.classes[self.current_class].setdefault('class_attributes',\n\
    \                    []).extend(attributes)\n            if node_type == 'class':\n\
    \                details.update({'class_attributes': [target.attr for\n      \
    \              subnode in node.body if isinstance(subnode, ast.Assign) for\n \
    \                   target in subnode.targets if isinstance(target, ast.\n   \
    \                 Attribute)], 'class_methods': [subnode.name for subnode in\n\
    \                    node.body if isinstance(subnode, ast.FunctionDef) and \n\
    \                    subnode.name != '__init__'], 'class_inheritance': [ast.\n\
    \                    unparse(base) for base in node.bases] if node.bases else\n\
    \                    [], 'class_static_methods': [subnode.name for subnode in\n\
    \                    node.body if isinstance(subnode, ast.FunctionDef) and \n\
    \                    subnode.name != '__init__' and any(isinstance(decorator,\n\
    \                    ast.Name) and decorator.id == 'staticmethod' for\n      \
    \              decorator in subnode.decorator_list)]})\n        return details\n\
    \n    def analyze(self, node: ast.AST) ->None:\n        \"\"\"\"\"\"\n       \
    \ node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info\
    \ = {'file_code': self.code, 'file_ast': ast.dump(node\n            ), 'file_dependencies':\
    \ list({alias.name for subnode in\n            node_walk if isinstance(subnode,\
    \ ast.Import) for alias in\n            subnode.names} | {subnode.module for subnode\
    \ in node_walk if\n            isinstance(subnode, ast.ImportFrom)}), 'file_functions':\
    \ list(\n            self.functions.keys()), 'file_classes': list(self.classes.keys())}\n\
    \        function_defs = [{func_name: {'inputs': details['function_inputs'],\n\
    \            'calls': details['function_calls'], 'call_inputs': details[\n   \
    \         'function_call_inputs'], 'returns': details['function_returns']\n  \
    \          }} for func_name, details in self.functions.items()]\n        class_defs\
    \ = []\n        for class_name, class_details in self.classes.items():\n     \
    \       method_defs = {}\n            for method_name, details in class_details.items():\n\
    \                if method_name.startswith('class_method_'):\n               \
    \     method_defs[method_name[len('class_method_'):]] = {'inputs'\n          \
    \              : details['method_inputs'], 'calls': details[\n               \
    \         'method_calls'], 'call_inputs': details[\n                        'method_call_inputs'],\
    \ 'returns': details[\n                        'method_returns']}\n          \
    \  class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary']\
    \ = {'dependencies': self.file_info[\n            'file_dependencies'], 'function_defs':\
    \ function_defs,\n            'class_defs': class_defs}\n        file_code_simplified\
    \ = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified']\
    \ = file_code_simplified\n\n\ndef code_graph(file_summary: Dict[str, Union[Dict,\
    \ str]]) ->Dict[str, Union\n    [List[str], Dict[str, List[str]]]]:\n    \"\"\"\
    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def\
    \ in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n\
    \    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n\
    \        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n\
    \            for method_name, method_details in class_details['method_defs'\n\
    \                ].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n\
    \                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name\n\
    \                    ] = method_details\n                G.add_edge(class_name,\
    \ qualified_method_name)\n\n    def get_edge_data_from_details(target_details:\
    \ dict, source_details:\n        dict, target: str) ->dict:\n        edge_data\
    \ = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n\
    \            edge_data['target_returns'] = list(set(target_details.get(\n    \
    \            'returns', [])))\n        if (source_details and 'call_inputs' in\
    \ source_details and target in\n            source_details['call_inputs']):\n\
    \            edge_data['target_inputs'] = source_details['call_inputs'][target]\n\
    \        return edge_data\n\n    def add_edge_with_data(source: str, target: str,\
    \ init_method: Optional[\n        str]=None) ->None:\n        target_details =\
    \ class_method_details_lookup.get(init_method or target\n            ) or function_details_lookup.get(target)\n\
    \        source_details = function_details_lookup.get(source\n            ) or\
    \ class_method_details_lookup.get(source)\n        G.add_edge(source, target,\
    \ **get_edge_data_from_details(\n            target_details, source_details, target))\n\
    \n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0]\
    \ for class_def in\n            file_summary['class_defs']]\n        for called\
    \ in calls:\n            called_class_name = called.split('.')[0]\n          \
    \  if called.startswith('self.'):\n                method_name = called.replace('self.',\
    \ '')\n                fully_qualified_name = (\n                    f\"{source_name.split('.')[0]}.{method_name}\"\
    )\n                if fully_qualified_name in class_method_details_lookup:\n \
    \                   add_edge_with_data(source_name, fully_qualified_name)\n  \
    \                  continue\n            if (called in function_details_lookup\
    \ or called in\n                class_method_details_lookup or \n            \
    \    f\"{source_name.split('.')[0]}.{called}\" in\n                class_method_details_lookup):\n\
    \                add_edge_with_data(source_name, called)\n            elif called_class_name\
    \ in class_names:\n                init_method = None\n                init_method_name\
    \ = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n\
    \                    init_method = init_method_name\n                add_edge_with_data(source_name,\
    \ called, init_method)\n            else:\n                G.add_node(called)\n\
    \                add_edge_with_data(source_name, called)\n    for function_name\
    \ in function_details_lookup.keys():\n        G.add_node(function_name)\n    for\
    \ func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name,\
    \ details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n\
    \        add_edges_for_calls(qualified_method_name, details['calls'])\n    for\
    \ edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target\n\
    \            ) or class_method_details_lookup.get(target)\n        source_details\
    \ = function_details_lookup.get(source\n            ) or class_method_details_lookup.get(source)\n\
    \        edge_data = get_edge_data_from_details(target_details,\n            source_details,\
    \ target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n\
    \    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in\n\
    \        G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}\n\n\ndef\
    \ get_python_file_details(file_path: str) ->Dict[str, Union[Dict, str]]:\n   \
    \ \"\"\"\"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8',\
    \ errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n\
    \    except:\n        logging.warning(\n            f'Permission denied or syntax\
    \ error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n\
    \    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info,\
    \ 'functions': visitor.\n        functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph']\
    \ = code_graph(file_details\n        ['file_info']['file_summary'])\n    file_details['file_info']['file_summary']\
    \ = json.dumps(file_details[\n        'file_info']['file_summary']).replace('\"\
    ', '')\n    return file_details"
  entire_code_graph:
    nodes:
    - CodeVisitor
    - CodeVisitor.__init__
    - CodeVisitor.visit_FunctionDef
    - CodeVisitor.visit_ClassDef
    - CodeVisitor.extract_details
    - CodeVisitor.analyze
    - remove_docs_and_comments
    - get_all_calls
    - code_graph
    - get_edge_data_from_details
    - add_edge_with_data
    - add_edges_for_calls
    - get_python_file_details
    - ast.parse
    - ast.walk
    - isinstance
    - ast.Constant
    - node.value.replace('"""', '').replace
    - node.value.replace
    - astor.to_source(parsed).strip
    - astor.to_source
    - ast.iter_child_nodes
    - ast.unparse
    - calls.update
    - nx.DiGraph
    - function_details_lookup.update
    - class_def.items
    - G.add_node
    - class_details['method_defs'].items
    - G.add_edge
    - target_details.get
    - list
    - set
    - class_method_details_lookup.get
    - function_details_lookup.get
    - class_def.keys
    - called.split
    - called.startswith
    - called.replace
    - source_name.split
    - function_details_lookup.keys
    - function_details_lookup.items
    - class_method_details_lookup.items
    - G[source][target].update
    - G.edges.data
    - open
    - f.read
    - logging.warning
    - visitor.analyze
    - json.dumps(file_details['file_info']['file_summary']).replace
    - json.dumps
    - self.generic_visit
    - ast.dump
    - next
    - call_data.keys
    - self.classes[self.current_class].setdefault('class_attributes', []).extend
    - self.classes[self.current_class].setdefault
    - details.update
    - any
    - self.visit
    - self.functions.keys
    - self.classes.keys
    - self.functions.items
    - self.classes.items
    - class_details.items
    - method_name.startswith
    - len
    - class_defs.append
    edges:
    - source: CodeVisitor
      target: CodeVisitor.__init__
      target_inputs:
      - self
      - code
      target_returns: []
    - source: CodeVisitor
      target: CodeVisitor.visit_FunctionDef
      target_inputs:
      - self
      - node
      target_returns: []
    - source: CodeVisitor
      target: CodeVisitor.visit_ClassDef
      target_inputs:
      - self
      - node
      target_returns: []
    - source: CodeVisitor
      target: CodeVisitor.extract_details
      target_inputs:
      - self
      - node
      - node_type
      target_returns:
      - details
    - source: CodeVisitor
      target: CodeVisitor.analyze
      target_inputs:
      - self
      - node
      target_returns: []
    - source: CodeVisitor.visit_FunctionDef
      target: CodeVisitor.extract_details
      target_inputs:
      - self
      - node
      - node_type
      target_returns:
      - details
    - source: CodeVisitor.visit_FunctionDef
      target: self.generic_visit
      target_inputs:
      - node
    - source: CodeVisitor.visit_ClassDef
      target: CodeVisitor.extract_details
      target_inputs:
      - self
      - node
      - node_type
      target_returns:
      - details
    - source: CodeVisitor.visit_ClassDef
      target: self.generic_visit
      target_inputs:
      - node
    - source: CodeVisitor.extract_details
      target: list
      target_inputs:
      - '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute)
        and isinstance(subnode.ctx, ast.Store)}'
    - source: CodeVisitor.extract_details
      target: ast.walk
      target_inputs:
      - node
    - source: CodeVisitor.extract_details
      target: get_all_calls
      target_inputs:
      - node
      target_returns:
      - calls
    - source: CodeVisitor.extract_details
      target: ast.unparse
      target_inputs:
      - base
    - source: CodeVisitor.extract_details
      target: ast.dump
      target_inputs:
      - node
    - source: CodeVisitor.extract_details
      target: next
      target_inputs:
      - (n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value,
        ast.Str))
      - None
    - source: CodeVisitor.extract_details
      target: isinstance
      target_inputs:
      - decorator
      - ast.Name
    - source: CodeVisitor.extract_details
      target: call_data.keys
      target_inputs: []
    - source: CodeVisitor.extract_details
      target: set
      target_inputs: []
    - source: CodeVisitor.extract_details
      target: self.classes[self.current_class].setdefault('class_attributes', []).extend
      target_inputs:
      - attributes
    - source: CodeVisitor.extract_details
      target: self.classes[self.current_class].setdefault
      target_inputs:
      - '''class_attributes'''
      - '[]'
    - source: CodeVisitor.extract_details
      target: details.update
      target_inputs:
      - '{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode,
        ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],
        ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode,
        ast.FunctionDef) and subnode.name != ''__init__''], ''class_inheritance'':
        [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'':
        [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)
        and subnode.name != ''__init__'' and any((isinstance(decorator, ast.Name)
        and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}'
    - source: CodeVisitor.extract_details
      target: any
      target_inputs:
      - (isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator
        in subnode.decorator_list)
    - source: CodeVisitor.analyze
      target: list
      target_inputs:
      - self.classes.keys()
    - source: CodeVisitor.analyze
      target: ast.walk
      target_inputs:
      - node
    - source: CodeVisitor.analyze
      target: self.visit
      target_inputs:
      - node
    - source: CodeVisitor.analyze
      target: ast.dump
      target_inputs:
      - node
    - source: CodeVisitor.analyze
      target: isinstance
      target_inputs:
      - subnode
      - ast.ImportFrom
    - source: CodeVisitor.analyze
      target: self.functions.keys
      target_inputs: []
    - source: CodeVisitor.analyze
      target: self.classes.keys
      target_inputs: []
    - source: CodeVisitor.analyze
      target: self.functions.items
      target_inputs: []
    - source: CodeVisitor.analyze
      target: self.classes.items
      target_inputs: []
    - source: CodeVisitor.analyze
      target: class_details.items
      target_inputs: []
    - source: CodeVisitor.analyze
      target: method_name.startswith
      target_inputs:
      - '''class_method_'''
    - source: CodeVisitor.analyze
      target: len
      target_inputs:
      - '''class_method_'''
    - source: CodeVisitor.analyze
      target: class_defs.append
      target_inputs:
      - '{class_name: {''method_defs'': method_defs}}'
    - source: CodeVisitor.analyze
      target: remove_docs_and_comments
      target_inputs:
      - ast.unparse(node)
      target_returns:
      - astor.to_source(parsed).strip()
    - source: CodeVisitor.analyze
      target: ast.unparse
      target_inputs:
      - node
    - source: remove_docs_and_comments
      target: ast.parse
      target_inputs:
      - code
    - source: remove_docs_and_comments
      target: ast.walk
      target_inputs:
      - parsed
    - source: remove_docs_and_comments
      target: isinstance
      target_inputs:
      - node.value
      - str
    - source: remove_docs_and_comments
      target: ast.Constant
      target_inputs: []
    - source: remove_docs_and_comments
      target: node.value.replace('"""', '').replace
      target_inputs:
      - '"''''''"'
      - ''''''
    - source: remove_docs_and_comments
      target: node.value.replace
      target_inputs:
      - '''"""'''
      - ''''''
    - source: remove_docs_and_comments
      target: astor.to_source(parsed).strip
      target_inputs: []
    - source: remove_docs_and_comments
      target: astor.to_source
      target_inputs:
      - parsed
    - source: get_all_calls
      target: ast.iter_child_nodes
      target_inputs:
      - node
    - source: get_all_calls
      target: isinstance
      target_inputs:
      - child
      - ast.Call
    - source: get_all_calls
      target: ast.unparse
      target_inputs:
      - arg
    - source: get_all_calls
      target: calls.update
      target_inputs:
      - get_all_calls(child)
    - source: get_all_calls
      target: get_all_calls
      target_inputs:
      - child
      target_returns:
      - calls
    - source: code_graph
      target: nx.DiGraph
      target_inputs: []
    - source: code_graph
      target: function_details_lookup.update
      target_inputs:
      - function_def
    - source: code_graph
      target: class_def.items
      target_inputs: []
    - source: code_graph
      target: G.add_node
      target_inputs:
      - function_name
    - source: code_graph
      target: class_details['method_defs'].items
      target_inputs: []
    - source: code_graph
      target: G.add_edge
      target_inputs:
      - source
      - target
    - source: code_graph
      target: target_details.get
      target_inputs:
      - '''returns'''
      - '[]'
    - source: code_graph
      target: list
      target_inputs:
      - G.nodes
    - source: code_graph
      target: set
      target_inputs:
      - target_details.get('returns', [])
    - source: code_graph
      target: class_method_details_lookup.get
      target_inputs:
      - source
    - source: code_graph
      target: function_details_lookup.get
      target_inputs:
      - source
    - source: code_graph
      target: get_edge_data_from_details
      target_inputs:
      - target_details
      - source_details
      - target
      target_returns:
      - edge_data
    - source: code_graph
      target: class_def.keys
      target_inputs: []
    - source: code_graph
      target: called.split
      target_inputs:
      - '''.'''
    - source: code_graph
      target: called.startswith
      target_inputs:
      - '''self.'''
    - source: code_graph
      target: called.replace
      target_inputs:
      - '''self.'''
      - ''''''
    - source: code_graph
      target: source_name.split
      target_inputs:
      - '''.'''
    - source: code_graph
      target: add_edge_with_data
      target_inputs:
      - source_name
      - called
      target_returns: []
    - source: code_graph
      target: function_details_lookup.keys
      target_inputs: []
    - source: code_graph
      target: function_details_lookup.items
      target_inputs: []
    - source: code_graph
      target: add_edges_for_calls
      target_inputs:
      - qualified_method_name
      - details['calls']
      target_returns: []
    - source: code_graph
      target: class_method_details_lookup.items
      target_inputs: []
    - source: code_graph
      target: G[source][target].update
      target_inputs:
      - edge_data
    - source: code_graph
      target: G.edges.data
      target_inputs: []
    - source: get_edge_data_from_details
      target: target_details.get
      target_inputs:
      - '''returns'''
      - '[]'
    - source: get_edge_data_from_details
      target: list
      target_inputs:
      - set(target_details.get('returns', []))
    - source: get_edge_data_from_details
      target: set
      target_inputs:
      - target_details.get('returns', [])
    - source: add_edge_with_data
      target: class_method_details_lookup.get
      target_inputs:
      - source
    - source: add_edge_with_data
      target: function_details_lookup.get
      target_inputs:
      - source
    - source: add_edge_with_data
      target: G.add_edge
      target_inputs:
      - source
      - target
    - source: add_edge_with_data
      target: get_edge_data_from_details
      target_inputs:
      - target_details
      - source_details
      - target
      target_returns:
      - edge_data
    - source: add_edges_for_calls
      target: list
      target_inputs:
      - class_def.keys()
    - source: add_edges_for_calls
      target: class_def.keys
      target_inputs: []
    - source: add_edges_for_calls
      target: called.split
      target_inputs:
      - '''.'''
    - source: add_edges_for_calls
      target: called.startswith
      target_inputs:
      - '''self.'''
    - source: add_edges_for_calls
      target: called.replace
      target_inputs:
      - '''self.'''
      - ''''''
    - source: add_edges_for_calls
      target: source_name.split
      target_inputs:
      - '''.'''
    - source: add_edges_for_calls
      target: add_edge_with_data
      target_inputs:
      - source_name
      - called
      target_returns: []
    - source: add_edges_for_calls
      target: G.add_node
      target_inputs:
      - called
    - source: get_python_file_details
      target: open
      target_inputs:
      - file_path
      - '''r'''
    - source: get_python_file_details
      target: f.read
      target_inputs: []
    - source: get_python_file_details
      target: ast.parse
      target_inputs:
      - code
    - source: get_python_file_details
      target: logging.warning
      target_inputs:
      - 'f''Permission denied or syntax error in file: {file_path}'''
    - source: get_python_file_details
      target: CodeVisitor
      target_inputs:
      - code
      target_returns: []
    - source: get_python_file_details
      target: visitor.analyze
      target_inputs:
      - tree
    - source: get_python_file_details
      target: code_graph
      target_inputs:
      - file_details['file_info']['file_summary']
      target_returns:
      - '{''nodes'': nodes, ''edges'': edges}'
      - edge_data
    - source: get_python_file_details
      target: json.dumps(file_details['file_info']['file_summary']).replace
      target_inputs:
      - '''"'''
      - ''''''
    - source: get_python_file_details
      target: json.dumps
      target_inputs:
      - file_details['file_info']['file_summary']
functions:
  remove_docs_and_comments:
    function_name: remove_docs_and_comments
    function_code: "def remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n\
      \    Remove docstrings and comments from the provided code.\n    Args:\n   \
      \     code: str: The source code.\n    Returns:\n        str: The sanitized\
      \ code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n\
      \        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value,\
      \ (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n\
      \        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n\
      \            node.value = node.value.replace('\"\"\"', '').replace(\"'''\",\
      \ '')\n    return astor.to_source(parsed).strip()"
    function_ast: 'FunctionDef(name=''remove_docs_and_comments'', args=arguments(posonlyargs=[],
      args=[arg(arg=''code'', annotation=Name(id=''str'', ctx=Load()))], kwonlyargs=[],
      kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Remove
      docstrings and comments from the provided code.\n    Args:\n        code: str:
      The source code.\n    Returns:\n        str: The sanitized code.\n    '')),
      Assign(targets=[Name(id=''parsed'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''parse'', ctx=Load()), args=[Name(id=''code'', ctx=Load())],
      keywords=[])), For(target=Name(id=''node'', ctx=Store()), iter=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''walk'', ctx=Load()), args=[Name(id=''parsed'', ctx=Load())],
      keywords=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load()), Tuple(elts=[Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Expr'', ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''Constant'', ctx=Load())], ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Attribute(value=Name(id=''node'', ctx=Load()), attr=''value'',
      ctx=Load()), Tuple(elts=[Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Str'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Bytes'', ctx=Load())],
      ctx=Load())], keywords=[])]), body=[Assign(targets=[Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''value'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Constant'', ctx=Load()), args=[], keywords=[keyword(arg=''value'',
      value=Constant(value=''''))]))], orelse=[If(test=BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Constant'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Attribute(value=Name(id=''node'', ctx=Load()), attr=''value'',
      ctx=Load()), Name(id=''str'', ctx=Load())], keywords=[])]), body=[Assign(targets=[Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''value'', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''value'', ctx=Load()), attr=''replace'', ctx=Load()), args=[Constant(value=''"""''),
      Constant(value='''')], keywords=[]), attr=''replace'', ctx=Load()), args=[Constant(value="''''''"),
      Constant(value='''')], keywords=[]))], orelse=[])])], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id=''astor'',
      ctx=Load()), attr=''to_source'', ctx=Load()), args=[Name(id=''parsed'', ctx=Load())],
      keywords=[]), attr=''strip'', ctx=Load()), args=[], keywords=[]))], decorator_list=[],
      returns=Name(id=''str'', ctx=Load()))'
    function_docstring: "\n    Remove docstrings and comments from the provided code.\n\
      \    Args:\n        code: str: The source code.\n    Returns:\n        str:\
      \ The sanitized code.\n    "
    function_inputs:
    - code
    function_defaults: []
    function_returns:
    - astor.to_source(parsed).strip()
    function_calls:
    - ast.parse
    - ast.walk
    - isinstance
    - ast.Constant
    - node.value.replace('"""', '').replace
    - node.value.replace
    - astor.to_source(parsed).strip
    - astor.to_source
    function_call_inputs:
      ast.parse:
      - code
      ast.walk:
      - parsed
      isinstance:
      - node.value
      - str
      ast.Constant: []
      node.value.replace('"""', '').replace:
      - '"''''''"'
      - ''''''
      node.value.replace:
      - '''"""'''
      - ''''''
      astor.to_source(parsed).strip: []
      astor.to_source:
      - parsed
    function_variables:
    - parsed
    function_decorators: []
    function_annotations: []
    function_properties:
    - node.value
  get_all_calls:
    function_name: get_all_calls
    function_code: "def get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n  \
      \  \"\"\"\n    Recursively find all function calls in the subtree rooted at\
      \ `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n\
      \    Returns:\n        Dict[str, List[str]]: A dictionary with function calls\
      \ as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for\
      \ child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n\
      \            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n\
      \        calls.update(get_all_calls(child))\n    return calls"
    function_ast: 'FunctionDef(name=''get_all_calls'', args=arguments(posonlyargs=[],
      args=[arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''AST'', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Recursively
      find all function calls in the subtree rooted at `node`.\n    Args:\n        node
      (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str,
      List[str]]: A dictionary with function calls as keys and their arguments as
      values.\n    '')), Assign(targets=[Name(id=''calls'', ctx=Store())], value=Dict(keys=[],
      values=[])), For(target=Name(id=''child'', ctx=Store()), iter=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''iter_child_nodes'', ctx=Load()), args=[Name(id=''node'',
      ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''child'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Call'', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id=''calls'',
      ctx=Load()), slice=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''unparse'',
      ctx=Load()), args=[Attribute(value=Name(id=''child'', ctx=Load()), attr=''func'',
      ctx=Load())], keywords=[]), ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''arg'', ctx=Load())],
      keywords=[]), generators=[comprehension(target=Name(id=''arg'', ctx=Store()),
      iter=Attribute(value=Name(id=''child'', ctx=Load()), attr=''args'', ctx=Load()),
      ifs=[], is_async=0)]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id=''calls'',
      ctx=Load()), attr=''update'', ctx=Load()), args=[Call(func=Name(id=''get_all_calls'',
      ctx=Load()), args=[Name(id=''child'', ctx=Load())], keywords=[])], keywords=[]))],
      orelse=[]), Return(value=Name(id=''calls'', ctx=Load()))], decorator_list=[],
      returns=Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
      ctx=Load()), Subscript(value=Name(id=''List'', ctx=Load()), slice=Name(id=''str'',
      ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))'
    function_docstring: "\n    Recursively find all function calls in the subtree\
      \ rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the\
      \ search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with\
      \ function calls as keys and their arguments as values.\n    "
    function_inputs:
    - node
    function_defaults: []
    function_returns:
    - calls
    function_calls:
    - ast.iter_child_nodes
    - isinstance
    - ast.unparse
    - calls.update
    - get_all_calls
    function_call_inputs:
      ast.iter_child_nodes:
      - node
      isinstance:
      - child
      - ast.Call
      ast.unparse:
      - arg
      calls.update:
      - get_all_calls(child)
      get_all_calls:
      - child
    function_variables:
    - calls
    function_decorators: []
    function_annotations: []
    function_properties: []
  code_graph:
    function_name: code_graph
    function_code: "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str,\
      \ Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary\
      \ representation of file details.\n    Args:\n        file_summary: Dict[str,\
      \ Union[Dict, str]]: The details extracted from the file.\n    Returns:\n  \
      \      dict: A dictionary with nodes and edges representing the relationships\
      \ in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup\
      \ = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n\
      \    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n\
      \        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n\
      \            for method_name, method_details in class_details['method_defs'].items():\n\
      \                qualified_method_name = f'{class_name}.{method_name}'\n   \
      \             G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name]\
      \ = method_details\n                G.add_edge(class_name, qualified_method_name)\n\
      \n    def get_edge_data_from_details(target_details: dict, source_details: dict,\
      \ target: str) -> dict:\n        edge_data = {}\n        if target_details:\n\
      \            edge_data['target_inputs'] = target_details.get('inputs')\n   \
      \         edge_data['target_returns'] = list(set(target_details.get('returns',\
      \ [])))\n        if source_details and 'call_inputs' in source_details and (target\
      \ in source_details['call_inputs']):\n            edge_data['target_inputs']\
      \ = source_details['call_inputs'][target]\n        return edge_data\n\n    def\
      \ add_edge_with_data(source: str, target: str, init_method: Optional[str]=None)\
      \ -> None:\n        target_details = class_method_details_lookup.get(init_method\
      \ or target) or function_details_lookup.get(target)\n        source_details\
      \ = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n\
      \        G.add_edge(source, target, **get_edge_data_from_details(target_details,\
      \ source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n\
      \        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n\
      \        for called in calls:\n            called_class_name = called.split('.')[0]\n\
      \            if called.startswith('self.'):\n                method_name = called.replace('self.',\
      \ '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
      \n                if fully_qualified_name in class_method_details_lookup:\n\
      \                    add_edge_with_data(source_name, fully_qualified_name)\n\
      \                    continue\n            if called in function_details_lookup\
      \ or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\"\
      \ in class_method_details_lookup:\n                add_edge_with_data(source_name,\
      \ called)\n            elif called_class_name in class_names:\n            \
      \    init_method = None\n                init_method_name = f'{called}.__init__'\n\
      \                if init_method_name in class_method_details_lookup:\n     \
      \               init_method = init_method_name\n                add_edge_with_data(source_name,\
      \ called, init_method)\n            else:\n                G.add_node(called)\n\
      \                add_edge_with_data(source_name, called)\n    for function_name\
      \ in function_details_lookup.keys():\n        G.add_node(function_name)\n  \
      \  for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name,\
      \ details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n\
      \        add_edges_for_calls(qualified_method_name, details['calls'])\n    for\
      \ edge in G.edges:\n        source, target = edge\n        target_details =\
      \ function_details_lookup.get(target) or class_method_details_lookup.get(target)\n\
      \        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n\
      \        edge_data = get_edge_data_from_details(target_details, source_details,\
      \ target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n\
      \    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in\
      \ G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}"
    function_ast: 'FunctionDef(name=''code_graph'', args=arguments(posonlyargs=[],
      args=[arg(arg=''file_summary'', annotation=Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''Dict'', ctx=Load()), Name(id=''str'',
      ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[],
      kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Create
      a dictionary representation of file details.\n    Args:\n        file_summary:
      Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict:
      A dictionary with nodes and edges representing the relationships in the code.\n    '')),
      Assign(targets=[Name(id=''G'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''nx'',
      ctx=Load()), attr=''DiGraph'', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id=''function_details_lookup'',
      ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id=''function_def'',
      ctx=Store()), iter=Subscript(value=Name(id=''file_summary'', ctx=Load()), slice=Constant(value=''function_defs''),
      ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id=''function_details_lookup'',
      ctx=Load()), attr=''update'', ctx=Load()), args=[Name(id=''function_def'', ctx=Load())],
      keywords=[]))], orelse=[]), Assign(targets=[Name(id=''class_method_details_lookup'',
      ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id=''class_def'',
      ctx=Store()), iter=Subscript(value=Name(id=''file_summary'', ctx=Load()), slice=Constant(value=''class_defs''),
      ctx=Load()), body=[For(target=Tuple(elts=[Name(id=''class_name'', ctx=Store()),
      Name(id=''class_details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_def'',
      ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''class_name'', ctx=Load())],
      keywords=[])), For(target=Tuple(elts=[Name(id=''method_name'', ctx=Store()),
      Name(id=''method_details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Subscript(value=Name(id=''class_details'',
      ctx=Load()), slice=Constant(value=''method_defs''), ctx=Load()), attr=''items'',
      ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id=''qualified_method_name'',
      ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id=''class_name'',
      ctx=Load()), conversion=-1), Constant(value=''.''), FormattedValue(value=Name(id=''method_name'',
      ctx=Load()), conversion=-1)])), Expr(value=Call(func=Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''qualified_method_name'',
      ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id=''class_method_details_lookup'',
      ctx=Load()), slice=Name(id=''qualified_method_name'', ctx=Load()), ctx=Store())],
      value=Name(id=''method_details'', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''add_edge'', ctx=Load()), args=[Name(id=''class_name'', ctx=Load()),
      Name(id=''qualified_method_name'', ctx=Load())], keywords=[]))], orelse=[])],
      orelse=[])], orelse=[]), FunctionDef(name=''get_edge_data_from_details'', args=arguments(posonlyargs=[],
      args=[arg(arg=''target_details'', annotation=Name(id=''dict'', ctx=Load())),
      arg(arg=''source_details'', annotation=Name(id=''dict'', ctx=Load())), arg(arg=''target'',
      annotation=Name(id=''str'', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]),
      body=[Assign(targets=[Name(id=''edge_data'', ctx=Store())], value=Dict(keys=[],
      values=[])), If(test=Name(id=''target_details'', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id=''edge_data'',
      ctx=Load()), slice=Constant(value=''target_inputs''), ctx=Store())], value=Call(func=Attribute(value=Name(id=''target_details'',
      ctx=Load()), attr=''get'', ctx=Load()), args=[Constant(value=''inputs'')], keywords=[])),
      Assign(targets=[Subscript(value=Name(id=''edge_data'', ctx=Load()), slice=Constant(value=''target_returns''),
      ctx=Store())], value=Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Name(id=''set'',
      ctx=Load()), args=[Call(func=Attribute(value=Name(id=''target_details'', ctx=Load()),
      attr=''get'', ctx=Load()), args=[Constant(value=''returns''), List(elts=[],
      ctx=Load())], keywords=[])], keywords=[])], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(),
      values=[Name(id=''source_details'', ctx=Load()), Compare(left=Constant(value=''call_inputs''),
      ops=[In()], comparators=[Name(id=''source_details'', ctx=Load())]), Compare(left=Name(id=''target'',
      ctx=Load()), ops=[In()], comparators=[Subscript(value=Name(id=''source_details'',
      ctx=Load()), slice=Constant(value=''call_inputs''), ctx=Load())])]), body=[Assign(targets=[Subscript(value=Name(id=''edge_data'',
      ctx=Load()), slice=Constant(value=''target_inputs''), ctx=Store())], value=Subscript(value=Subscript(value=Name(id=''source_details'',
      ctx=Load()), slice=Constant(value=''call_inputs''), ctx=Load()), slice=Name(id=''target'',
      ctx=Load()), ctx=Load()))], orelse=[]), Return(value=Name(id=''edge_data'',
      ctx=Load()))], decorator_list=[], returns=Name(id=''dict'', ctx=Load())), FunctionDef(name=''add_edge_with_data'',
      args=arguments(posonlyargs=[], args=[arg(arg=''source'', annotation=Name(id=''str'',
      ctx=Load())), arg(arg=''target'', annotation=Name(id=''str'', ctx=Load())),
      arg(arg=''init_method'', annotation=Subscript(value=Name(id=''Optional'', ctx=Load()),
      slice=Name(id=''str'', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[],
      defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id=''target_details'',
      ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id=''class_method_details_lookup'',
      ctx=Load()), attr=''get'', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id=''init_method'',
      ctx=Load()), Name(id=''target'', ctx=Load())])], keywords=[]), Call(func=Attribute(value=Name(id=''function_details_lookup'',
      ctx=Load()), attr=''get'', ctx=Load()), args=[Name(id=''target'', ctx=Load())],
      keywords=[])])), Assign(targets=[Name(id=''source_details'', ctx=Store())],
      value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id=''function_details_lookup'',
      ctx=Load()), attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())],
      keywords=[]), Call(func=Attribute(value=Name(id=''class_method_details_lookup'',
      ctx=Load()), attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())],
      keywords=[])])), Expr(value=Call(func=Attribute(value=Name(id=''G'', ctx=Load()),
      attr=''add_edge'', ctx=Load()), args=[Name(id=''source'', ctx=Load()), Name(id=''target'',
      ctx=Load())], keywords=[keyword(value=Call(func=Name(id=''get_edge_data_from_details'',
      ctx=Load()), args=[Name(id=''target_details'', ctx=Load()), Name(id=''source_details'',
      ctx=Load()), Name(id=''target'', ctx=Load())], keywords=[]))]))], decorator_list=[],
      returns=Constant(value=None)), FunctionDef(name=''add_edges_for_calls'', args=arguments(posonlyargs=[],
      args=[arg(arg=''source_name''), arg(arg=''calls'')], kwonlyargs=[], kw_defaults=[],
      defaults=[]), body=[Assign(targets=[Name(id=''class_names'', ctx=Store())],
      value=ListComp(elt=Subscript(value=Call(func=Name(id=''list'', ctx=Load()),
      args=[Call(func=Attribute(value=Name(id=''class_def'', ctx=Load()), attr=''keys'',
      ctx=Load()), args=[], keywords=[])], keywords=[]), slice=Constant(value=0),
      ctx=Load()), generators=[comprehension(target=Name(id=''class_def'', ctx=Store()),
      iter=Subscript(value=Name(id=''file_summary'', ctx=Load()), slice=Constant(value=''class_defs''),
      ctx=Load()), ifs=[], is_async=0)])), For(target=Name(id=''called'', ctx=Store()),
      iter=Name(id=''calls'', ctx=Load()), body=[Assign(targets=[Name(id=''called_class_name'',
      ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id=''called'',
      ctx=Load()), attr=''split'', ctx=Load()), args=[Constant(value=''.'')], keywords=[]),
      slice=Constant(value=0), ctx=Load())), If(test=Call(func=Attribute(value=Name(id=''called'',
      ctx=Load()), attr=''startswith'', ctx=Load()), args=[Constant(value=''self.'')],
      keywords=[]), body=[Assign(targets=[Name(id=''method_name'', ctx=Store())],
      value=Call(func=Attribute(value=Name(id=''called'', ctx=Load()), attr=''replace'',
      ctx=Load()), args=[Constant(value=''self.''), Constant(value='''')], keywords=[])),
      Assign(targets=[Name(id=''fully_qualified_name'', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id=''source_name'',
      ctx=Load()), attr=''split'', ctx=Load()), args=[Constant(value=''.'')], keywords=[]),
      slice=Constant(value=0), ctx=Load()), conversion=-1), Constant(value=''.''),
      FormattedValue(value=Name(id=''method_name'', ctx=Load()), conversion=-1)])),
      If(test=Compare(left=Name(id=''fully_qualified_name'', ctx=Load()), ops=[In()],
      comparators=[Name(id=''class_method_details_lookup'', ctx=Load())]), body=[Expr(value=Call(func=Name(id=''add_edge_with_data'',
      ctx=Load()), args=[Name(id=''source_name'', ctx=Load()), Name(id=''fully_qualified_name'',
      ctx=Load())], keywords=[])), Continue()], orelse=[])], orelse=[]), If(test=BoolOp(op=Or(),
      values=[Compare(left=Name(id=''called'', ctx=Load()), ops=[In()], comparators=[Name(id=''function_details_lookup'',
      ctx=Load())]), Compare(left=Name(id=''called'', ctx=Load()), ops=[In()], comparators=[Name(id=''class_method_details_lookup'',
      ctx=Load())]), Compare(left=JoinedStr(values=[FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id=''source_name'',
      ctx=Load()), attr=''split'', ctx=Load()), args=[Constant(value=''.'')], keywords=[]),
      slice=Constant(value=0), ctx=Load()), conversion=-1), Constant(value=''.''),
      FormattedValue(value=Name(id=''called'', ctx=Load()), conversion=-1)]), ops=[In()],
      comparators=[Name(id=''class_method_details_lookup'', ctx=Load())])]), body=[Expr(value=Call(func=Name(id=''add_edge_with_data'',
      ctx=Load()), args=[Name(id=''source_name'', ctx=Load()), Name(id=''called'',
      ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id=''called_class_name'',
      ctx=Load()), ops=[In()], comparators=[Name(id=''class_names'', ctx=Load())]),
      body=[Assign(targets=[Name(id=''init_method'', ctx=Store())], value=Constant(value=None)),
      Assign(targets=[Name(id=''init_method_name'', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id=''called'',
      ctx=Load()), conversion=-1), Constant(value=''.__init__'')])), If(test=Compare(left=Name(id=''init_method_name'',
      ctx=Load()), ops=[In()], comparators=[Name(id=''class_method_details_lookup'',
      ctx=Load())]), body=[Assign(targets=[Name(id=''init_method'', ctx=Store())],
      value=Name(id=''init_method_name'', ctx=Load()))], orelse=[]), Expr(value=Call(func=Name(id=''add_edge_with_data'',
      ctx=Load()), args=[Name(id=''source_name'', ctx=Load()), Name(id=''called'',
      ctx=Load()), Name(id=''init_method'', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''called'', ctx=Load())],
      keywords=[])), Expr(value=Call(func=Name(id=''add_edge_with_data'', ctx=Load()),
      args=[Name(id=''source_name'', ctx=Load()), Name(id=''called'', ctx=Load())],
      keywords=[]))])])], orelse=[])], decorator_list=[]), For(target=Name(id=''function_name'',
      ctx=Store()), iter=Call(func=Attribute(value=Name(id=''function_details_lookup'',
      ctx=Load()), attr=''keys'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''add_node'', ctx=Load()), args=[Name(id=''function_name'',
      ctx=Load())], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id=''func_name'',
      ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''function_details_lookup'',
      ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id=''add_edges_for_calls'',
      ctx=Load()), args=[Name(id=''func_name'', ctx=Load()), Subscript(value=Name(id=''details'',
      ctx=Load()), slice=Constant(value=''calls''), ctx=Load())], keywords=[]))],
      orelse=[]), For(target=Tuple(elts=[Name(id=''qualified_method_name'', ctx=Store()),
      Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_method_details_lookup'',
      ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id=''add_edges_for_calls'',
      ctx=Load()), args=[Name(id=''qualified_method_name'', ctx=Load()), Subscript(value=Name(id=''details'',
      ctx=Load()), slice=Constant(value=''calls''), ctx=Load())], keywords=[]))],
      orelse=[]), For(target=Name(id=''edge'', ctx=Store()), iter=Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''edges'', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id=''source'',
      ctx=Store()), Name(id=''target'', ctx=Store())], ctx=Store())], value=Name(id=''edge'',
      ctx=Load())), Assign(targets=[Name(id=''target_details'', ctx=Store())], value=BoolOp(op=Or(),
      values=[Call(func=Attribute(value=Name(id=''function_details_lookup'', ctx=Load()),
      attr=''get'', ctx=Load()), args=[Name(id=''target'', ctx=Load())], keywords=[]),
      Call(func=Attribute(value=Name(id=''class_method_details_lookup'', ctx=Load()),
      attr=''get'', ctx=Load()), args=[Name(id=''target'', ctx=Load())], keywords=[])])),
      Assign(targets=[Name(id=''source_details'', ctx=Store())], value=BoolOp(op=Or(),
      values=[Call(func=Attribute(value=Name(id=''function_details_lookup'', ctx=Load()),
      attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())], keywords=[]),
      Call(func=Attribute(value=Name(id=''class_method_details_lookup'', ctx=Load()),
      attr=''get'', ctx=Load()), args=[Name(id=''source'', ctx=Load())], keywords=[])])),
      Assign(targets=[Name(id=''edge_data'', ctx=Store())], value=Call(func=Name(id=''get_edge_data_from_details'',
      ctx=Load()), args=[Name(id=''target_details'', ctx=Load()), Name(id=''source_details'',
      ctx=Load()), Name(id=''target'', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Subscript(value=Subscript(value=Name(id=''G'',
      ctx=Load()), slice=Name(id=''source'', ctx=Load()), ctx=Load()), slice=Name(id=''target'',
      ctx=Load()), ctx=Load()), attr=''update'', ctx=Load()), args=[Name(id=''edge_data'',
      ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id=''nodes'',
      ctx=Store())], value=Call(func=Name(id=''list'', ctx=Load()), args=[Attribute(value=Name(id=''G'',
      ctx=Load()), attr=''nodes'', ctx=Load())], keywords=[])), Assign(targets=[Name(id=''edges'',
      ctx=Store())], value=ListComp(elt=Dict(keys=[Constant(value=''source''), Constant(value=''target''),
      None], values=[Subscript(value=Name(id=''edge'', ctx=Load()), slice=Constant(value=0),
      ctx=Load()), Subscript(value=Name(id=''edge'', ctx=Load()), slice=Constant(value=1),
      ctx=Load()), Subscript(value=Name(id=''edge'', ctx=Load()), slice=Constant(value=2),
      ctx=Load())]), generators=[comprehension(target=Name(id=''edge'', ctx=Store()),
      iter=Call(func=Attribute(value=Attribute(value=Name(id=''G'', ctx=Load()), attr=''edges'',
      ctx=Load()), attr=''data'', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])),
      Return(value=Dict(keys=[Constant(value=''nodes''), Constant(value=''edges'')],
      values=[Name(id=''nodes'', ctx=Load()), Name(id=''edges'', ctx=Load())]))],
      decorator_list=[], returns=Subscript(value=Name(id=''Dict'', ctx=Load()), slice=Tuple(elts=[Name(id=''str'',
      ctx=Load()), Subscript(value=Name(id=''Union'', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id=''List'',
      ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load()), Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
      ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
      ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))'
    function_docstring: "\n    Create a dictionary representation of file details.\n\
      \    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted\
      \ from the file.\n    Returns:\n        dict: A dictionary with nodes and edges\
      \ representing the relationships in the code.\n    "
    function_inputs:
    - file_summary
    function_defaults: []
    function_returns:
    - '{''nodes'': nodes, ''edges'': edges}'
    - edge_data
    function_calls:
    - nx.DiGraph
    - function_details_lookup.update
    - class_def.items
    - G.add_node
    - class_details['method_defs'].items
    - G.add_edge
    - target_details.get
    - list
    - set
    - class_method_details_lookup.get
    - function_details_lookup.get
    - get_edge_data_from_details
    - class_def.keys
    - called.split
    - called.startswith
    - called.replace
    - source_name.split
    - add_edge_with_data
    - function_details_lookup.keys
    - function_details_lookup.items
    - add_edges_for_calls
    - class_method_details_lookup.items
    - G[source][target].update
    - G.edges.data
    function_call_inputs:
      nx.DiGraph: []
      function_details_lookup.update:
      - function_def
      class_def.items: []
      G.add_node:
      - function_name
      class_details['method_defs'].items: []
      G.add_edge:
      - source
      - target
      target_details.get:
      - '''returns'''
      - '[]'
      list:
      - G.nodes
      set:
      - target_details.get('returns', [])
      class_method_details_lookup.get:
      - source
      function_details_lookup.get:
      - source
      get_edge_data_from_details:
      - target_details
      - source_details
      - target
      class_def.keys: []
      called.split:
      - '''.'''
      called.startswith:
      - '''self.'''
      called.replace:
      - '''self.'''
      - ''''''
      source_name.split:
      - '''.'''
      add_edge_with_data:
      - source_name
      - called
      function_details_lookup.keys: []
      function_details_lookup.items: []
      add_edges_for_calls:
      - qualified_method_name
      - details['calls']
      class_method_details_lookup.items: []
      G[source][target].update:
      - edge_data
      G.edges.data: []
    function_variables:
    - qualified_method_name
    - method_name
    - function_details_lookup
    - nodes
    - fully_qualified_name
    - edges
    - init_method_name
    - target_details
    - source_details
    - edge_data
    - class_method_details_lookup
    - G
    - class_names
    - init_method
    - called_class_name
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_edge_data_from_details:
    function_name: get_edge_data_from_details
    function_code: "def get_edge_data_from_details(target_details: dict, source_details:\
      \ dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n\
      \        edge_data['target_inputs'] = target_details.get('inputs')\n       \
      \ edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n\
      \    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n\
      \        edge_data['target_inputs'] = source_details['call_inputs'][target]\n\
      \    return edge_data"
    function_ast: FunctionDef(name='get_edge_data_from_details', args=arguments(posonlyargs=[],
      args=[arg(arg='target_details', annotation=Name(id='dict', ctx=Load())), arg(arg='source_details',
      annotation=Name(id='dict', ctx=Load())), arg(arg='target', annotation=Name(id='str',
      ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='edge_data',
      ctx=Store())], value=Dict(keys=[], values=[])), If(test=Name(id='target_details',
      ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='edge_data', ctx=Load()),
      slice=Constant(value='target_inputs'), ctx=Store())], value=Call(func=Attribute(value=Name(id='target_details',
      ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='inputs')], keywords=[])),
      Assign(targets=[Subscript(value=Name(id='edge_data', ctx=Load()), slice=Constant(value='target_returns'),
      ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='set',
      ctx=Load()), args=[Call(func=Attribute(value=Name(id='target_details', ctx=Load()),
      attr='get', ctx=Load()), args=[Constant(value='returns'), List(elts=[], ctx=Load())],
      keywords=[])], keywords=[])], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(),
      values=[Name(id='source_details', ctx=Load()), Compare(left=Constant(value='call_inputs'),
      ops=[In()], comparators=[Name(id='source_details', ctx=Load())]), Compare(left=Name(id='target',
      ctx=Load()), ops=[In()], comparators=[Subscript(value=Name(id='source_details',
      ctx=Load()), slice=Constant(value='call_inputs'), ctx=Load())])]), body=[Assign(targets=[Subscript(value=Name(id='edge_data',
      ctx=Load()), slice=Constant(value='target_inputs'), ctx=Store())], value=Subscript(value=Subscript(value=Name(id='source_details',
      ctx=Load()), slice=Constant(value='call_inputs'), ctx=Load()), slice=Name(id='target',
      ctx=Load()), ctx=Load()))], orelse=[]), Return(value=Name(id='edge_data', ctx=Load()))],
      decorator_list=[], returns=Name(id='dict', ctx=Load()))
    function_docstring: null
    function_inputs:
    - target_details
    - source_details
    - target
    function_defaults: []
    function_returns:
    - edge_data
    function_calls:
    - target_details.get
    - list
    - set
    function_call_inputs:
      target_details.get:
      - '''returns'''
      - '[]'
      list:
      - set(target_details.get('returns', []))
      set:
      - target_details.get('returns', [])
    function_variables:
    - edge_data
    function_decorators: []
    function_annotations: []
    function_properties: []
  add_edge_with_data:
    function_name: add_edge_with_data
    function_code: "def add_edge_with_data(source: str, target: str, init_method:\
      \ Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method\
      \ or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source)\
      \ or class_method_details_lookup.get(source)\n    G.add_edge(source, target,\
      \ **get_edge_data_from_details(target_details, source_details, target))"
    function_ast: FunctionDef(name='add_edge_with_data', args=arguments(posonlyargs=[],
      args=[arg(arg='source', annotation=Name(id='str', ctx=Load())), arg(arg='target',
      annotation=Name(id='str', ctx=Load())), arg(arg='init_method', annotation=Subscript(value=Name(id='Optional',
      ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[],
      kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Name(id='target_details',
      ctx=Store())], value=BoolOp(op=Or(), values=[Call(func=Attribute(value=Name(id='class_method_details_lookup',
      ctx=Load()), attr='get', ctx=Load()), args=[BoolOp(op=Or(), values=[Name(id='init_method',
      ctx=Load()), Name(id='target', ctx=Load())])], keywords=[]), Call(func=Attribute(value=Name(id='function_details_lookup',
      ctx=Load()), attr='get', ctx=Load()), args=[Name(id='target', ctx=Load())],
      keywords=[])])), Assign(targets=[Name(id='source_details', ctx=Store())], value=BoolOp(op=Or(),
      values=[Call(func=Attribute(value=Name(id='function_details_lookup', ctx=Load()),
      attr='get', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[]),
      Call(func=Attribute(value=Name(id='class_method_details_lookup', ctx=Load()),
      attr='get', ctx=Load()), args=[Name(id='source', ctx=Load())], keywords=[])])),
      Expr(value=Call(func=Attribute(value=Name(id='G', ctx=Load()), attr='add_edge',
      ctx=Load()), args=[Name(id='source', ctx=Load()), Name(id='target', ctx=Load())],
      keywords=[keyword(value=Call(func=Name(id='get_edge_data_from_details', ctx=Load()),
      args=[Name(id='target_details', ctx=Load()), Name(id='source_details', ctx=Load()),
      Name(id='target', ctx=Load())], keywords=[]))]))], decorator_list=[], returns=Constant(value=None))
    function_docstring: null
    function_inputs:
    - source
    - target
    - init_method
    function_defaults:
    - None
    function_returns: []
    function_calls:
    - class_method_details_lookup.get
    - function_details_lookup.get
    - G.add_edge
    - get_edge_data_from_details
    function_call_inputs:
      class_method_details_lookup.get:
      - source
      function_details_lookup.get:
      - source
      G.add_edge:
      - source
      - target
      get_edge_data_from_details:
      - target_details
      - source_details
      - target
    function_variables:
    - target_details
    - source_details
    function_decorators: []
    function_annotations: []
    function_properties: []
  add_edges_for_calls:
    function_name: add_edges_for_calls
    function_code: "def add_edges_for_calls(source_name, calls):\n    class_names\
      \ = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n\
      \    for called in calls:\n        called_class_name = called.split('.')[0]\n\
      \        if called.startswith('self.'):\n            method_name = called.replace('self.',\
      \ '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
      \n            if fully_qualified_name in class_method_details_lookup:\n    \
      \            add_edge_with_data(source_name, fully_qualified_name)\n       \
      \         continue\n        if called in function_details_lookup or called in\
      \ class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in\
      \ class_method_details_lookup:\n            add_edge_with_data(source_name,\
      \ called)\n        elif called_class_name in class_names:\n            init_method\
      \ = None\n            init_method_name = f'{called}.__init__'\n            if\
      \ init_method_name in class_method_details_lookup:\n                init_method\
      \ = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n\
      \        else:\n            G.add_node(called)\n            add_edge_with_data(source_name,\
      \ called)"
    function_ast: FunctionDef(name='add_edges_for_calls', args=arguments(posonlyargs=[],
      args=[arg(arg='source_name'), arg(arg='calls')], kwonlyargs=[], kw_defaults=[],
      defaults=[]), body=[Assign(targets=[Name(id='class_names', ctx=Store())], value=ListComp(elt=Subscript(value=Call(func=Name(id='list',
      ctx=Load()), args=[Call(func=Attribute(value=Name(id='class_def', ctx=Load()),
      attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), slice=Constant(value=0),
      ctx=Load()), generators=[comprehension(target=Name(id='class_def', ctx=Store()),
      iter=Subscript(value=Name(id='file_summary', ctx=Load()), slice=Constant(value='class_defs'),
      ctx=Load()), ifs=[], is_async=0)])), For(target=Name(id='called', ctx=Store()),
      iter=Name(id='calls', ctx=Load()), body=[Assign(targets=[Name(id='called_class_name',
      ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='called',
      ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]),
      slice=Constant(value=0), ctx=Load())), If(test=Call(func=Attribute(value=Name(id='called',
      ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='self.')],
      keywords=[]), body=[Assign(targets=[Name(id='method_name', ctx=Store())], value=Call(func=Attribute(value=Name(id='called',
      ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='self.'), Constant(value='')],
      keywords=[])), Assign(targets=[Name(id='fully_qualified_name', ctx=Store())],
      value=JoinedStr(values=[FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id='source_name',
      ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]),
      slice=Constant(value=0), ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Name(id='method_name',
      ctx=Load()), conversion=-1)])), If(test=Compare(left=Name(id='fully_qualified_name',
      ctx=Load()), ops=[In()], comparators=[Name(id='class_method_details_lookup',
      ctx=Load())]), body=[Expr(value=Call(func=Name(id='add_edge_with_data', ctx=Load()),
      args=[Name(id='source_name', ctx=Load()), Name(id='fully_qualified_name', ctx=Load())],
      keywords=[])), Continue()], orelse=[])], orelse=[]), If(test=BoolOp(op=Or(),
      values=[Compare(left=Name(id='called', ctx=Load()), ops=[In()], comparators=[Name(id='function_details_lookup',
      ctx=Load())]), Compare(left=Name(id='called', ctx=Load()), ops=[In()], comparators=[Name(id='class_method_details_lookup',
      ctx=Load())]), Compare(left=JoinedStr(values=[FormattedValue(value=Subscript(value=Call(func=Attribute(value=Name(id='source_name',
      ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]),
      slice=Constant(value=0), ctx=Load()), conversion=-1), Constant(value='.'), FormattedValue(value=Name(id='called',
      ctx=Load()), conversion=-1)]), ops=[In()], comparators=[Name(id='class_method_details_lookup',
      ctx=Load())])]), body=[Expr(value=Call(func=Name(id='add_edge_with_data', ctx=Load()),
      args=[Name(id='source_name', ctx=Load()), Name(id='called', ctx=Load())], keywords=[]))],
      orelse=[If(test=Compare(left=Name(id='called_class_name', ctx=Load()), ops=[In()],
      comparators=[Name(id='class_names', ctx=Load())]), body=[Assign(targets=[Name(id='init_method',
      ctx=Store())], value=Constant(value=None)), Assign(targets=[Name(id='init_method_name',
      ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Name(id='called',
      ctx=Load()), conversion=-1), Constant(value='.__init__')])), If(test=Compare(left=Name(id='init_method_name',
      ctx=Load()), ops=[In()], comparators=[Name(id='class_method_details_lookup',
      ctx=Load())]), body=[Assign(targets=[Name(id='init_method', ctx=Store())], value=Name(id='init_method_name',
      ctx=Load()))], orelse=[]), Expr(value=Call(func=Name(id='add_edge_with_data',
      ctx=Load()), args=[Name(id='source_name', ctx=Load()), Name(id='called', ctx=Load()),
      Name(id='init_method', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='G',
      ctx=Load()), attr='add_node', ctx=Load()), args=[Name(id='called', ctx=Load())],
      keywords=[])), Expr(value=Call(func=Name(id='add_edge_with_data', ctx=Load()),
      args=[Name(id='source_name', ctx=Load()), Name(id='called', ctx=Load())], keywords=[]))])])],
      orelse=[])], decorator_list=[])
    function_docstring: null
    function_inputs:
    - source_name
    - calls
    function_defaults: []
    function_returns: []
    function_calls:
    - list
    - class_def.keys
    - called.split
    - called.startswith
    - called.replace
    - source_name.split
    - add_edge_with_data
    - G.add_node
    function_call_inputs:
      list:
      - class_def.keys()
      class_def.keys: []
      called.split:
      - '''.'''
      called.startswith:
      - '''self.'''
      called.replace:
      - '''self.'''
      - ''''''
      source_name.split:
      - '''.'''
      add_edge_with_data:
      - source_name
      - called
      G.add_node:
      - called
    function_variables:
    - method_name
    - fully_qualified_name
    - init_method_name
    - class_names
    - init_method
    - called_class_name
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_python_file_details:
    function_name: get_python_file_details
    function_code: "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict,\
      \ str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n \
      \       file_path: str: The path to the Python file.\n    Returns:\n       \
      \ Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\
      \"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore')\
      \ as f:\n            code = f.read()\n            tree = ast.parse(code)\n \
      \   except:\n        logging.warning(f'Permission denied or syntax error in\
      \ file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n\
      \    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info,\
      \ 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph']\
      \ = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary']\
      \ = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n\
      \    return file_details"
    function_ast: 'FunctionDef(name=''get_python_file_details'', args=arguments(posonlyargs=[],
      args=[arg(arg=''file_path'', annotation=Name(id=''str'', ctx=Load()))], kwonlyargs=[],
      kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n    Extract
      details from a Python file.\n    Args:\n        file_path: str: The path to
      the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details
      extracted from the file.\n    '')), Try(body=[With(items=[withitem(context_expr=Call(func=Name(id=''open'',
      ctx=Load()), args=[Name(id=''file_path'', ctx=Load()), Constant(value=''r'')],
      keywords=[keyword(arg=''encoding'', value=Constant(value=''utf-8'')), keyword(arg=''errors'',
      value=Constant(value=''ignore''))]), optional_vars=Name(id=''f'', ctx=Store()))],
      body=[Assign(targets=[Name(id=''code'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''f'',
      ctx=Load()), attr=''read'', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id=''tree'',
      ctx=Store())], value=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''parse'', ctx=Load()), args=[Name(id=''code'', ctx=Load())], keywords=[]))])],
      handlers=[ExceptHandler(body=[Expr(value=Call(func=Attribute(value=Name(id=''logging'',
      ctx=Load()), attr=''warning'', ctx=Load()), args=[JoinedStr(values=[Constant(value=''Permission
      denied or syntax error in file: ''), FormattedValue(value=Name(id=''file_path'',
      ctx=Load()), conversion=-1)])], keywords=[])), Return(value=Constant(value=None))])],
      orelse=[], finalbody=[]), Assign(targets=[Name(id=''visitor'', ctx=Store())],
      value=Call(func=Name(id=''CodeVisitor'', ctx=Load()), args=[Name(id=''code'',
      ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id=''visitor'',
      ctx=Load()), attr=''analyze'', ctx=Load()), args=[Name(id=''tree'', ctx=Load())],
      keywords=[])), Assign(targets=[Name(id=''file_details'', ctx=Store())], value=Dict(keys=[Constant(value=''file_info''),
      Constant(value=''functions''), Constant(value=''classes'')], values=[Attribute(value=Name(id=''visitor'',
      ctx=Load()), attr=''file_info'', ctx=Load()), Attribute(value=Name(id=''visitor'',
      ctx=Load()), attr=''functions'', ctx=Load()), Attribute(value=Name(id=''visitor'',
      ctx=Load()), attr=''classes'', ctx=Load())])), Assign(targets=[Subscript(value=Subscript(value=Name(id=''file_details'',
      ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''entire_code_graph''),
      ctx=Store())], value=Call(func=Name(id=''code_graph'', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id=''file_details'',
      ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''file_summary''),
      ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Subscript(value=Name(id=''file_details'',
      ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''file_summary''),
      ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id=''json'',
      ctx=Load()), attr=''dumps'', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id=''file_details'',
      ctx=Load()), slice=Constant(value=''file_info''), ctx=Load()), slice=Constant(value=''file_summary''),
      ctx=Load())], keywords=[]), attr=''replace'', ctx=Load()), args=[Constant(value=''"''),
      Constant(value='''')], keywords=[])), Return(value=Name(id=''file_details'',
      ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''Dict'', ctx=Load()), Name(id=''str'',
      ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))'
    function_docstring: "\n    Extract details from a Python file.\n    Args:\n  \
      \      file_path: str: The path to the Python file.\n    Returns:\n        Dict[str,\
      \ Union[Dict, str]]: The details extracted from the file.\n    "
    function_inputs:
    - file_path
    function_defaults: []
    function_returns:
    - file_details
    - None
    function_calls:
    - open
    - f.read
    - ast.parse
    - logging.warning
    - CodeVisitor
    - visitor.analyze
    - code_graph
    - json.dumps(file_details['file_info']['file_summary']).replace
    - json.dumps
    function_call_inputs:
      open:
      - file_path
      - '''r'''
      f.read: []
      ast.parse:
      - code
      logging.warning:
      - 'f''Permission denied or syntax error in file: {file_path}'''
      CodeVisitor:
      - code
      visitor.analyze:
      - tree
      code_graph:
      - file_details['file_info']['file_summary']
      json.dumps(file_details['file_info']['file_summary']).replace:
      - '''"'''
      - ''''''
      json.dumps:
      - file_details['file_info']['file_summary']
    function_variables:
    - tree
    - visitor
    - file_details
    - code
    function_decorators: []
    function_annotations: []
    function_properties: []
classes:
  CodeVisitor:
    class_name: CodeVisitor
    class_code: "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class\
      \ for traversing an AST (Abstract Syntax Tree) and extracting details about\
      \ the code.\n    Attributes:\n        code (str): The source code.\n       \
      \ functions(Dict): details about functions in the code.\n        classes (Dict):\
      \ details about classes in the code.\n        file_info (Dict): details about\
      \ the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef)\
      \ -> None: \n            Extract details about a function.\n        visit_ClassDef(node:\
      \ ast.ClassDef) -> None: \n            Extract details about a class.\n    \
      \    extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str,\
      \ List[str]]]: \n            Extract details about a node.\n        analyze(node:\
      \ ast.AST) -> None: \n            Populate file_info with details about the\
      \ file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n\
      \        Initialize a new instance of the class.\n        Args:\n          \
      \  code: str: The source code.\n        Returns:\n            None\n       \
      \ \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str,\
      \ Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str,\
      \ List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]]\
      \ = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self,\
      \ node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about\
      \ a function.\n        Args:\n            node: ast.FunctionDef: The node to\
      \ visit.\n        Returns:\n            None\n        \"\"\"\n        details\
      \ = self.extract_details(node, 'method' if self.current_class else 'function')\n\
      \        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}']\
      \ = details\n        else:\n            self.functions[node.name] = details\n\
      \        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef)\
      \ -> None:\n        \"\"\"\n        Extract details about a class.\n       \
      \ Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n\
      \            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node,\
      \ 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n\
      \        self.current_class = None\n\n    def extract_details(self, node: ast.AST,\
      \ node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n   \
      \     Extract details about a node.\n        Args:\n            node: ast.AST:\
      \ The node to extract details from.\n            node_type: str: The type of\
      \ node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The\
      \ details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n\
      \        call_data = get_all_calls(node)\n        details = {f'{node_type}_name':\
      \ node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node),\
      \ f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n,\
      \ ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs':\
      \ [arg.arg for arg in node.args.args] if node_type in ['function', 'method']\
      \ else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults]\
      \ if node_type in ['function', 'method'] else None, f'{node_type}_returns':\
      \ [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode\
      \ in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()),\
      \ f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target)\
      \ for subnode in node_walk if isinstance(subnode, ast.Assign) for target in\
      \ subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators':\
      \ list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list\
      \ else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation)\
      \ for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation\
      \ is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode\
      \ in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx,\
      \ ast.Store)})}\n        if node_type in ['class', 'method']:\n            if\
      \ node_type == 'method' and self.current_class:\n                attributes\
      \ = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign)\
      \ for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value,\
      \ ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes',\
      \ []).extend(attributes)\n            if node_type == 'class':\n           \
      \     details.update({'class_attributes': [target.attr for subnode in node.body\
      \ if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target,\
      \ ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if\
      \ isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance':\
      \ [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods':\
      \ [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)\
      \ and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and\
      \ decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n\
      \        return details\n\n    def analyze(self, node: ast.AST) -> None:\n \
      \       \"\"\"\n        Traverse the AST rooted at 'node', create a list of\
      \ all nodes within the current file, and populate 'file_info' with file details\n\
      \        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n\
      \            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n\
      \        self.visit(node)\n        self.file_info = {'file_code': self.code,\
      \ 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode\
      \ in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names}\
      \ | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\
      \ 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n\
      \        function_defs = [{func_name: {'inputs': details['function_inputs'],\
      \ 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'],\
      \ 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n\
      \        class_defs = []\n        for class_name, class_details in self.classes.items():\n\
      \            method_defs = {}\n            for method_name, details in class_details.items():\n\
      \                if method_name.startswith('class_method_'):\n             \
      \       method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'],\
      \ 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'],\
      \ 'returns': details['method_returns']}\n            class_defs.append({class_name:\
      \ {'method_defs': method_defs}})\n        self.file_info['file_summary'] = {'dependencies':\
      \ self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs':\
      \ class_defs}\n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n\
      \        self.file_info['file_code_simplified'] = file_code_simplified"
    class_ast: 'ClassDef(name=''CodeVisitor'', bases=[Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''NodeVisitor'', ctx=Load())], keywords=[], body=[Expr(value=Constant(value=''\n    Visitor
      class for traversing an AST (Abstract Syntax Tree) and extracting details about
      the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict):
      details about functions in the code.\n        classes (Dict): details about
      classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node:
      ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node:
      ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node:
      ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract
      details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate
      file_info with details about the file.\n    '')), FunctionDef(name=''__init__'',
      args=arguments(posonlyargs=[], args=[arg(arg=''self''), arg(arg=''code'', annotation=Name(id=''str'',
      ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n        Initialize
      a new instance of the class.\n        Args:\n            code: str: The source
      code.\n        Returns:\n            None\n        '')), AnnAssign(target=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''code'', ctx=Store()), annotation=Name(id=''str'', ctx=Load()),
      value=Name(id=''code'', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''functions'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
      ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
      ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[],
      values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'', ctx=Load()),
      attr=''classes'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
      ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
      ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[],
      values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'', ctx=Load()),
      attr=''file_info'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
      ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
      ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0),
      AnnAssign(target=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
      ctx=Store()), annotation=Name(id=''str'', ctx=Load()), value=Constant(value=None),
      simple=0)], decorator_list=[]), FunctionDef(name=''visit_FunctionDef'', args=arguments(posonlyargs=[],
      args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''FunctionDef'', ctx=Load()))], kwonlyargs=[], kw_defaults=[],
      defaults=[]), body=[Expr(value=Constant(value=''\n        Extract details about
      a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        '')),
      Assign(targets=[Name(id=''details'', ctx=Store())], value=Call(func=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''extract_details'', ctx=Load()), args=[Name(id=''node'',
      ctx=Load()), IfExp(test=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
      ctx=Load()), body=Constant(value=''method''), orelse=Constant(value=''function''))],
      keywords=[])), If(test=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
      ctx=Load()), body=[Assign(targets=[Subscript(value=Subscript(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''current_class'', ctx=Load()), ctx=Load()), slice=JoinedStr(values=[Constant(value=''class_method_''),
      FormattedValue(value=Attribute(value=Name(id=''node'', ctx=Load()), attr=''name'',
      ctx=Load()), conversion=-1)]), ctx=Store())], value=Name(id=''details'', ctx=Load()))],
      orelse=[Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'', ctx=Load()),
      attr=''functions'', ctx=Load()), slice=Attribute(value=Name(id=''node'', ctx=Load()),
      attr=''name'', ctx=Load()), ctx=Store())], value=Name(id=''details'', ctx=Load()))]),
      Expr(value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()), attr=''generic_visit'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[]))], decorator_list=[],
      returns=Constant(value=None)), FunctionDef(name=''visit_ClassDef'', args=arguments(posonlyargs=[],
      args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''ClassDef'', ctx=Load()))], kwonlyargs=[], kw_defaults=[],
      defaults=[]), body=[Expr(value=Constant(value=''\n        Extract details about
      a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        '')),
      Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'', ctx=Load()),
      attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''node'', ctx=Load()),
      attr=''name'', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''extract_details'', ctx=Load()), args=[Name(id=''node'',
      ctx=Load()), Constant(value=''class'')], keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''current_class'', ctx=Store())], value=Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''name'', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''generic_visit'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
      keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'', ctx=Load()),
      attr=''current_class'', ctx=Store())], value=Constant(value=None))], decorator_list=[],
      returns=Constant(value=None)), FunctionDef(name=''extract_details'', args=arguments(posonlyargs=[],
      args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''AST'', ctx=Load())), arg(arg=''node_type'', annotation=Name(id=''str'',
      ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n        Extract
      details about a node.\n        Args:\n            node: ast.AST: The node to
      extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str,
      Union[str, List[str]]]: The details extracted from the node.\n        '')),
      Assign(targets=[Name(id=''node_walk'', ctx=Store())], value=Call(func=Name(id=''list'',
      ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''walk'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])], keywords=[])),
      Assign(targets=[Name(id=''call_data'', ctx=Store())], value=Call(func=Name(id=''get_all_calls'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])), Assign(targets=[Name(id=''details'',
      ctx=Store())], value=Dict(keys=[JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_name'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_code'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_ast'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_docstring'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_inputs'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_defaults'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_returns'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_calls'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_call_inputs'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_variables'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_decorators'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_annotations'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
      ctx=Load()), conversion=-1), Constant(value=''_properties'')])], values=[Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''name'', ctx=Load()), Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
      keywords=[]), Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''dump'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[]), Call(func=Name(id=''next'',
      ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Attribute(value=Name(id=''n'',
      ctx=Load()), attr=''value'', ctx=Load()), attr=''s'', ctx=Load()), generators=[comprehension(target=Name(id=''n'',
      ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(),
      values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''n'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Expr'', ctx=Load())],
      keywords=[]), Call(func=Name(id=''isinstance'', ctx=Load()), args=[Attribute(value=Name(id=''n'',
      ctx=Load()), attr=''value'', ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''Str'', ctx=Load())], keywords=[])])], is_async=0)]), Constant(value=None)],
      keywords=[]), IfExp(test=Compare(left=Name(id=''node_type'', ctx=Load()), ops=[In()],
      comparators=[List(elts=[Constant(value=''function''), Constant(value=''method'')],
      ctx=Load())]), body=ListComp(elt=Attribute(value=Name(id=''arg'', ctx=Load()),
      attr=''arg'', ctx=Load()), generators=[comprehension(target=Name(id=''arg'',
      ctx=Store()), iter=Attribute(value=Attribute(value=Name(id=''node'', ctx=Load()),
      attr=''args'', ctx=Load()), attr=''args'', ctx=Load()), ifs=[], is_async=0)]),
      orelse=Constant(value=None)), IfExp(test=Compare(left=Name(id=''node_type'',
      ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''function''),
      Constant(value=''method'')], ctx=Load())]), body=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''d'', ctx=Load())],
      keywords=[]), generators=[comprehension(target=Name(id=''d'', ctx=Store()),
      iter=Attribute(value=Attribute(value=Name(id=''node'', ctx=Load()), attr=''args'',
      ctx=Load()), attr=''defaults'', ctx=Load()), ifs=[], is_async=0)]), orelse=Constant(value=None)),
      ListComp(elt=IfExp(test=Compare(left=Attribute(value=Name(id=''subnode'', ctx=Load()),
      attr=''value'', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]),
      body=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''unparse'',
      ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''value'',
      ctx=Load())], keywords=[]), orelse=Constant(value=''None'')), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Return'', ctx=Load())], keywords=[])], is_async=0)]), Call(func=Name(id=''list'',
      ctx=Load()), args=[Call(func=Attribute(value=Name(id=''call_data'', ctx=Load()),
      attr=''keys'', ctx=Load()), args=[], keywords=[])], keywords=[]), Name(id=''call_data'',
      ctx=Load()), Call(func=Name(id=''list'', ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''target'', ctx=Load())],
      keywords=[]), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
      iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Assign'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
      ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
      ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''target'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'', ctx=Load())],
      keywords=[])], is_async=0)])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()),
      args=[IfExp(test=Attribute(value=Name(id=''node'', ctx=Load()), attr=''decorator_list'',
      ctx=Load()), body=SetComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''unparse'', ctx=Load()), args=[Name(id=''decorator'', ctx=Load())], keywords=[]),
      generators=[comprehension(target=Name(id=''decorator'', ctx=Store()), iter=Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''decorator_list'', ctx=Load()), ifs=[], is_async=0)]), orelse=Call(func=Name(id=''set'',
      ctx=Load()), args=[], keywords=[]))], keywords=[]), Call(func=Name(id=''list'',
      ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''unparse'', ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()),
      attr=''annotation'', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(),
      values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''AnnAssign'',
      ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
      ctx=Load()), attr=''annotation'', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])])],
      is_async=0)])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''subnode'', ctx=Load())],
      keywords=[]), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
      iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Attribute'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''ctx'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Store'', ctx=Load())],
      keywords=[])])], is_async=0)])], keywords=[])])), If(test=Compare(left=Name(id=''node_type'',
      ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''class''),
      Constant(value=''method'')], ctx=Load())]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id=''node_type'',
      ctx=Load()), ops=[Eq()], comparators=[Constant(value=''method'')]), Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''current_class'', ctx=Load())]), body=[Assign(targets=[Name(id=''attributes'',
      ctx=Store())], value=ListComp(elt=Attribute(value=Name(id=''target'', ctx=Load()),
      attr=''attr'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Assign'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
      ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
      ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''target'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Attribute'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Attribute(value=Name(id=''target'', ctx=Load()), attr=''value'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'', ctx=Load())],
      keywords=[]), Compare(left=Attribute(value=Attribute(value=Name(id=''target'',
      ctx=Load()), attr=''value'', ctx=Load()), attr=''id'', ctx=Load()), ops=[Eq()],
      comparators=[Constant(value=''self'')])])], is_async=0)])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''current_class'', ctx=Load()), ctx=Load()), attr=''setdefault'',
      ctx=Load()), args=[Constant(value=''class_attributes''), List(elts=[], ctx=Load())],
      keywords=[]), attr=''extend'', ctx=Load()), args=[Name(id=''attributes'', ctx=Load())],
      keywords=[]))], orelse=[]), If(test=Compare(left=Name(id=''node_type'', ctx=Load()),
      ops=[Eq()], comparators=[Constant(value=''class'')]), body=[Expr(value=Call(func=Attribute(value=Name(id=''details'',
      ctx=Load()), attr=''update'', ctx=Load()), args=[Dict(keys=[Constant(value=''class_attributes''),
      Constant(value=''class_methods''), Constant(value=''class_inheritance''), Constant(value=''class_static_methods'')],
      values=[ListComp(elt=Attribute(value=Name(id=''target'', ctx=Load()), attr=''attr'',
      ctx=Load()), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
      iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'', ctx=Load()),
      ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Assign'',
      ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
      ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
      ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''target'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Attribute'',
      ctx=Load())], keywords=[])], is_async=0)]), ListComp(elt=Attribute(value=Name(id=''subnode'',
      ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'',
      ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''FunctionDef'', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
      ctx=Load()), attr=''name'', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=''__init__'')])])],
      is_async=0)]), IfExp(test=Attribute(value=Name(id=''node'', ctx=Load()), attr=''bases'',
      ctx=Load()), body=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
      attr=''unparse'', ctx=Load()), args=[Name(id=''base'', ctx=Load())], keywords=[]),
      generators=[comprehension(target=Name(id=''base'', ctx=Store()), iter=Attribute(value=Name(id=''node'',
      ctx=Load()), attr=''bases'', ctx=Load()), ifs=[], is_async=0)]), orelse=List(elts=[],
      ctx=Load())), ListComp(elt=Attribute(value=Name(id=''subnode'', ctx=Load()),
      attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'',
      ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''FunctionDef'', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
      ctx=Load()), attr=''name'', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=''__init__'')]),
      Call(func=Name(id=''any'', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(),
      values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''decorator'',
      ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'', ctx=Load())],
      keywords=[]), Compare(left=Attribute(value=Name(id=''decorator'', ctx=Load()),
      attr=''id'', ctx=Load()), ops=[Eq()], comparators=[Constant(value=''staticmethod'')])]),
      generators=[comprehension(target=Name(id=''decorator'', ctx=Store()), iter=Attribute(value=Name(id=''subnode'',
      ctx=Load()), attr=''decorator_list'', ctx=Load()), ifs=[], is_async=0)])], keywords=[])])],
      is_async=0)])])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id=''details'',
      ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id=''Dict'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
      ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
      ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
      ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name=''analyze'', args=arguments(posonlyargs=[],
      args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''AST'', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]),
      body=[Expr(value=Constant(value="\n        Traverse the AST rooted at ''node'',
      create a list of all nodes within the current file, and populate ''file_info''
      with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        ")),
      Assign(targets=[Name(id=''node_walk'', ctx=Store())], value=Call(func=Name(id=''list'',
      ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''walk'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])], keywords=[])),
      Expr(value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()), attr=''visit'',
      ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''file_info'', ctx=Store())], value=Dict(keys=[Constant(value=''file_code''),
      Constant(value=''file_ast''), Constant(value=''file_dependencies''), Constant(value=''file_functions''),
      Constant(value=''file_classes'')], values=[Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''code'', ctx=Load()), Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''dump'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
      keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[BinOp(left=SetComp(elt=Attribute(value=Name(id=''alias'',
      ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''Import'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''alias'',
      ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''names'',
      ctx=Load()), ifs=[], is_async=0)]), op=BitOr(), right=SetComp(elt=Attribute(value=Name(id=''subnode'',
      ctx=Load()), attr=''module'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
      ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
      ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''ImportFrom'', ctx=Load())], keywords=[])], is_async=0)]))],
      keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''functions'', ctx=Load()), attr=''keys'', ctx=Load()), args=[],
      keywords=[])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''classes'', ctx=Load()), attr=''keys'', ctx=Load()), args=[],
      keywords=[])], keywords=[])])), Assign(targets=[Name(id=''function_defs'', ctx=Store())],
      value=ListComp(elt=Dict(keys=[Name(id=''func_name'', ctx=Load())], values=[Dict(keys=[Constant(value=''inputs''),
      Constant(value=''calls''), Constant(value=''call_inputs''), Constant(value=''returns'')],
      values=[Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_inputs''),
      ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_calls''),
      ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_call_inputs''),
      ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_returns''),
      ctx=Load())])]), generators=[comprehension(target=Tuple(elts=[Name(id=''func_name'',
      ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''functions'', ctx=Load()), attr=''items'', ctx=Load()), args=[],
      keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id=''class_defs'',
      ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id=''class_name'',
      ctx=Store()), Name(id=''class_details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''classes'', ctx=Load()), attr=''items'', ctx=Load()), args=[],
      keywords=[]), body=[Assign(targets=[Name(id=''method_defs'', ctx=Store())],
      value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id=''method_name'',
      ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_details'',
      ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id=''method_name'',
      ctx=Load()), attr=''startswith'', ctx=Load()), args=[Constant(value=''class_method_'')],
      keywords=[]), body=[Assign(targets=[Subscript(value=Name(id=''method_defs'',
      ctx=Load()), slice=Subscript(value=Name(id=''method_name'', ctx=Load()), slice=Slice(lower=Call(func=Name(id=''len'',
      ctx=Load()), args=[Constant(value=''class_method_'')], keywords=[])), ctx=Load()),
      ctx=Store())], value=Dict(keys=[Constant(value=''inputs''), Constant(value=''calls''),
      Constant(value=''call_inputs''), Constant(value=''returns'')], values=[Subscript(value=Name(id=''details'',
      ctx=Load()), slice=Constant(value=''method_inputs''), ctx=Load()), Subscript(value=Name(id=''details'',
      ctx=Load()), slice=Constant(value=''method_calls''), ctx=Load()), Subscript(value=Name(id=''details'',
      ctx=Load()), slice=Constant(value=''method_call_inputs''), ctx=Load()), Subscript(value=Name(id=''details'',
      ctx=Load()), slice=Constant(value=''method_returns''), ctx=Load())]))], orelse=[])],
      orelse=[]), Expr(value=Call(func=Attribute(value=Name(id=''class_defs'', ctx=Load()),
      attr=''append'', ctx=Load()), args=[Dict(keys=[Name(id=''class_name'', ctx=Load())],
      values=[Dict(keys=[Constant(value=''method_defs'')], values=[Name(id=''method_defs'',
      ctx=Load())])])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_summary''),
      ctx=Store())], value=Dict(keys=[Constant(value=''dependencies''), Constant(value=''function_defs''),
      Constant(value=''class_defs'')], values=[Subscript(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_dependencies''),
      ctx=Load()), Name(id=''function_defs'', ctx=Load()), Name(id=''class_defs'',
      ctx=Load())])), Assign(targets=[Name(id=''file_code_simplified'', ctx=Store())],
      value=Call(func=Name(id=''remove_docs_and_comments'', ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'',
      ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
      keywords=[])], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
      ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_code_simplified''),
      ctx=Store())], value=Name(id=''file_code_simplified'', ctx=Load()))], decorator_list=[],
      returns=Constant(value=None))], decorator_list=[])'
    class_docstring: "\n    Visitor class for traversing an AST (Abstract Syntax Tree)\
      \ and extracting details about the code.\n    Attributes:\n        code (str):\
      \ The source code.\n        functions(Dict): details about functions in the\
      \ code.\n        classes (Dict): details about classes in the code.\n      \
      \  file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node:\
      \ ast.FunctionDef) -> None: \n            Extract details about a function.\n\
      \        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details\
      \ about a class.\n        extract_details(node: ast.AST, node_type: str) ->\
      \ Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n\
      \        analyze(node: ast.AST) -> None: \n            Populate file_info with\
      \ details about the file.\n    "
    class_inputs: null
    class_defaults: null
    class_returns:
    - details
    class_calls:
    - self.extract_details
    - self.generic_visit
    - list
    - ast.walk
    - get_all_calls
    - ast.unparse
    - ast.dump
    - next
    - isinstance
    - call_data.keys
    - set
    - self.classes[self.current_class].setdefault('class_attributes', []).extend
    - self.classes[self.current_class].setdefault
    - details.update
    - any
    - self.visit
    - self.functions.keys
    - self.classes.keys
    - self.functions.items
    - self.classes.items
    - class_details.items
    - method_name.startswith
    - len
    - class_defs.append
    - remove_docs_and_comments
    class_call_inputs:
      self.extract_details:
      - node
      - '''class'''
      self.generic_visit:
      - node
      list:
      - self.classes.keys()
      ast.walk:
      - node
      get_all_calls:
      - node
      ast.unparse:
      - node
      ast.dump:
      - node
      next:
      - (n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value,
        ast.Str))
      - None
      isinstance:
      - subnode
      - ast.ImportFrom
      call_data.keys: []
      set: []
      self.classes[self.current_class].setdefault('class_attributes', []).extend:
      - attributes
      self.classes[self.current_class].setdefault:
      - '''class_attributes'''
      - '[]'
      details.update:
      - '{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode,
        ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],
        ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode,
        ast.FunctionDef) and subnode.name != ''__init__''], ''class_inheritance'':
        [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'':
        [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)
        and subnode.name != ''__init__'' and any((isinstance(decorator, ast.Name)
        and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}'
      any:
      - (isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator
        in subnode.decorator_list)
      self.visit:
      - node
      self.functions.keys: []
      self.classes.keys: []
      self.functions.items: []
      self.classes.items: []
      class_details.items: []
      method_name.startswith:
      - '''class_method_'''
      len:
      - '''class_method_'''
      class_defs.append:
      - '{class_name: {''method_defs'': method_defs}}'
      remove_docs_and_comments:
      - ast.unparse(node)
    class_variables:
    - details
    - method_defs
    - function_defs
    - node_walk
    - call_data
    - class_defs
    - attributes
    - file_code_simplified
    class_decorators: []
    class_annotations:
    - Dict[str, Union[str, List[str]]]
    - Dict[str, Dict[str, Union[str, List[str]]]]
    - str
    class_properties:
    - self.file_info
    - self.functions
    - self.current_class
    - self.code
    - self.classes
    class_attributes:
    - current_class
    - current_class
    - file_info
    class_methods:
    - visit_FunctionDef
    - visit_ClassDef
    - extract_details
    - analyze
    class_inheritance:
    - ast.NodeVisitor
    class_static_methods: []
    class_method___init__:
      method_name: __init__
      method_code: "def __init__(self, code: str):\n    \"\"\"\n        Initialize\
        \ a new instance of the class.\n        Args:\n            code: str: The\
        \ source code.\n        Returns:\n            None\n        \"\"\"\n    self.code:\
        \ str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]]\
        \ = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n\
        \    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class:\
        \ str = None"
      method_ast: 'FunctionDef(name=''__init__'', args=arguments(posonlyargs=[], args=[arg(arg=''self''),
        arg(arg=''code'', annotation=Name(id=''str'', ctx=Load()))], kwonlyargs=[],
        kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n        Initialize
        a new instance of the class.\n        Args:\n            code: str: The source
        code.\n        Returns:\n            None\n        '')), AnnAssign(target=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''code'', ctx=Store()), annotation=Name(id=''str'', ctx=Load()),
        value=Name(id=''code'', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''functions'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Dict'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
        ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
        ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[],
        values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''classes'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Dict'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
        ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
        ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[],
        values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''file_info'', ctx=Store()), annotation=Subscript(value=Name(id=''Dict'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
        ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
        ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0),
        AnnAssign(target=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
        ctx=Store()), annotation=Name(id=''str'', ctx=Load()), value=Constant(value=None),
        simple=0)], decorator_list=[])'
      method_docstring: "\n        Initialize a new instance of the class.\n     \
        \   Args:\n            code: str: The source code.\n        Returns:\n   \
        \         None\n        "
      method_inputs:
      - self
      - code
      method_defaults: []
      method_returns: []
      method_calls: []
      method_call_inputs: {}
      method_variables: []
      method_decorators: []
      method_annotations:
      - Dict[str, Union[str, List[str]]]
      - Dict[str, Dict[str, Union[str, List[str]]]]
      - str
      method_properties:
      - self.file_info
      - self.functions
      - self.current_class
      - self.code
      - self.classes
    class_method_visit_FunctionDef:
      method_name: visit_FunctionDef
      method_code: "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n\
        \    \"\"\"\n        Extract details about a function.\n        Args:\n  \
        \          node: ast.FunctionDef: The node to visit.\n        Returns:\n \
        \           None\n        \"\"\"\n    details = self.extract_details(node,\
        \ 'method' if self.current_class else 'function')\n    if self.current_class:\n\
        \        self.classes[self.current_class][f'class_method_{node.name}'] = details\n\
        \    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)"
      method_ast: 'FunctionDef(name=''visit_FunctionDef'', args=arguments(posonlyargs=[],
        args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''FunctionDef'', ctx=Load()))], kwonlyargs=[], kw_defaults=[],
        defaults=[]), body=[Expr(value=Constant(value=''\n        Extract details
        about a function.\n        Args:\n            node: ast.FunctionDef: The node
        to visit.\n        Returns:\n            None\n        '')), Assign(targets=[Name(id=''details'',
        ctx=Store())], value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()),
        attr=''extract_details'', ctx=Load()), args=[Name(id=''node'', ctx=Load()),
        IfExp(test=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
        ctx=Load()), body=Constant(value=''method''), orelse=Constant(value=''function''))],
        keywords=[])), If(test=Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'',
        ctx=Load()), body=[Assign(targets=[Subscript(value=Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''current_class'', ctx=Load()), ctx=Load()), slice=JoinedStr(values=[Constant(value=''class_method_''),
        FormattedValue(value=Attribute(value=Name(id=''node'', ctx=Load()), attr=''name'',
        ctx=Load()), conversion=-1)]), ctx=Store())], value=Name(id=''details'', ctx=Load()))],
        orelse=[Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''functions'', ctx=Load()), slice=Attribute(value=Name(id=''node'',
        ctx=Load()), attr=''name'', ctx=Load()), ctx=Store())], value=Name(id=''details'',
        ctx=Load()))]), Expr(value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()),
        attr=''generic_visit'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
        keywords=[]))], decorator_list=[], returns=Constant(value=None))'
      method_docstring: "\n        Extract details about a function.\n        Args:\n\
        \            node: ast.FunctionDef: The node to visit.\n        Returns:\n\
        \            None\n        "
      method_inputs:
      - self
      - node
      method_defaults: []
      method_returns: []
      method_calls:
      - self.extract_details
      - self.generic_visit
      method_call_inputs:
        self.extract_details:
        - node
        - '''method'' if self.current_class else ''function'''
        self.generic_visit:
        - node
      method_variables:
      - details
      method_decorators: []
      method_annotations: []
      method_properties: []
    class_method_visit_ClassDef:
      method_name: visit_ClassDef
      method_code: "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\
        \"\n        Extract details about a class.\n        Args:\n            node:\
        \ ast.ClassDef: The node to visit.\n        Returns:\n            None\n \
        \       \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n\
        \    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class\
        \ = None"
      method_ast: 'FunctionDef(name=''visit_ClassDef'', args=arguments(posonlyargs=[],
        args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''ClassDef'', ctx=Load()))], kwonlyargs=[], kw_defaults=[],
        defaults=[]), body=[Expr(value=Constant(value=''\n        Extract details
        about a class.\n        Args:\n            node: ast.ClassDef: The node to
        visit.\n        Returns:\n            None\n        '')), Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''node'',
        ctx=Load()), attr=''name'', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''extract_details'', ctx=Load()), args=[Name(id=''node'',
        ctx=Load()), Constant(value=''class'')], keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''current_class'', ctx=Store())], value=Attribute(value=Name(id=''node'',
        ctx=Load()), attr=''name'', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''generic_visit'', ctx=Load()), args=[Name(id=''node'',
        ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''current_class'', ctx=Store())], value=Constant(value=None))],
        decorator_list=[], returns=Constant(value=None))'
      method_docstring: "\n        Extract details about a class.\n        Args:\n\
        \            node: ast.ClassDef: The node to visit.\n        Returns:\n  \
        \          None\n        "
      method_inputs:
      - self
      - node
      method_defaults: []
      method_returns: []
      method_calls:
      - self.extract_details
      - self.generic_visit
      method_call_inputs:
        self.extract_details:
        - node
        - '''class'''
        self.generic_visit:
        - node
      method_variables: []
      method_decorators: []
      method_annotations: []
      method_properties:
      - self.current_class
    class_method_extract_details:
      method_name: extract_details
      method_code: "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str,\
        \ Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n\
        \        Args:\n            node: ast.AST: The node to extract details from.\n\
        \            node_type: str: The type of node.\n        Returns:\n       \
        \     Dict[str, Union[str, List[str]]]: The details extracted from the node.\n\
        \        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n\
        \    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node),\
        \ f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s\
        \ for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)),\
        \ None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type\
        \ in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d)\
        \ for d in node.args.defaults] if node_type in ['function', 'method'] else\
        \ None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value\
        \ is not None else 'None' for subnode in node_walk if isinstance(subnode,\
        \ ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs':\
        \ call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode\
        \ in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets\
        \ if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator)\
        \ for decorator in node.decorator_list} if node.decorator_list else set()),\
        \ f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode\
        \ in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation\
        \ is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for\
        \ subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx,\
        \ ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type\
        \ == 'method' and self.current_class:\n            attributes = [target.attr\
        \ for subnode in node_walk if isinstance(subnode, ast.Assign) for target in\
        \ subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value,\
        \ ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes',\
        \ []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes':\
        \ [target.attr for subnode in node.body if isinstance(subnode, ast.Assign)\
        \ for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods':\
        \ [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)\
        \ and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base)\
        \ for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name\
        \ for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name\
        \ != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id\
        \ == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return\
        \ details"
      method_ast: 'FunctionDef(name=''extract_details'', args=arguments(posonlyargs=[],
        args=[arg(arg=''self''), arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''AST'', ctx=Load())), arg(arg=''node_type'', annotation=Name(id=''str'',
        ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=''\n        Extract
        details about a node.\n        Args:\n            node: ast.AST: The node
        to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str,
        Union[str, List[str]]]: The details extracted from the node.\n        '')),
        Assign(targets=[Name(id=''node_walk'', ctx=Store())], value=Call(func=Name(id=''list'',
        ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
        attr=''walk'', ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])],
        keywords=[])), Assign(targets=[Name(id=''call_data'', ctx=Store())], value=Call(func=Name(id=''get_all_calls'',
        ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])), Assign(targets=[Name(id=''details'',
        ctx=Store())], value=Dict(keys=[JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_name'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_code'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_ast'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_docstring'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_inputs'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_defaults'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_returns'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_calls'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_call_inputs'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_variables'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_decorators'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_annotations'')]), JoinedStr(values=[FormattedValue(value=Name(id=''node_type'',
        ctx=Load()), conversion=-1), Constant(value=''_properties'')])], values=[Attribute(value=Name(id=''node'',
        ctx=Load()), attr=''name'', ctx=Load()), Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
        keywords=[]), Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''dump'',
        ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[]), Call(func=Name(id=''next'',
        ctx=Load()), args=[GeneratorExp(elt=Attribute(value=Attribute(value=Name(id=''n'',
        ctx=Load()), attr=''value'', ctx=Load()), attr=''s'', ctx=Load()), generators=[comprehension(target=Name(id=''n'',
        ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(),
        values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''n'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Expr'',
        ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'', ctx=Load()),
        args=[Attribute(value=Name(id=''n'', ctx=Load()), attr=''value'', ctx=Load()),
        Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Str'', ctx=Load())],
        keywords=[])])], is_async=0)]), Constant(value=None)], keywords=[]), IfExp(test=Compare(left=Name(id=''node_type'',
        ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''function''),
        Constant(value=''method'')], ctx=Load())]), body=ListComp(elt=Attribute(value=Name(id=''arg'',
        ctx=Load()), attr=''arg'', ctx=Load()), generators=[comprehension(target=Name(id=''arg'',
        ctx=Store()), iter=Attribute(value=Attribute(value=Name(id=''node'', ctx=Load()),
        attr=''args'', ctx=Load()), attr=''args'', ctx=Load()), ifs=[], is_async=0)]),
        orelse=Constant(value=None)), IfExp(test=Compare(left=Name(id=''node_type'',
        ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''function''),
        Constant(value=''method'')], ctx=Load())]), body=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''d'', ctx=Load())],
        keywords=[]), generators=[comprehension(target=Name(id=''d'', ctx=Store()),
        iter=Attribute(value=Attribute(value=Name(id=''node'', ctx=Load()), attr=''args'',
        ctx=Load()), attr=''defaults'', ctx=Load()), ifs=[], is_async=0)]), orelse=Constant(value=None)),
        ListComp(elt=IfExp(test=Compare(left=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''value'', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]),
        body=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()), attr=''unparse'',
        ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''value'',
        ctx=Load())], keywords=[]), orelse=Constant(value=''None'')), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''Return'', ctx=Load())], keywords=[])], is_async=0)]),
        Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Name(id=''call_data'',
        ctx=Load()), attr=''keys'', ctx=Load()), args=[], keywords=[])], keywords=[]),
        Name(id=''call_data'', ctx=Load()), Call(func=Name(id=''list'', ctx=Load()),
        args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
        attr=''unparse'', ctx=Load()), args=[Name(id=''target'', ctx=Load())], keywords=[]),
        generators=[comprehension(target=Name(id=''subnode'', ctx=Store()), iter=Name(id=''node_walk'',
        ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Assign'',
        ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
        ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
        ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''target'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'',
        ctx=Load())], keywords=[])], is_async=0)])], keywords=[]), Call(func=Name(id=''list'',
        ctx=Load()), args=[IfExp(test=Attribute(value=Name(id=''node'', ctx=Load()),
        attr=''decorator_list'', ctx=Load()), body=SetComp(elt=Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''decorator'', ctx=Load())],
        keywords=[]), generators=[comprehension(target=Name(id=''decorator'', ctx=Store()),
        iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''decorator_list'',
        ctx=Load()), ifs=[], is_async=0)]), orelse=Call(func=Name(id=''set'', ctx=Load()),
        args=[], keywords=[]))], keywords=[]), Call(func=Name(id=''list'', ctx=Load()),
        args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
        attr=''unparse'', ctx=Load()), args=[Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''annotation'', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(),
        values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''AnnAssign'',
        ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''annotation'', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)])])],
        is_async=0)])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[SetComp(elt=Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''subnode'', ctx=Load())],
        keywords=[]), generators=[comprehension(target=Name(id=''subnode'', ctx=Store()),
        iter=Name(id=''node_walk'', ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''Attribute'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''ctx'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Store'',
        ctx=Load())], keywords=[])])], is_async=0)])], keywords=[])])), If(test=Compare(left=Name(id=''node_type'',
        ctx=Load()), ops=[In()], comparators=[List(elts=[Constant(value=''class''),
        Constant(value=''method'')], ctx=Load())]), body=[If(test=BoolOp(op=And(),
        values=[Compare(left=Name(id=''node_type'', ctx=Load()), ops=[Eq()], comparators=[Constant(value=''method'')]),
        Attribute(value=Name(id=''self'', ctx=Load()), attr=''current_class'', ctx=Load())]),
        body=[Assign(targets=[Name(id=''attributes'', ctx=Store())], value=ListComp(elt=Attribute(value=Name(id=''target'',
        ctx=Load()), attr=''attr'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''Assign'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
        ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
        ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''target'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''Attribute'', ctx=Load())], keywords=[]), Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Attribute(value=Name(id=''target'', ctx=Load()), attr=''value'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'',
        ctx=Load())], keywords=[]), Compare(left=Attribute(value=Attribute(value=Name(id=''target'',
        ctx=Load()), attr=''value'', ctx=Load()), attr=''id'', ctx=Load()), ops=[Eq()],
        comparators=[Constant(value=''self'')])])], is_async=0)])), Expr(value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''classes'', ctx=Load()), slice=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''current_class'', ctx=Load()), ctx=Load()), attr=''setdefault'',
        ctx=Load()), args=[Constant(value=''class_attributes''), List(elts=[], ctx=Load())],
        keywords=[]), attr=''extend'', ctx=Load()), args=[Name(id=''attributes'',
        ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id=''node_type'',
        ctx=Load()), ops=[Eq()], comparators=[Constant(value=''class'')]), body=[Expr(value=Call(func=Attribute(value=Name(id=''details'',
        ctx=Load()), attr=''update'', ctx=Load()), args=[Dict(keys=[Constant(value=''class_attributes''),
        Constant(value=''class_methods''), Constant(value=''class_inheritance''),
        Constant(value=''class_static_methods'')], values=[ListComp(elt=Attribute(value=Name(id=''target'',
        ctx=Load()), attr=''attr'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'',
        ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''subnode'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Assign'',
        ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''target'',
        ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''targets'',
        ctx=Load()), ifs=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''target'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Attribute'',
        ctx=Load())], keywords=[])], is_async=0)]), ListComp(elt=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'',
        ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''FunctionDef'', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''name'', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=''__init__'')])])],
        is_async=0)]), IfExp(test=Attribute(value=Name(id=''node'', ctx=Load()), attr=''bases'',
        ctx=Load()), body=ListComp(elt=Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''base'', ctx=Load())],
        keywords=[]), generators=[comprehension(target=Name(id=''base'', ctx=Store()),
        iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''bases'', ctx=Load()),
        ifs=[], is_async=0)]), orelse=List(elts=[], ctx=Load())), ListComp(elt=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Attribute(value=Name(id=''node'', ctx=Load()), attr=''body'',
        ctx=Load()), ifs=[BoolOp(op=And(), values=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''FunctionDef'', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''name'', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=''__init__'')]),
        Call(func=Name(id=''any'', ctx=Load()), args=[GeneratorExp(elt=BoolOp(op=And(),
        values=[Call(func=Name(id=''isinstance'', ctx=Load()), args=[Name(id=''decorator'',
        ctx=Load()), Attribute(value=Name(id=''ast'', ctx=Load()), attr=''Name'',
        ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id=''decorator'',
        ctx=Load()), attr=''id'', ctx=Load()), ops=[Eq()], comparators=[Constant(value=''staticmethod'')])]),
        generators=[comprehension(target=Name(id=''decorator'', ctx=Store()), iter=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''decorator_list'', ctx=Load()), ifs=[], is_async=0)])],
        keywords=[])])], is_async=0)])])], keywords=[]))], orelse=[])], orelse=[]),
        Return(value=Name(id=''details'', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id=''Dict'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''Union'',
        ctx=Load()), slice=Tuple(elts=[Name(id=''str'', ctx=Load()), Subscript(value=Name(id=''List'',
        ctx=Load()), slice=Name(id=''str'', ctx=Load()), ctx=Load())], ctx=Load()),
        ctx=Load())], ctx=Load()), ctx=Load()))'
      method_docstring: "\n        Extract details about a node.\n        Args:\n\
        \            node: ast.AST: The node to extract details from.\n          \
        \  node_type: str: The type of node.\n        Returns:\n            Dict[str,\
        \ Union[str, List[str]]]: The details extracted from the node.\n        "
      method_inputs:
      - self
      - node
      - node_type
      method_defaults: []
      method_returns:
      - details
      method_calls:
      - list
      - ast.walk
      - get_all_calls
      - ast.unparse
      - ast.dump
      - next
      - isinstance
      - call_data.keys
      - set
      - self.classes[self.current_class].setdefault('class_attributes', []).extend
      - self.classes[self.current_class].setdefault
      - details.update
      - any
      method_call_inputs:
        list:
        - '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute)
          and isinstance(subnode.ctx, ast.Store)}'
        ast.walk:
        - node
        get_all_calls:
        - node
        ast.unparse:
        - base
        ast.dump:
        - node
        next:
        - (n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value,
          ast.Str))
        - None
        isinstance:
        - decorator
        - ast.Name
        call_data.keys: []
        set: []
        self.classes[self.current_class].setdefault('class_attributes', []).extend:
        - attributes
        self.classes[self.current_class].setdefault:
        - '''class_attributes'''
        - '[]'
        details.update:
        - '{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode,
          ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],
          ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode,
          ast.FunctionDef) and subnode.name != ''__init__''], ''class_inheritance'':
          [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'':
          [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)
          and subnode.name != ''__init__'' and any((isinstance(decorator, ast.Name)
          and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}'
        any:
        - (isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for
          decorator in subnode.decorator_list)
      method_variables:
      - call_data
      - details
      - attributes
      - node_walk
      method_decorators: []
      method_annotations: []
      method_properties: []
    class_method_analyze:
      method_name: analyze
      method_code: "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n      \
        \  Traverse the AST rooted at 'node', create a list of all nodes within the\
        \ current file, and populate 'file_info' with file details\n        Args:\n\
        \            node: ast.AST: The node to analyze.\n        Returns:\n     \
        \       None\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    self.visit(node)\n\
        \    self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node),\
        \ 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode,\
        \ ast.Import) for alias in subnode.names} | {subnode.module for subnode in\
        \ node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()),\
        \ 'file_classes': list(self.classes.keys())}\n    function_defs = [{func_name:\
        \ {'inputs': details['function_inputs'], 'calls': details['function_calls'],\
        \ 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}}\
        \ for func_name, details in self.functions.items()]\n    class_defs = []\n\
        \    for class_name, class_details in self.classes.items():\n        method_defs\
        \ = {}\n        for method_name, details in class_details.items():\n     \
        \       if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]]\
        \ = {'inputs': details['method_inputs'], 'calls': details['method_calls'],\
        \ 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n\
        \        class_defs.append({class_name: {'method_defs': method_defs}})\n \
        \   self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'],\
        \ 'function_defs': function_defs, 'class_defs': class_defs}\n    file_code_simplified\
        \ = remove_docs_and_comments(ast.unparse(node))\n    self.file_info['file_code_simplified']\
        \ = file_code_simplified"
      method_ast: 'FunctionDef(name=''analyze'', args=arguments(posonlyargs=[], args=[arg(arg=''self''),
        arg(arg=''node'', annotation=Attribute(value=Name(id=''ast'', ctx=Load()),
        attr=''AST'', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]),
        body=[Expr(value=Constant(value="\n        Traverse the AST rooted at ''node'',
        create a list of all nodes within the current file, and populate ''file_info''
        with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        ")),
        Assign(targets=[Name(id=''node_walk'', ctx=Store())], value=Call(func=Name(id=''list'',
        ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'', ctx=Load()),
        attr=''walk'', ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])],
        keywords=[])), Expr(value=Call(func=Attribute(value=Name(id=''self'', ctx=Load()),
        attr=''visit'', ctx=Load()), args=[Name(id=''node'', ctx=Load())], keywords=[])),
        Assign(targets=[Attribute(value=Name(id=''self'', ctx=Load()), attr=''file_info'',
        ctx=Store())], value=Dict(keys=[Constant(value=''file_code''), Constant(value=''file_ast''),
        Constant(value=''file_dependencies''), Constant(value=''file_functions''),
        Constant(value=''file_classes'')], values=[Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''code'', ctx=Load()), Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''dump'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
        keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[BinOp(left=SetComp(elt=Attribute(value=Name(id=''alias'',
        ctx=Load()), attr=''name'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''Import'', ctx=Load())], keywords=[])], is_async=0), comprehension(target=Name(id=''alias'',
        ctx=Store()), iter=Attribute(value=Name(id=''subnode'', ctx=Load()), attr=''names'',
        ctx=Load()), ifs=[], is_async=0)]), op=BitOr(), right=SetComp(elt=Attribute(value=Name(id=''subnode'',
        ctx=Load()), attr=''module'', ctx=Load()), generators=[comprehension(target=Name(id=''subnode'',
        ctx=Store()), iter=Name(id=''node_walk'', ctx=Load()), ifs=[Call(func=Name(id=''isinstance'',
        ctx=Load()), args=[Name(id=''subnode'', ctx=Load()), Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''ImportFrom'', ctx=Load())], keywords=[])], is_async=0)]))],
        keywords=[]), Call(func=Name(id=''list'', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''functions'', ctx=Load()), attr=''keys'', ctx=Load()),
        args=[], keywords=[])], keywords=[]), Call(func=Name(id=''list'', ctx=Load()),
        args=[Call(func=Attribute(value=Attribute(value=Name(id=''self'', ctx=Load()),
        attr=''classes'', ctx=Load()), attr=''keys'', ctx=Load()), args=[], keywords=[])],
        keywords=[])])), Assign(targets=[Name(id=''function_defs'', ctx=Store())],
        value=ListComp(elt=Dict(keys=[Name(id=''func_name'', ctx=Load())], values=[Dict(keys=[Constant(value=''inputs''),
        Constant(value=''calls''), Constant(value=''call_inputs''), Constant(value=''returns'')],
        values=[Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_inputs''),
        ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_calls''),
        ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_call_inputs''),
        ctx=Load()), Subscript(value=Name(id=''details'', ctx=Load()), slice=Constant(value=''function_returns''),
        ctx=Load())])]), generators=[comprehension(target=Tuple(elts=[Name(id=''func_name'',
        ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''functions'', ctx=Load()), attr=''items'', ctx=Load()),
        args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id=''class_defs'',
        ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id=''class_name'',
        ctx=Store()), Name(id=''class_details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''classes'', ctx=Load()), attr=''items'', ctx=Load()), args=[],
        keywords=[]), body=[Assign(targets=[Name(id=''method_defs'', ctx=Store())],
        value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id=''method_name'',
        ctx=Store()), Name(id=''details'', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id=''class_details'',
        ctx=Load()), attr=''items'', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id=''method_name'',
        ctx=Load()), attr=''startswith'', ctx=Load()), args=[Constant(value=''class_method_'')],
        keywords=[]), body=[Assign(targets=[Subscript(value=Name(id=''method_defs'',
        ctx=Load()), slice=Subscript(value=Name(id=''method_name'', ctx=Load()), slice=Slice(lower=Call(func=Name(id=''len'',
        ctx=Load()), args=[Constant(value=''class_method_'')], keywords=[])), ctx=Load()),
        ctx=Store())], value=Dict(keys=[Constant(value=''inputs''), Constant(value=''calls''),
        Constant(value=''call_inputs''), Constant(value=''returns'')], values=[Subscript(value=Name(id=''details'',
        ctx=Load()), slice=Constant(value=''method_inputs''), ctx=Load()), Subscript(value=Name(id=''details'',
        ctx=Load()), slice=Constant(value=''method_calls''), ctx=Load()), Subscript(value=Name(id=''details'',
        ctx=Load()), slice=Constant(value=''method_call_inputs''), ctx=Load()), Subscript(value=Name(id=''details'',
        ctx=Load()), slice=Constant(value=''method_returns''), ctx=Load())]))], orelse=[])],
        orelse=[]), Expr(value=Call(func=Attribute(value=Name(id=''class_defs'', ctx=Load()),
        attr=''append'', ctx=Load()), args=[Dict(keys=[Name(id=''class_name'', ctx=Load())],
        values=[Dict(keys=[Constant(value=''method_defs'')], values=[Name(id=''method_defs'',
        ctx=Load())])])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_summary''),
        ctx=Store())], value=Dict(keys=[Constant(value=''dependencies''), Constant(value=''function_defs''),
        Constant(value=''class_defs'')], values=[Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_dependencies''),
        ctx=Load()), Name(id=''function_defs'', ctx=Load()), Name(id=''class_defs'',
        ctx=Load())])), Assign(targets=[Name(id=''file_code_simplified'', ctx=Store())],
        value=Call(func=Name(id=''remove_docs_and_comments'', ctx=Load()), args=[Call(func=Attribute(value=Name(id=''ast'',
        ctx=Load()), attr=''unparse'', ctx=Load()), args=[Name(id=''node'', ctx=Load())],
        keywords=[])], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id=''self'',
        ctx=Load()), attr=''file_info'', ctx=Load()), slice=Constant(value=''file_code_simplified''),
        ctx=Store())], value=Name(id=''file_code_simplified'', ctx=Load()))], decorator_list=[],
        returns=Constant(value=None))'
      method_docstring: "\n        Traverse the AST rooted at 'node', create a list\
        \ of all nodes within the current file, and populate 'file_info' with file\
        \ details\n        Args:\n            node: ast.AST: The node to analyze.\n\
        \        Returns:\n            None\n        "
      method_inputs:
      - self
      - node
      method_defaults: []
      method_returns: []
      method_calls:
      - list
      - ast.walk
      - self.visit
      - ast.dump
      - isinstance
      - self.functions.keys
      - self.classes.keys
      - self.functions.items
      - self.classes.items
      - class_details.items
      - method_name.startswith
      - len
      - class_defs.append
      - remove_docs_and_comments
      - ast.unparse
      method_call_inputs:
        list:
        - self.classes.keys()
        ast.walk:
        - node
        self.visit:
        - node
        ast.dump:
        - node
        isinstance:
        - subnode
        - ast.ImportFrom
        self.functions.keys: []
        self.classes.keys: []
        self.functions.items: []
        self.classes.items: []
        class_details.items: []
        method_name.startswith:
        - '''class_method_'''
        len:
        - '''class_method_'''
        class_defs.append:
        - '{class_name: {''method_defs'': method_defs}}'
        remove_docs_and_comments:
        - ast.unparse(node)
        ast.unparse:
        - node
      method_variables:
      - method_defs
      - function_defs
      - node_walk
      - class_defs
      - file_code_simplified
      method_decorators: []
      method_annotations: []
      method_properties:
      - self.file_info
