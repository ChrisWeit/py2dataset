[
    {
        "instruction": "Dependencies in Python file: `py2dataset.get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Adds code graph and control flow to file details.\n        b. Returns file details.\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]]\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        \"if\": \"If\",\n        \"while\": \"While\",\n        \"for\": \"For\",\n        \"asyncfor\": \"AsyncFor\",\n        \"with\": \"With\",\n        \"asyncwith\": \"AsyncWith\",\n        \"try\": \"Try\",\n        \"except\": \"ExceptHandler\",\n        \"def\": \"FunctionDef\",\n        \"asyncdef\": \"AsyncFunctionDef\",\n        \"class\": \"ClassDef\",\n        \"return\": \"Return\",\n    }\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append(\n                {f\"def {node.name}({args_str})\": extract_control_flow_tree(node.body)}\n            )\n        elif isinstance(node, ast.If):\n            if_block = {\n                f\"if {ast.unparse(node.test)}\": extract_control_flow_tree(node.body)\n            }\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update(\n                    {\n                        f\"elif {ast.unparse(orelse[0].test)}\": extract_control_flow_tree(\n                            orelse[0].body\n                        )\n                    }\n                )\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({\"else\": extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({\"return\": [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append(\n                    {\"return\": []}\n                )  # Handle cases with no return value\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = (\n                    ast.unparse(handler.type) if handler.type is not None else \"\"\n                )\n                handler_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                except_block.append(\n                    {\n                        f\"except {handler_type} as {handler_name}:\": extract_control_flow_tree(\n                            handler.body\n                        )\n                    }\n                )\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append(\n                {\n                    f\"while {ast.unparse(node.test)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.For):\n            control_flow_tree.append(\n                {\n                    f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.With):\n            control_flow_tree.append(\n                {\n                    f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append(\n                {f\"class {node.name}\": extract_control_flow_tree(node.body)}\n            )\n        elif any(\n            isinstance(node, getattr(ast, node_keywords_map[keyword]))\n            for keyword in node_keywords_map.keys()\n        ):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in file_details[\"file_info\"][\"control_flow_structure\"]:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details[\"file_info\"][\"entire_code_graph\"] = code_graph(\n        file_details[\"file_info\"][\"file_summary\"]\n    )\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(\n        file_details[\"file_info\"][\"file_summary\"]\n    ).replace('\"', \"\")\n\n    # file_code_simplified is the code without comments and docstrings\n    try:\n        file_ast = file_details[\"file_info\"][\"file_ast\"]  # Accessing the AST\n        file_details[\"file_info\"][\"control_flow_structure\"] = reorganize_control_flow(\n            file_details[\"file_info\"][\"entire_code_graph\"],\n            extract_control_flow_tree(file_ast.body)  # Using the AST for control flow extraction\n        )\n        file_details[\"file_info\"][\"plantUML\"] = get_plantUML(file_details)\n    except Exception as e:\n        file_details[\"file_info\"][\"control_flow_structure\"] = [str(e)]\n        file_details[\"file_info\"][\"plantUML\"] = str(e)  \n\n    # remove the AST from the file_details\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "Dependencies:json, networkx, typing, ast\n\nPurpose and Significance:\nIn this code snippet, 3 different functions are provided for working with AST(Abstract Syntax Trees).\r\n- The function `code_graph` creates a dictionary representation of file details, where it extracts the function and class method details from the file summary. It then creates a directed graph with nodes and edges representing the relationships in the code.\r\n- The function `extract_control_flow_tree` extracts control flow tree from AST.\r\n- The function `reorganize_control_flow` reorganizes the control flow structure recursively.\r\n- The function `get_plantUML_element` gets plantUML code for each element.\r\n- The function `get_plantUML` gets plantUML code for entire file.\r\n- The function `get_code_graph` adds code graph and control flow to file details. "
    },
    {
        "instruction": "Call code graph in Python file: `py2dataset.get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Adds code graph and control flow to file details.\n        b. Returns file details.\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]]\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        \"if\": \"If\",\n        \"while\": \"While\",\n        \"for\": \"For\",\n        \"asyncfor\": \"AsyncFor\",\n        \"with\": \"With\",\n        \"asyncwith\": \"AsyncWith\",\n        \"try\": \"Try\",\n        \"except\": \"ExceptHandler\",\n        \"def\": \"FunctionDef\",\n        \"asyncdef\": \"AsyncFunctionDef\",\n        \"class\": \"ClassDef\",\n        \"return\": \"Return\",\n    }\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append(\n                {f\"def {node.name}({args_str})\": extract_control_flow_tree(node.body)}\n            )\n        elif isinstance(node, ast.If):\n            if_block = {\n                f\"if {ast.unparse(node.test)}\": extract_control_flow_tree(node.body)\n            }\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update(\n                    {\n                        f\"elif {ast.unparse(orelse[0].test)}\": extract_control_flow_tree(\n                            orelse[0].body\n                        )\n                    }\n                )\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({\"else\": extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({\"return\": [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append(\n                    {\"return\": []}\n                )  # Handle cases with no return value\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = (\n                    ast.unparse(handler.type) if handler.type is not None else \"\"\n                )\n                handler_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                except_block.append(\n                    {\n                        f\"except {handler_type} as {handler_name}:\": extract_control_flow_tree(\n                            handler.body\n                        )\n                    }\n                )\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append(\n                {\n                    f\"while {ast.unparse(node.test)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.For):\n            control_flow_tree.append(\n                {\n                    f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.With):\n            control_flow_tree.append(\n                {\n                    f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append(\n                {f\"class {node.name}\": extract_control_flow_tree(node.body)}\n            )\n        elif any(\n            isinstance(node, getattr(ast, node_keywords_map[keyword]))\n            for keyword in node_keywords_map.keys()\n        ):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in file_details[\"file_info\"][\"control_flow_structure\"]:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details[\"file_info\"][\"entire_code_graph\"] = code_graph(\n        file_details[\"file_info\"][\"file_summary\"]\n    )\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(\n        file_details[\"file_info\"][\"file_summary\"]\n    ).replace('\"', \"\")\n\n    # file_code_simplified is the code without comments and docstrings\n    try:\n        file_ast = file_details[\"file_info\"][\"file_ast\"]  # Accessing the AST\n        file_details[\"file_info\"][\"control_flow_structure\"] = reorganize_control_flow(\n            file_details[\"file_info\"][\"entire_code_graph\"],\n            extract_control_flow_tree(file_ast.body)  # Using the AST for control flow extraction\n        )\n        file_details[\"file_info\"][\"plantUML\"] = get_plantUML(file_details)\n    except Exception as e:\n        file_details[\"file_info\"][\"control_flow_structure\"] = [str(e)]\n        file_details[\"file_info\"][\"plantUML\"] = str(e)  \n\n    # remove the AST from the file_details\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "{'nodes': ['code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'extract_control_flow_tree', 'reorganize_control_flow', 'reorganize_structure', 'get_plantUML_element', 'get_plantUML', 'get_code_graph', 'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', \"class_details['method_defs'].items\", 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'function_details_lookup.items', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'nodes_to_remove.append', 'isinstance', \"', '.join\", 'ast.unparse', 'control_flow_tree.append', 'if_block.update', 'except_block.append', 'any', 'getattr', 'node_keywords_map.keys', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend', 'key.startswith', \"json.dumps(file_details['file_info']['file_summary']).replace\", 'str'], 'edges': [{'source': 'code_graph', 'target': 'nx.DiGraph', 'target_inputs': []}, {'source': 'code_graph', 'target': 'function_details_lookup.update', 'target_inputs': ['function_def']}, {'source': 'code_graph', 'target': 'class_def.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_node', 'target_inputs': ['class_name', 'qualified_method_name', 'called', 'function_name']}, {'source': 'code_graph', 'target': \"class_details['method_defs'].items\", 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_edge', 'target_inputs': ['class_name', 'qualified_method_name', 'source', 'target']}, {'source': 'code_graph', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'code_graph', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\", 'class_def.keys()', 'G.nodes']}, {'source': 'code_graph', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'code_graph', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target', 'target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'code_graph', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'code_graph', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'code_graph', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'code_graph', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'code_graph', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'code_graph', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'code_graph', 'target': 'function_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'add_edges_for_calls', 'target_inputs': ['func_name', \"details['calls']\", 'qualified_method_name', \"details['calls']\"], 'target_returns': []}, {'source': 'code_graph', 'target': 'class_method_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G[source][target].update', 'target_inputs': ['edge_data']}, {'source': 'code_graph', 'target': 'G.edges.data', 'target_inputs': []}, {'source': 'code_graph', 'target': 'nodes_to_remove.append', 'target_inputs': ['node']}, {'source': 'get_edge_data_from_details', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'get_edge_data_from_details', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\"]}, {'source': 'get_edge_data_from_details', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'add_edge_with_data', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source']}, {'source': 'add_edge_with_data', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source']}, {'source': 'add_edge_with_data', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'add_edge_with_data', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'add_edges_for_calls', 'target': 'list', 'target_inputs': ['class_def.keys()']}, {'source': 'add_edges_for_calls', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'add_edges_for_calls', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'add_edges_for_calls', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'add_edges_for_calls', 'target': 'G.add_node', 'target_inputs': ['called']}, {'source': 'extract_control_flow_tree', 'target': 'isinstance', 'target_inputs': ['node', '(ast.FunctionDef, ast.AsyncFunctionDef)', 'node', 'ast.If', 'orelse[0]', 'ast.If', 'node', 'ast.Return', 'node', 'ast.Try', 'handler.name', 'ast.Name', 'node', 'ast.While', 'node', 'ast.For', 'node', 'ast.With', 'node', 'ast.ClassDef', 'node', 'getattr(ast, node_keywords_map[keyword])']}, {'source': 'extract_control_flow_tree', 'target': \"', '.join\", 'target_inputs': ['[ast.unparse(arg) for arg in node.args.args]', '[ast.unparse(item) for item in node.items]']}, {'source': 'extract_control_flow_tree', 'target': 'ast.unparse', 'target_inputs': ['arg', 'node.test', 'orelse[0].test', 'node.value', 'handler.type', 'handler.name', 'node.test', 'node.target', 'node.iter', 'item', 'node', 'node']}, {'source': 'extract_control_flow_tree', 'target': 'control_flow_tree.append', 'target_inputs': [\"{f'def {node.name}({args_str})': extract_control_flow_tree(node.body)}\", 'if_block', \"{'return': [ast.unparse(node.value)]}\", \"{'return': []}\", 'control_flow_dict', \"{f'while {ast.unparse(node.test)}': extract_control_flow_tree(node.body)}\", \"{f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}': extract_control_flow_tree(node.body)}\", '{f\"with {\\', \\'.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(node.body)}', \"{f'class {node.name}': extract_control_flow_tree(node.body)}\", '{ast.unparse(node): []}', 'ast.unparse(node)']}, {'source': 'extract_control_flow_tree', 'target': 'extract_control_flow_tree', 'target_inputs': ['node.body', 'node.body', 'orelse[0].body', 'orelse', 'node.body', 'handler.body', 'node.orelse', 'node.finalbody', 'node.body', 'node.body', 'node.body', 'node.body'], 'target_returns': ['control_flow_tree']}, {'source': 'extract_control_flow_tree', 'target': 'if_block.update', 'target_inputs': [\"{f'elif {ast.unparse(orelse[0].test)}': extract_control_flow_tree(orelse[0].body)}\", \"{'else': extract_control_flow_tree(orelse)}\"]}, {'source': 'extract_control_flow_tree', 'target': 'except_block.append', 'target_inputs': [\"{f'except {handler_type} as {handler_name}:': extract_control_flow_tree(handler.body)}\"]}, {'source': 'extract_control_flow_tree', 'target': 'any', 'target_inputs': ['(isinstance(node, getattr(ast, node_keywords_map[keyword])) for keyword in node_keywords_map.keys())']}, {'source': 'extract_control_flow_tree', 'target': 'getattr', 'target_inputs': ['ast', 'node_keywords_map[keyword]']}, {'source': 'extract_control_flow_tree', 'target': 'node_keywords_map.keys', 'target_inputs': []}, {'source': 'reorganize_control_flow', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_control_flow', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_control_flow', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_control_flow', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_control_flow', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_control_flow', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_control_flow', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_control_flow', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'reorganize_control_flow', 'target': 'reorganize_structure', 'target_inputs': ['control_flow_structure', 'starting_points'], 'target_returns': ['organized']}, {'source': 'reorganize_structure', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_structure', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_structure', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_structure', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_structure', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_structure', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_structure', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_structure', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'get_plantUML_element', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'value', 'list', 'element', 'str']}, {'source': 'get_plantUML_element', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'get_plantUML_element', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'get_plantUML_element', 'target': 'key.startswith', 'target_inputs': [\"'def '\", \"'class '\", \"'if '\", \"'for '\", \"'while '\", \"'asyncfor '\", \"'try '\", \"'except '\", \"'def '\", \"'class '\", \"'if '\", \"'for '\", \"'while '\", \"'asyncfor '\", \"'try '\", \"'except '\"]}, {'source': 'get_plantUML_element', 'target': 'get_plantUML_element', 'target_inputs': ['child', 'inner_indentation'], 'target_returns': ['plantuml_str']}, {'source': 'get_plantUML', 'target': 'get_plantUML_element', 'target_inputs': ['element', \"'  '\"], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'code_graph', 'target_inputs': [\"file_details['file_info']['file_summary']\"], 'target_returns': ['edge_data', \"{'nodes': nodes, 'edges': edges}\"]}, {'source': 'get_code_graph', 'target': \"json.dumps(file_details['file_info']['file_summary']).replace\", 'target_inputs': ['\\'\"\\'', \"''\"]}, {'source': 'get_code_graph', 'target': 'json.dumps', 'target_inputs': [\"file_details['file_info']['file_summary']\"]}, {'source': 'get_code_graph', 'target': 'reorganize_control_flow', 'target_inputs': [\"file_details['file_info']['entire_code_graph']\", 'extract_control_flow_tree(file_ast.body)'], 'target_returns': ['reorganize_structure(control_flow_structure, starting_points)', 'organized']}, {'source': 'get_code_graph', 'target': 'extract_control_flow_tree', 'target_inputs': ['file_ast.body'], 'target_returns': ['control_flow_tree']}, {'source': 'get_code_graph', 'target': 'get_plantUML', 'target_inputs': ['file_details'], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'str', 'target_inputs': ['e', 'e']}]}"
    },
    {
        "instruction": "Functions defined in Python file: `py2dataset.get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Adds code graph and control flow to file details.\n        b. Returns file details.\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]]\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        \"if\": \"If\",\n        \"while\": \"While\",\n        \"for\": \"For\",\n        \"asyncfor\": \"AsyncFor\",\n        \"with\": \"With\",\n        \"asyncwith\": \"AsyncWith\",\n        \"try\": \"Try\",\n        \"except\": \"ExceptHandler\",\n        \"def\": \"FunctionDef\",\n        \"asyncdef\": \"AsyncFunctionDef\",\n        \"class\": \"ClassDef\",\n        \"return\": \"Return\",\n    }\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append(\n                {f\"def {node.name}({args_str})\": extract_control_flow_tree(node.body)}\n            )\n        elif isinstance(node, ast.If):\n            if_block = {\n                f\"if {ast.unparse(node.test)}\": extract_control_flow_tree(node.body)\n            }\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update(\n                    {\n                        f\"elif {ast.unparse(orelse[0].test)}\": extract_control_flow_tree(\n                            orelse[0].body\n                        )\n                    }\n                )\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({\"else\": extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({\"return\": [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append(\n                    {\"return\": []}\n                )  # Handle cases with no return value\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = (\n                    ast.unparse(handler.type) if handler.type is not None else \"\"\n                )\n                handler_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                except_block.append(\n                    {\n                        f\"except {handler_type} as {handler_name}:\": extract_control_flow_tree(\n                            handler.body\n                        )\n                    }\n                )\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append(\n                {\n                    f\"while {ast.unparse(node.test)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.For):\n            control_flow_tree.append(\n                {\n                    f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.With):\n            control_flow_tree.append(\n                {\n                    f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append(\n                {f\"class {node.name}\": extract_control_flow_tree(node.body)}\n            )\n        elif any(\n            isinstance(node, getattr(ast, node_keywords_map[keyword]))\n            for keyword in node_keywords_map.keys()\n        ):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in file_details[\"file_info\"][\"control_flow_structure\"]:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details[\"file_info\"][\"entire_code_graph\"] = code_graph(\n        file_details[\"file_info\"][\"file_summary\"]\n    )\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(\n        file_details[\"file_info\"][\"file_summary\"]\n    ).replace('\"', \"\")\n\n    # file_code_simplified is the code without comments and docstrings\n    try:\n        file_ast = file_details[\"file_info\"][\"file_ast\"]  # Accessing the AST\n        file_details[\"file_info\"][\"control_flow_structure\"] = reorganize_control_flow(\n            file_details[\"file_info\"][\"entire_code_graph\"],\n            extract_control_flow_tree(file_ast.body)  # Using the AST for control flow extraction\n        )\n        file_details[\"file_info\"][\"plantUML\"] = get_plantUML(file_details)\n    except Exception as e:\n        file_details[\"file_info\"][\"control_flow_structure\"] = [str(e)]\n        file_details[\"file_info\"][\"plantUML\"] = str(e)  \n\n    # remove the AST from the file_details\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "Functions defined:code_graph, get_edge_data_from_details, add_edge_with_data, add_edges_for_calls, extract_control_flow_tree, reorganize_control_flow, reorganize_structure, get_plantUML_element, get_plantUML, get_code_graph\n\nPurpose and Significance:\nThe purpose of each object is as follows:\r\n\n1. `code_graph`: This function takes the file summary and creates a dictionary representation of the code graph by extracting function and class method details from the file, creating nodes and edges representing the relationships in the code, adding edge data to the edges, and returning a dictionary with nodes and edges.\r\n2. `extract_control_flow_tree`: This function takes AST nodes as input and returns the control flow tree of the given code snippet. It is used to extract control flow tree from the AST for further processing in the reorganize_control_flow function.\r\n3. `reorganize_control_flow`: This function reorganizes the control flow structure based on the order of the nodes in the code graph. The starting points are obtained from the code graph and the function is called recursively to create a new control flow tree that matches the order of the code graph.\r\n4. `get_plantUML_element`: This function takes an element as input and generates the corresponding plantUML syntax for each node/element based on its type, be it function or class definitions, conditional statements like if, loops etc., calls and return statements. The `get_plantUML` function is called to generate a complete PlantUML diagram.\r\n5. `get_code_graph`: This function takes the file details as input and adds code graph and control flow information to it. It also removes any nodes that are not sources or targets of an edge from the graph before generating the plantUML code using `get_plantUML` function.\r\n\nThe significance of these objects is as follows:\r\n\n1. `code_graph`: This function generates a dictionary representation of the code graph, which can be used to visualize the relationships between different functions and class methods in the file. It helps in identifying dependencies between them and also shows the inputs/outputs passed between them.\r\n2. `extract_control_flow_tree`: This function extracts the control flow tree from AST nodes. The extracted control flow tree is used to reorganize the structure based on the order of execution in the code graph.\r\n3. `reorganize_control_flow`: This function reorganizes the control flow structure by matching it with the order of execution of the code graph, which makes it easier for users to understand the program flow.\r\n4. `get_plantUML_element`: This function generates PlantUML syntax for each element in the control flow tree based on its type and adds it to the plantUML string that will be generated later.\r\n5. `get_code_graph`: This function is used to generate a complete PlantUML diagram by adding code graph and control flow information to the file details, which helps in visualizing the program flow more clearly. "
    },
    {
        "instruction": "Inputs to `code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}",
        "output": "Inputs to `code_graph`:file_summary\n\nPurpose and Significance:\nThe `file_summary` input parameter is a dictionary containing details extracted from the Python source code. It contains information about function definitions, class definitions, and calls made within the file. The `code_graph` function creates a directed graph representation of these relationships using NetworkX library. The nodes in this graph represent functions, classes, and methods, while edges represent function and method calls. The edge data includes inputs passed to the called function or method and any return values that are used as input for other functions or methods. "
    },
    {
        "instruction": "Inputs to `get_edge_data_from_details` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "Inputs to `get_edge_data_from_details`:target_details, source_details, target\n\nPurpose and Significance:\nThe function `code_graph` takes in a dictionary containing information about functions, classes, and their methods, as well as the calls made within each of them. It then creates a directed graph using NetworkX where nodes represent these elements and edges represent the relationships between them (e.g., one function calling another). The `get_edge_data_from_details` helper function is used to extract information about an edge, such as inputs or returns, based on the details of the target node and source node. It takes in three arguments: 'target_details' represents the details for a specific target node, 'source_details' represents the details for the calling node (either a function or method), and 'target' is simply the name of the target node.\r\n\nThe `extract_control_flow_tree` function takes in a list of AST nodes and recursively extracts information about control flow structures such as if-else statements, loops, and try-except blocks. It returns a dictionary that represents the structure of these control flow statements.\r\n\nThe `reorganize_control_flow` function takes in the code graph and the extracted control flow tree and reorganizes it to match the order of nodes in the graph. It starts by finding the starting points of the graph (i.e., functions or methods that are not called by any other elements), then recursively adds elements to a list based on their call hierarchy.\r\n\nThe `get_plantUML_element` function takes in an element from the reorganized control flow structure and returns its PlantUML representation, including indentation for nested structures. It also handles different types of statements such as functions, classes, loops, and if-else blocks.\r\n\nFinally, the `get_plantUML` function takes in the file details dictionary (which contains information about the code graph, control flow structure, and source code), creates a PlantUML string from these elements, and returns it. The resulting plantUML string can be used to generate an image or text diagram of the Python code using a tool like `plantuml-cli`.\r\n\nThe `get_code_graph` function is the main function that combines all of these components into one step. It first creates the code graph, then extracts and reorganizes the control flow tree from the AST nodes. Finally, it generates a PlantUML string for the entire file using the `get_plantUML` function.\r\n\nNote that `get_code_graph` removes the 'file_ast' attribute of the dictionary as it is no longer needed and could be potentially large and cumbersome to store. "
    },
    {
        "instruction": "Inputs to `add_edge_with_data` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))",
        "output": "Inputs to `add_edge_with_data`:source, target, init_method\n\nPurpose and Significance:\nThe `add_edge_with_data` function is a helper function that adds an edge between two nodes in the graph with data. It takes three arguments - `source`, `target`, and `init_method`. The `init_method` argument is optional, and it represents the method name of the class being called. If the `init_method` is not provided, then the function assumes that the target node is a function or a class method. "
    },
    {
        "instruction": "Inputs to `add_edges_for_calls` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)",
        "output": "Inputs to `add_edges_for_calls`:source_name, calls\n\nPurpose and Significance:\nThe function `code_graph()` creates a dictionary representation of file details. The function `extract_control_flow_tree()` extracts control flow tree from AST. The function `reorganize_control_flow()` reorganizes the control flow structure recursively. The function `get_plantUML_element()` gets plantUML code for each element and `get_plantUML()` gets plantUML code for entire file. Finally, the function `get_code_graph()` adds code graph and control flow to file details.\r\n\nThe input parameter 'source_name' is used in the helper function `add_edges_for_calls` which is called by `code_graph()`. It represents the name of the source node, i.e., the current function or class method being processed. The input parameter 'calls' is a list of all the functions and methods that are called from within this function or class method. "
    },
    {
        "instruction": "Inputs to `extract_control_flow_tree` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {'if': 'If', 'while': 'While', 'for': 'For', 'asyncfor': 'AsyncFor', 'with': 'With', 'asyncwith': 'AsyncWith', 'try': 'Try', 'except': 'ExceptHandler', 'def': 'FunctionDef', 'asyncdef': 'AsyncFunctionDef', 'class': 'ClassDef', 'return': 'Return'}\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append({f'def {node.name}({args_str})': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.If):\n            if_block = {f'if {ast.unparse(node.test)}': extract_control_flow_tree(node.body)}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update({f'elif {ast.unparse(orelse[0].test)}': extract_control_flow_tree(orelse[0].body)})\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({'else': extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({'return': [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append({'return': []})\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = ast.unparse(handler.type) if handler.type is not None else ''\n                handler_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                except_block.append({f'except {handler_type} as {handler_name}:': extract_control_flow_tree(handler.body)})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append({f'while {ast.unparse(node.test)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.For):\n            control_flow_tree.append({f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.With):\n            control_flow_tree.append({f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append({f'class {node.name}': extract_control_flow_tree(node.body)})\n        elif any((isinstance(node, getattr(ast, node_keywords_map[keyword])) for keyword in node_keywords_map.keys())):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree",
        "output": "Inputs to `extract_control_flow_tree`:nodes\n\nPurpose and Significance:\nThe input to `extract_control_flow_tree` is a list of AST nodes. The function recursively traverses through each node in the list and extracts the control flow structure, building it as a tree. \r\n\n`'reorganize_control_flow` function reorganizes the extracted control flow based on the order in which functions/classes are called from top to bottom. This helps visualize the order of execution and is necessary for creating a plantUML diagram. It returns the reorganized structure.\r\n\n`get_plantUML_element` function takes an element as input, recursively generates PlantUML code for that element, and adds it to the `plantuml_str`. It uses indentation levels to maintain the hierarchy of the elements in the control flow. \r\n\nThe 'get_plantUML' function generates plantUML code for entire file by iterating through each element in the reorganized control flow structure.\r\n\n`get_code_graph` function adds the code graph and control flow to the file details, then removes the AST from the file_details dictionary. Finally, it returns the updated `file_details`. "
    },
    {
        "instruction": "Inputs to `reorganize_control_flow` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)",
        "output": "Inputs to `reorganize_control_flow`:code_graph, control_flow_structure\n\nPurpose and Significance:\nThe purpose of the code is to generate a PlantUML diagram from a Python file. The input parameters are a dictionary containing the details of the Python file (i.e., function and class method definitions) and an AST object representing the code structure. The `code_graph` function creates a directed graph representation of the relationships between functions, classes, methods, and calls. It extracts these elements from the provided input data using AST. Then, the `extract_control_flow_tree` function constructs the control flow tree based on the AST nodes. The `reorganize_control_flow` function reorganizes the control flow structure to match the code graph and returns a list of dictionaries representing the file's structure. Finally, the `get_plantUML_element` function generates PlantUML code for each element in the reorganized control flow structure, and the `get_plantUML` function combines these elements into a complete PlantUML diagram. The `get_code_graph` function adds this generated PlantUML string to the `file_details` dictionary with additional metadata related to the file structure such as node count and edge counts. This updated file details object is returned from `get_code_graph`. "
    },
    {
        "instruction": "Inputs to `reorganize_structure` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized",
        "output": "Inputs to `reorganize_structure`:structure, start_points\n\nPurpose and Significance:\nThe inputs to reorganize_structure function are two arguments `structure` and `start_points`. "
    },
    {
        "instruction": "Inputs to `get_plantUML_element` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str",
        "output": "Inputs to `get_plantUML_element`:element, indentation\n\nPurpose and Significance:\nThe purpose of `get_plantUML_element()` is to get Plant UML code for each element. The signature takes in an `element`, which represents either a dictionary or string. Depending on the type, it adds specific keywords before the inner content (for instance, class and function definitions start with `class` or `def`) and also adjusts the indentation level by adding 2 spaces to the current level of indentation (`inner_indentation`). The `get_plantUML()` function then uses this helper function to create a Plant UML representation of the entire file. "
    },
    {
        "instruction": "Inputs to `get_plantUML` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in file_details['file_info']['control_flow_structure']:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str",
        "output": "Inputs to `get_plantUML`:file_details\n\nPurpose and Significance:\nThe purpose of the function is to create a plantUML diagram from a given input of `file_details`. It extracts information such as functions, class methods, and their relationships using the `code_graph` function. Then it creates a control flow tree using the `extract_control_flow_tree` function and reorganizes it according to the `reorganize_control_flow` function before getting PlantUML code using `get_plantUML`. The final result is returned in `file_details[\"file_info\"][\"plantUML\"]`. "
    },
    {
        "instruction": "Inputs to `get_code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    try:\n        file_ast = file_details['file_info']['file_ast']\n        file_details['file_info']['control_flow_structure'] = reorganize_control_flow(file_details['file_info']['entire_code_graph'], extract_control_flow_tree(file_ast.body))\n        file_details['file_info']['plantUML'] = get_plantUML(file_details)\n    except Exception as e:\n        file_details['file_info']['control_flow_structure'] = [str(e)]\n        file_details['file_info']['plantUML'] = str(e)\n    del file_details['file_info']['file_ast']\n    return file_details",
        "output": "Inputs to `get_code_graph`:file_details\n\nPurpose and Significance:\nThe `get_code_graph` function takes in a dictionary called `file_summary`, which contains information about the file's functions, classes, and their relationships. It then creates a directed graph using NetworkX library to represent these relationships as nodes and edges between them. The function also extracts control flow tree from AST and reorganizes it based on the code graph created earlier. Finally, it adds plantUML-specific code to represent each node in the code. \r\n\nHere are some more details about each object within this code snippet: "
    },
    {
        "instruction": "Docstring of `code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}",
        "output": "Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code."
    },
    {
        "instruction": "Docstring of `extract_control_flow_tree` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {'if': 'If', 'while': 'While', 'for': 'For', 'asyncfor': 'AsyncFor', 'with': 'With', 'asyncwith': 'AsyncWith', 'try': 'Try', 'except': 'ExceptHandler', 'def': 'FunctionDef', 'asyncdef': 'AsyncFunctionDef', 'class': 'ClassDef', 'return': 'Return'}\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append({f'def {node.name}({args_str})': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.If):\n            if_block = {f'if {ast.unparse(node.test)}': extract_control_flow_tree(node.body)}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update({f'elif {ast.unparse(orelse[0].test)}': extract_control_flow_tree(orelse[0].body)})\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({'else': extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({'return': [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append({'return': []})\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = ast.unparse(handler.type) if handler.type is not None else ''\n                handler_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                except_block.append({f'except {handler_type} as {handler_name}:': extract_control_flow_tree(handler.body)})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append({f'while {ast.unparse(node.test)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.For):\n            control_flow_tree.append({f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.With):\n            control_flow_tree.append({f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append({f'class {node.name}': extract_control_flow_tree(node.body)})\n        elif any((isinstance(node, getattr(ast, node_keywords_map[keyword])) for keyword in node_keywords_map.keys())):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree",
        "output": "Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree"
    },
    {
        "instruction": "Docstring of `reorganize_control_flow` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)",
        "output": "Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure"
    },
    {
        "instruction": "Docstring of `get_plantUML_element` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str",
        "output": "Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element"
    },
    {
        "instruction": "Docstring of `get_plantUML` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in file_details['file_info']['control_flow_structure']:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str",
        "output": "Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file"
    },
    {
        "instruction": "Docstring of `get_code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    try:\n        file_ast = file_details['file_info']['file_ast']\n        file_details['file_info']['control_flow_structure'] = reorganize_control_flow(file_details['file_info']['entire_code_graph'], extract_control_flow_tree(file_ast.body))\n        file_details['file_info']['plantUML'] = get_plantUML(file_details)\n    except Exception as e:\n        file_details['file_info']['control_flow_structure'] = [str(e)]\n        file_details['file_info']['plantUML'] = str(e)\n    del file_details['file_info']['file_ast']\n    return file_details",
        "output": "Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details"
    },
    {
        "instruction": "Calls made in `code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}",
        "output": "Calls made in `code_graph`:nx.DiGraph, function_details_lookup.update, class_def.items, G.add_node, class_details['method_defs'].items, G.add_edge, target_details.get, list, set, class_method_details_lookup.get, function_details_lookup.get, get_edge_data_from_details, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, function_details_lookup.items, add_edges_for_calls, class_method_details_lookup.items, G[source][target].update, G.edges.data, nodes_to_remove.append\n\nPurpose and Significance:\nThis is not the right code as there are a number of undefined variables. Could you provide more details such as which variable and their respective data type in `get_code_graph()`? The same for other functions? This would help us better understand your purpose. "
    },
    {
        "instruction": "Calls made in `get_edge_data_from_details` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "Calls made in `get_edge_data_from_details`:target_details.get, list, set\n\nPurpose and Significance:\nThe function `get_edge_data_from_details` is a helper function that extracts edge data from target details and source details. It returns a dictionary with the following keys: \"target_inputs\" and \"target_returns\". The value of \"target_inputs\" is the list of inputs to the target node, and the value of \"target_returns\" is a set of return values from the target node. If there are no inputs or returns, it will be an empty list or set, respectively.\r\n\nThe function `add_edge_with_data` adds edges for function or class method calls. It takes in two arguments: source and target, and an optional argument init_method which is used when the target node represents a class method call. The function checks if the target node exists in either the function lookup table (stores all extracted functions from file) or class methods lookup table. If so, it updates edge data to match and then adds that node to the graph using `G.add_edge(source, target, **edge_data)`. Otherwise, it creates a new node with no inputs/returns data and adds an edge.\r\n\nThe function `extract_control_flow_tree` is used to extract control flow tree from AST nodes. It iterates through each node in the AST and checks if it's one of the following types: FunctionDef, AsyncFunctionDef, If, Return, Try, While, For, With, or ClassDef. If any of these conditions are met, it calls itself recursively to extract the child control flow nodes from that particular node type. If a node is an `ast.Return` and has a value attribute (meaning there was something returned), then it will be appended with an empty string since there is no specific input. If the node is not in any of these categories, it's converted to a string using `ast.unparse(node)`. This allows us to generate a dictionary that matches our control flow structure.\r\n\nThe function `reorganize_control_flow` takes in the code graph and control flow structure and reorganizes the control flow structure to match the nodes found in the graph by recursively looping through starting points until they have all been found. \r\n\nFinally, there's the function `get_plantUML_element` which generates PlantUML code for each element in the control flow structure. It takes an indentation level as a parameter and checks if the element is a dictionary or string. If it's a dictionary, it extracts the first key (which will be something like \"def function_name\" or \"class ClassName\") and then loops through its value to generate PlantUML code for each child element. If it's a string, it generates PlantUML syntax based on the keyword (i.e., `function_name();`, `:If (condition){}`)\r\n\nThe function `get_plantUML` takes in file details and loops through the control flow structure to generate PlantUML code for each element.\r\n\nThe function `get_code_graph` is the main function that calls all of these helper functions and adds the entire code graph, reorganized control flow structure, and plantUML code to the file details dictionary. It also removes the AST from the file details since it's not needed anymore. "
    },
    {
        "instruction": "Calls made in `add_edge_with_data` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))",
        "output": "Calls made in `add_edge_with_data`:class_method_details_lookup.get, function_details_lookup.get, G.add_edge, get_edge_data_from_details\n\nPurpose and Significance:\nThe purpose of these objects within the code is to create a directed graph representation of the relationships between functions and class methods in the file, add edges for function and class method calls, and extract control flow tree from AST. The significance of these objects are as follows:\r\n\n1. `class_method_details_lookup.get` - This is used to get the details of a class method based on its fully qualified name.\r\n2. `function_details_lookup.get` - This is used to get the details of a function based on its name.\r\n3. `G.add_edge` - This is used to add an edge between two nodes in the graph with the given data.\r\n4. `get_edge_data_from_details` - This is used to extract the input and return values from a function/method called and stores it in an object representing that specific edge for visualization later.\r\n\nAll these are implemented using networkx which allows easy management of nodes and edges in a graph. "
    },
    {
        "instruction": "Calls made in `add_edges_for_calls` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)",
        "output": "Calls made in `add_edges_for_calls`:list, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, G.add_node\n\nPurpose and Significance:\nThe purpose of the code is to create a dictionary representation of file details and extract control flow tree from AST nodes. It uses `networkx` library for graph manipulation and `ast` library for parsing Python code. "
    },
    {
        "instruction": "Calls made in `extract_control_flow_tree` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {'if': 'If', 'while': 'While', 'for': 'For', 'asyncfor': 'AsyncFor', 'with': 'With', 'asyncwith': 'AsyncWith', 'try': 'Try', 'except': 'ExceptHandler', 'def': 'FunctionDef', 'asyncdef': 'AsyncFunctionDef', 'class': 'ClassDef', 'return': 'Return'}\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append({f'def {node.name}({args_str})': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.If):\n            if_block = {f'if {ast.unparse(node.test)}': extract_control_flow_tree(node.body)}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update({f'elif {ast.unparse(orelse[0].test)}': extract_control_flow_tree(orelse[0].body)})\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({'else': extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({'return': [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append({'return': []})\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = ast.unparse(handler.type) if handler.type is not None else ''\n                handler_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                except_block.append({f'except {handler_type} as {handler_name}:': extract_control_flow_tree(handler.body)})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append({f'while {ast.unparse(node.test)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.For):\n            control_flow_tree.append({f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.With):\n            control_flow_tree.append({f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append({f'class {node.name}': extract_control_flow_tree(node.body)})\n        elif any((isinstance(node, getattr(ast, node_keywords_map[keyword])) for keyword in node_keywords_map.keys())):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree",
        "output": "Calls made in `extract_control_flow_tree`:isinstance, , .join, ast.unparse, control_flow_tree.append, extract_control_flow_tree, if_block.update, except_block.append, any, getattr, node_keywords_map.keys\n\nPurpose and Significance:\nThe purpose of these objects within the code is to perform the following tasks:\r\n1. `isinstance`: It checks whether an object belongs to a specified type or not.\r\n2. `ast.unparse` function returns the string representation of Python code equivalent to given AST node. In the code_graph() and reorganize_control_flow(), it is used for unparsing an ast object like a string expression to represent that AST object in a readable format.\r\n3. `.join`: It joins all elements of an iterable into a single string, with a specified separator between them.\r\n4. `control_flow_tree.append` function adds the given element to the end of the list.\r\n5. `extract_control_flow_tree` function is used for extracting control flow tree from AST nodes and returning it as a dictionary in the format required by the reorganize_control_flow() function.\r\n6. `if_block.update`: It updates the if block with the else or except block of the try-except statement.\r\n7. `except_block.append` appends each element from try statement into except blocks to generate an entire exception structure recursively\r\n8. `getattr(object, 'method')` gets and calls the attribute of object by its name. In this case, it is used to get the keywords for node types like if, while, for etc.\r\n9. `node_keywords_map` dictionary maps each keyword to its respective ast type, which helps in creating a key-value pair in the control flow tree. \r\n\nOverall, these objects are used to extract and manipulate the AST nodes and create a control flow tree for the given Python file. "
    },
    {
        "instruction": "Calls made in `reorganize_control_flow` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)",
        "output": "Calls made in `reorganize_control_flow`:set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend, reorganize_structure\n\nPurpose and Significance:\nThe purpose and significance of these objects within the code are as follows:\r\n- set: used to store the unique elements in `seen` to keep track of what elements have been appended already in `reorganize_structure()` function.\r\n- isinstance(): it's a built-in Python function that returns True if the object is an instance of the specified class, otherwise False. It's used to check whether an element is a dictionary or not.\r\n- next() function: is a built-in function that retrieves the first value of an iterable.\r\n- iter(): Returns an iterator object for a sequence or collection. It's used to iterate over each key in `element` dictionary.\r\n- json.dumps(): Converts a Python object into a JSON formatted string.\r\n- organized.append() and seen.add(): Used to append elements to the `organized` list and add them to the `seen` set respectively, to avoid appending duplicate values in `organized` list.\r\n- reorganize_structure(): This function is a recursive function that sorts the control flow tree based on the starting points of the code graph. It's called recursively until all elements are sorted and added to the `organized` list. "
    },
    {
        "instruction": "Calls made in `reorganize_structure` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized",
        "output": "Calls made in `reorganize_structure`:set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend\n\nPurpose and Significance:\nThe purpose of this object is to keep track of all the function calls and class methods that are made within a file. It is used in the `reorganize_control_flow` function to reorganize the control flow structure based on the code graph created by the `code_graph` function. The significance of these objects is that they help with managing the data structures used in the `reorganize_structure` function, such as keeping track of seen nodes and organizing them accordingly using the starting points extracted from the code graph.\r\n\nAdditionally, `indentation` keeps track of the current indentation level for each element while creating the plantUML code. It is used to properly format the output in a way that PlantUML can understand. "
    },
    {
        "instruction": "Calls made in `get_plantUML_element` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str",
        "output": "Calls made in `get_plantUML_element`:isinstance, next, iter, key.startswith, get_plantUML_element\n\nPurpose and Significance:\nThe objects/functions `isinstance`, `next`, and `key.startswith` are used within the `get_plantUML_element` function to check if an element is a dictionary or string, extract the first key of a dictionary, and determine which type of statement it represents (function, class, control flow) respectively. The `get_plantUML_element` function is then called recursively on any child elements in the current element's value. "
    },
    {
        "instruction": "Calls made in `get_plantUML` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in file_details['file_info']['control_flow_structure']:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str",
        "output": "Calls made in `get_plantUML`:get_plantUML_element\n\nPurpose and Significance:\nThe `get_plantUML` function is responsible for generating PlantUML diagrams from a given set of file details. It does this by recursively iterating through the control flow tree and adding elements to a string based on their type, which are then used to generate the final PlantUML diagram using the `@startuml` and `@enduml` tags. The `get_plantUML_element` function is responsible for generating the PlantUML code for each element in the control flow tree. It takes an element as input and returns a string containing the corresponding PlantUML code, along with any nested elements if necessary.\r\n\nFor example: \r\n- If the element is a dictionary (i.e., `{\"class Foo(): ...\"` or `{f\"def foo(): {[...]}`), it checks if the key of the dictionary matches a certain pattern to determine if it represents a function definition, class definition, `if`, `while`, etc., and uses the PlantUML syntax to add a node to the string accordingly. If there are nested elements in the value (i.e., `[...]`), it recursively calls itself with an increased indentation level.\r\n- If the element is just a string (i.e., `\"def foo():\" or \"foo = ...\"`), it assumes it's a node in the graph and adds a label to it, without any further processing. "
    },
    {
        "instruction": "Calls made in `get_code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    try:\n        file_ast = file_details['file_info']['file_ast']\n        file_details['file_info']['control_flow_structure'] = reorganize_control_flow(file_details['file_info']['entire_code_graph'], extract_control_flow_tree(file_ast.body))\n        file_details['file_info']['plantUML'] = get_plantUML(file_details)\n    except Exception as e:\n        file_details['file_info']['control_flow_structure'] = [str(e)]\n        file_details['file_info']['plantUML'] = str(e)\n    del file_details['file_info']['file_ast']\n    return file_details",
        "output": "Calls made in `get_code_graph`:code_graph, json.dumps(file_details['file_info']['file_summary']).replace, json.dumps, reorganize_control_flow, extract_control_flow_tree, get_plantUML, str\n\nPurpose and Significance:\nThe code provided above implements a Python script to create a code graph and control flow tree for a given file using the AST module of Python. The `code_graph` function creates a dictionary representation of the file details by extracting function and class method details from the file summary, creating a directed graph with nodes and edges representing the relationships in the code, adding edges for function and class method calls, and returning a dictionary with nodes and edges representing the relationships in the code. The `extract_control_flow_tree` function extracts control flow tree from AST by processing nodes and edges of the AST to identify control structures such as if statements, while loops, try-except blocks, for loops, and functions. The `reorganize_control_flow` function reorganizes the control flow structure recursively based on the code graph, and the `get_plantUML_element` function gets PlantUML code for each element. Finally, the `get_code_graph` function adds the code graph and control flow to file details, creating a final JSON output containing nodes and edges in the code as well as PlantUML representation of the file.\r\n\nIn the `get_code_graph` function, the following objects are used:\r\n- `json.dumps(file_details['file_info']['file_summary']).replace` - this method is called on a JSON representation of the `file_details`, to replace any single quotes that appear in it with empty strings.\r\n- `reorganize_control_flow` - this function reorganizes the control flow structure based on the code graph, which was created by the `code_graph` function\r\n- `extract_control_flow_tree` - this function extracts the control flow tree from AST nodes\r\n- `get_plantUML` - this function gets PlantUML code for entire file using the reorganized control flow structure\r\n- `str` - used to convert exceptions to strings in case of any errors that occur while creating the control flow and PlantUML representations. "
    },
    {
        "instruction": "Variables defined in `code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}",
        "output": "Variables defined in `code_graph`:class_names, called_class_name, fully_qualified_name, G, edges, edge_data, method_name, init_method, source_details, class_method_details_lookup, init_method_name, nodes, qualified_method_name, nodes_to_remove, function_details_lookup, target_details\n\nPurpose and Significance:\nThe purpose of these objects is to perform the following functions:\r\n\n1. `class_names`: A list that stores the class names defined in a Python file.\r\n2. `called_class_name`: A variable used in a function or class method to check if an element is called within another element's body and belongs to a class.\r\n3. `G`: An instance of a NetworkX DiGraph object that represents the code graph as a directed graph with nodes and edges.\r\n4. `edges`: A list containing all the edges in the graph.\r\n5. `edge_data`: A dictionary that contains data about each edge, such as input and output parameters.\r\n6. `method_name`: The name of a method within a class.\r\n7. `init_method`: The `__init__` method of a class.\r\n8. `source_details`: Details about the source element in an edge.\r\n9. `class_method_details_lookup`: A lookup dictionary for class methods.\r\n10. `init_method_name`: The name of the `__init__` method within a class.\r\n11. `nodes`: A list containing all the nodes in the graph.\r\n12. `qualified_method_name`: The fully qualified name of a method, including its class name and method name.\r\n13. `nodes_to_remove`: Nodes that do not belong to either an edge's source or target node and can be safely removed from the graph.\r\n14. `function_details_lookup`: A lookup dictionary for function details.\r\n15. `target_details`: Details about the target element in an edge.\r\n\nThe significance of these variables is as follows:\r\n- `class_names` is used to identify which class a method belongs to when a self reference is encountered, and to ensure that classes are represented as nodes in the graph.\r\n- `called_class_name` helps with determining if an element called within another element's body belongs to a class or not.\r\n- `G` is used to create the directed graph representation of the code. It stores all the node and edge information for each element in the file, as well as their input and output parameters.\r\n- `edges` are added to the graph based on function calls and method calls within classes.\r\n- `edge_data` contains data about each edge, such as input and output parameters, which is used to add edges with specific information to the graph.\r\n- `method_name` is used to create a fully qualified name for class methods.\r\n- `init_method` stores the name of an init method that should be added if the `__init__()` function within a class has been called elsewhere in the code. This helps with resolving inheritance issues and ensuring that classes are represented as nodes in the graph.\r\n- `source_details` is used to extract data about the source element, such as input parameters for an edge.\r\n- `class_method_details_lookup` is a lookup dictionary for class methods, which allows for easy access to their details when adding edges between them and other elements.\r\n- `init_method_name` is used to create a fully qualified name for the `__init__()` method of a class.\r\n- `nodes` contains all the nodes in the graph.\r\n- `qualified_method_name` is used to create a fully qualified name for methods within classes.\r\n- `nodes_to_remove` are any nodes that do not belong to either an edge's source or target node and can be safely removed from the graph.\r\n- `function_details_lookup` contains function details, such as its arguments, returns, and calls.\r\n- `target_details` contains data about the target element in an edge, including any parameters it expects from its inputs. This allows us to check for expected parameters if the function call does not use explicit positional arguments.\r\n\nIn summary, these objects are used throughout the code to help build and manage a graph representation of the file's structure. "
    },
    {
        "instruction": "Variables defined in `get_edge_data_from_details` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "Variables defined in `get_edge_data_from_details`:edge_data\n\nPurpose and Significance:\nThe `get_edge_data_from_details` function is a helper function that extracts edge data from target details, source details, and the target node name. It updates the existing dictionary with edge data, such as the input and output values of each method call. The purpose of this function is to add edge data to the graph edges.\r\n\nThe `add_edge_with_data` function adds an edge between two nodes in the graph with the appropriate edge data extracted from the `get_edge_data_from_details` function. It takes into account whether a method call is within a class or not, and also handles cases where the target node may be a class instead of a function.\r\n\nThe `extract_control_flow_tree` function recursively extracts control flow tree from AST nodes. The `node_keywords_map` dictionary maps each AST keyword to its corresponding plantUML keyword, such as 'if', 'while', and 'for'. The `isinstance` checks for each type of node in the AST and adds it to the control flow tree accordingly.\r\n\nThe `reorganize_control_flow` function takes the code graph and control flow structure, and reorganizes the control flow to match the order of nodes in the code graph. It starts from the starting points of the graph and finds matching elements in the control flow structure recursively.\r\n\nThe `get_plantUML_element` function generates plantUML code for each element in the control flow tree, with indentation based on its level in the hierarchy. The `get_plantUML` function generates the entire plantUML code for the file by iterating through the reorganized control flow structure.\r\n\nThe `get_code_graph` function adds the code graph and control flow to the file details, then removes the AST from the file details. "
    },
    {
        "instruction": "Variables defined in `add_edge_with_data` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))",
        "output": "Variables defined in `add_edge_with_data`:source_details, target_details\n\nPurpose and Significance:\nThe function `code_graph` takes a dictionary of file summary as input and returns a dictionary with nodes and edges representing the relationships in the code. The `function_details_lookup` variable is a lookup dictionary for function and class method details. The `add_edge_with_data` helper function extracts edge data from target details, source details and stores them along with source node name. In case of call, if targeted class doesn't have the attribute/function present it searches the code in file_summary and creates a new node for that call. `add_edges_for_calls` function adds edges to the graph based on calls made in each method. "
    },
    {
        "instruction": "Variables defined in `add_edges_for_calls` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)",
        "output": "Variables defined in `add_edges_for_calls`:class_names, fully_qualified_name, init_method, method_name, init_method_name, called_class_name\n\nPurpose and Significance:\nThe variables are defined inside the `add_edges_for_calls` function in the `code_graph` function. They are used to store the following values:\r\n- `class_names`: a list of class names from all the classes present in the file summary.\r\n- `fully_qualified_name`: The fully qualified name of the method that is being called, if it belongs to a class and has an `__init__` method. For example, if we have a class named `MyClass` with an `__init__` method, and we call `MyClass()` from another function or method, then the fully qualified name would be `MyClass.__init__`.\r\n- `method_name`: The name of the method that is being called.\r\n- `init_method`: The name of the `__init__` method of a class. For example, if we have a class named `MyClass`, then its `__init__` method would be `MyClass.__init__`.\r\n- `called_class_name`: The name of the class that is being called.\r\n\nThe purpose of these variables is to check whether a call is being made to an instance or class method, and to add the edge with the correct source and target. For example, if we have `MyClass()` in our code, then we need to add an edge from the function that contains this call to the `__init__` method of `MyClass`. If there is no `__init__` method, we create a node for the class itself and add an edge between the source and target nodes. "
    },
    {
        "instruction": "Variables defined in `extract_control_flow_tree` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {'if': 'If', 'while': 'While', 'for': 'For', 'asyncfor': 'AsyncFor', 'with': 'With', 'asyncwith': 'AsyncWith', 'try': 'Try', 'except': 'ExceptHandler', 'def': 'FunctionDef', 'asyncdef': 'AsyncFunctionDef', 'class': 'ClassDef', 'return': 'Return'}\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append({f'def {node.name}({args_str})': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.If):\n            if_block = {f'if {ast.unparse(node.test)}': extract_control_flow_tree(node.body)}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update({f'elif {ast.unparse(orelse[0].test)}': extract_control_flow_tree(orelse[0].body)})\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({'else': extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({'return': [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append({'return': []})\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = ast.unparse(handler.type) if handler.type is not None else ''\n                handler_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                except_block.append({f'except {handler_type} as {handler_name}:': extract_control_flow_tree(handler.body)})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append({f'while {ast.unparse(node.test)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.For):\n            control_flow_tree.append({f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.With):\n            control_flow_tree.append({f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append({f'class {node.name}': extract_control_flow_tree(node.body)})\n        elif any((isinstance(node, getattr(ast, node_keywords_map[keyword])) for keyword in node_keywords_map.keys())):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree",
        "output": "Variables defined in `extract_control_flow_tree`:try_block, control_flow_tree, handler_name, else_block, args_str, if_block, handler_type, orelse, node_keywords_map, control_flow_dict, except_block, finally_block\n\nPurpose and Significance:\nThe `extract_control_flow_tree` function is responsible for extracting the control flow tree from the Abstract Syntax Tree (AST) of a Python file. It takes in a list of AST nodes and recursively traverses through them to create a dictionary representation of the control flow structure. The objects defined in this function are used as helper functions during the creation of the control flow tree:\r\n\n- `try_block`: A list representing the try block of the current node.\r\n- `control_flow_tree`: The current control flow tree being constructed recursively, with child nodes.\r\n- `handler_name`: Name of an exception handler (if any).\r\n- `else_block`: Any `else` blocks found during the traversal of a try-except block.\r\n- `args_str`: String representation of function arguments for display in the PlantUML output.\r\n- `if_block`: The current if statement being processed.\r\n- `handler_type`: Type of an exception handler (if any).\r\n- `control_flow_dict`: A dictionary representing a control flow node, with its children as keys and values.\r\n- `except_block`: A list representing the except block of the current node.\r\n- `finally_block`: Any `finally` blocks found during the traversal of a try-except block.\r\n\nThese objects are used to help build up the control flow tree as we iterate through the AST nodes, which can be nested and complex in Python code. "
    },
    {
        "instruction": "Variables defined in `reorganize_control_flow` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)",
        "output": "Variables defined in `reorganize_control_flow`:targets, element_id, key, remaining, starting_points\n\nPurpose and Significance:\nThe function `reorganize_control_flow` is a helper function used to reorganize the control flow structure into a dictionary. The `targets` variable stores all the target nodes of edges in the code graph. The `element_id` variable is used to store the unique identifier for each element in the control flow structure, which helps in checking if an element has already been seen before. The `starting_points` list stores all starting points for the code graph.\r\n\nIn the first step of reorganizing the control flow structure, we iterate through each start point and find matching elements in the given structure. If a match is found, we add it to the organized list and mark it as seen using `seen`. If an element is not included in the organized list, we append it at the end.\r\n\nThen, we define a recursive function to reorganize the control flow structure recursively by calling itself on each child of the matched dictionary elements. This will ensure that nested structures are handled properly. We update `indentation` accordingly while going through different levels in the recursion to reflect the level of indentation in PlantUML code.\r\n\nFinally, we return the reorganized control flow structure. "
    },
    {
        "instruction": "Variables defined in `reorganize_structure` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized",
        "output": "Variables defined in `reorganize_structure`:remaining, key, element_id\n\nPurpose and Significance:\nThe `reorganize_structure` function is a recursive function that takes two arguments - `structure` and `start_points`. It returns an organized version of the `structure` where each element in it matches one of the `start_points`. The `remaining` variable contains any elements not found in `structure`, and are added at the end of the reorganized structure. \r\n\nThe function first iterates through each element in `structure` and checks if it is a dictionary or string. If it's a dictionary, it gets the key (which should be an indentation level), which corresponds to either \"class \", \"def \", \"if \", \"for \", \"while \", \"asyncfor\", or \"try\" keywords.\r\n\nIf it starts with \"class \" or \"def \", it creates a new level of indentation, as it represents a block. It then iterates through the values of the dictionary recursively to reorganize them based on their start points, and appends them to `organized` list along with the key.\r\n\nIf it starts with \"if \", \"for \", \"while \", or \"asyncfor \", it simply appends that key without increasing the indentation level as the following block has not yet been added.\r\nIf it is an except handler, it also adds a new level of indentation. If it is any other string element (i.e., a function call), it appends it to `organized` list with the current indentation level.\r\n\nFinally, it returns the `organized` list along with any remaining elements that were not added to it. "
    },
    {
        "instruction": "Variables defined in `get_plantUML_element` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str",
        "output": "Variables defined in `get_plantUML_element`:inner_indentation, value, key, plantuml_str\n\nPurpose and Significance:\nThe variables defined in `get_plantUML_element` function are used to keep track of the current indentation level and the values of the dictionary keys. The `value` variable stores the list of child elements or string value for each element in the control flow structure, which is then processed recursively to create the Plant UML code. The `key` variable holds the first key from the dictionary which is used to identify what type of element it is (`def`, `if`, etc.). Finally, `plantuml_str` is used to store the plantUML code for each element while processing and return it after all the child elements are processed. "
    },
    {
        "instruction": "Variables defined in `get_plantUML` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in file_details['file_info']['control_flow_structure']:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str",
        "output": "Variables defined in `get_plantUML`:plantuml_str\n\nPurpose and Significance:\nThe variable `plantuml_str` is a string that represents the PlantUML code for an element in the control flow structure. It is used to recursively build up the entire PlantUML code for the file by calling the `get_plantUML_element()` function on each element of the control flow structure and appending it to the final output. "
    },
    {
        "instruction": "Variables defined in `get_code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    try:\n        file_ast = file_details['file_info']['file_ast']\n        file_details['file_info']['control_flow_structure'] = reorganize_control_flow(file_details['file_info']['entire_code_graph'], extract_control_flow_tree(file_ast.body))\n        file_details['file_info']['plantUML'] = get_plantUML(file_details)\n    except Exception as e:\n        file_details['file_info']['control_flow_structure'] = [str(e)]\n        file_details['file_info']['plantUML'] = str(e)\n    del file_details['file_info']['file_ast']\n    return file_details",
        "output": "Variables defined in `get_code_graph`:file_ast\n\nPurpose and Significance:\nThe variable `file_ast` is used to extract the control flow tree from AST. It represents the Abstract Syntax Tree (AST) of the Python file that is being analyzed, which contains all the information about the syntax and structure of the code. By passing it through `extract_control_flow_tree` function, we can create a simplified representation of the program's control flow based on function definitions, loops, conditionals, etc. This AST is then used to reorganize the control flow tree using `reorganize_control_flow` function and add it to the file details dictionary. Finally, we use `get_plantUML_element` function to generate PlantUML code for each element in the control flow structure and `get_plantUML` function to generate the entire PlantUML code for the file. "
    },
    {
        "instruction": "Returns from `code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}",
        "output": "Returns from `code_graph`:{'nodes': nodes, 'edges': edges}, edge_data\n\nPurpose and Significance:\nThe function `code_graph()` returns a dictionary with two keys: 'nodes' and 'edges', which represent the nodes and edges of the code graph respectively. The 'nodes' key contains a list of all the functions and class methods present in the file, while the 'edges' key contains a list of dictionaries representing each edge between nodes in the graph with additional information such as the inputs and returns of the function/method being called. "
    },
    {
        "instruction": "Returns from `get_edge_data_from_details` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "Returns from `get_edge_data_from_details`:edge_data\n\nPurpose and Significance:\nThe `get_edge_data_from_details` function is a helper function that extracts edge data from target details. It takes in two arguments, `target_details` and `source_details`, which are dictionaries containing information about the source node of an edge, such as inputs or returns, and returns a dictionary containing any relevant edge data based on those details. "
    },
    {
        "instruction": "Returns from `extract_control_flow_tree` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {'if': 'If', 'while': 'While', 'for': 'For', 'asyncfor': 'AsyncFor', 'with': 'With', 'asyncwith': 'AsyncWith', 'try': 'Try', 'except': 'ExceptHandler', 'def': 'FunctionDef', 'asyncdef': 'AsyncFunctionDef', 'class': 'ClassDef', 'return': 'Return'}\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append({f'def {node.name}({args_str})': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.If):\n            if_block = {f'if {ast.unparse(node.test)}': extract_control_flow_tree(node.body)}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update({f'elif {ast.unparse(orelse[0].test)}': extract_control_flow_tree(orelse[0].body)})\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({'else': extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({'return': [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append({'return': []})\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = ast.unparse(handler.type) if handler.type is not None else ''\n                handler_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                except_block.append({f'except {handler_type} as {handler_name}:': extract_control_flow_tree(handler.body)})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append({f'while {ast.unparse(node.test)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.For):\n            control_flow_tree.append({f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}': extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.With):\n            control_flow_tree.append({f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(node.body)})\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append({f'class {node.name}': extract_control_flow_tree(node.body)})\n        elif any((isinstance(node, getattr(ast, node_keywords_map[keyword])) for keyword in node_keywords_map.keys())):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree",
        "output": "Returns from `extract_control_flow_tree`:control_flow_tree\n\nPurpose and Significance:\nThe `code_graph` function creates a dictionary representation of the file details, which includes nodes and edges representing the relationships in the code. It also extracts function and class method details and adds them to lookup dictionaries for later use. The helper functions `get_edge_data_from_details`, `add_edge_with_data`, and `add_edges_for_calls` are used to add edges with data to the graph, and then the function returns a dictionary of nodes and edges representing the relationships in the code.\r\n\nThe `extract_control_flow_tree` function extracts control flow tree from AST. It recursively traverses through each node in the AST and creates a list of dictionaries containing the structure of the code.\r\n\nThe `reorganize_control_flow` function gets starting points from the code graph and reorganizes the control flow structure recursively to match the order of nodes in the code graph. It returns a reorganized control flow structure.\r\n\nThe `get_plantUML_element` function takes an element and indentation level as input, and generates PlantUML code for each element based on its type (function definition, class definition, if statement, etc.).\r\n\nThe `get_plantUML` function generates the entire PlantUML code for the file.\r\n\nThe `get_code_graph` function adds code graph and control flow to the file details and returns it. "
    },
    {
        "instruction": "Returns from `reorganize_control_flow` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)",
        "output": "Returns from `reorganize_control_flow`:reorganize_structure(control_flow_structure, starting_points), organized\n\nPurpose and Significance:\nThe purpose of the 'returns' object is to return the reorganized control flow structure. The significance of this object is that it represents the reorganization of the control flow that match with code graph edges so as it doesn't go back to node when reaching edge with unfulfilled incoming requirements which lead to cycles in the graph.\r\n\nIn `reorganize_control_flow` function, we have a list of starting points and iterate through each start point and find matching elements in the structure. If an element is a dictionary, it means that it has sub-elements and we need to recursively call this function until all the elements are organized.\r\n\nThe `get_plantUML` function takes the file details as input and returns the plantUML code for entire file. It uses the control flow structure to generate the plantUML code for each element in the file. \r\n\nIn `get_code_graph`, we first create a graph using the `code_graph` function which creates nodes and edges representing relationships in the code.\r\nWe then add code graph and control flow to the file details.\r\n"
    },
    {
        "instruction": "Returns from `reorganize_structure` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized",
        "output": "Returns from `reorganize_structure`:organized\n\nPurpose and Significance:\nThe `reorganize_structure` function is a recursive function that takes in two arguments, `structure` and `start_points`. It iterates through each element in the `structure`, checks if it's a dictionary or string, and then adds it to the `organized` list along with any sub-elements that match the `start_points` and haven't been seen before. The `get_plantUML_element` function takes an `element` as input and returns its PlantUML representation. It also handles indentation based on the type of element being processed, such as if it's a class or a loop. Finally, the `get_plantUML` function generates the entire PlantUML code for the file by iterating through each element in the reorganized control flow structure and adding its plantUML representation to the string. The `get_code_graph` function adds the code graph and control flow to the file details, then removes the AST from the file details before returning it. "
    },
    {
        "instruction": "Returns from `get_plantUML_element` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str",
        "output": "Returns from `get_plantUML_element`:plantuml_str\n\nPurpose and Significance:\nThe function `get_plantUML_element()` is used to generate PlantUML code for each element in the control flow structure. It takes an element and indentation level as input, and returns a string containing the PlantUML code for that element with the specified indentation level. The purpose of this function is to recursively traverse through the control flow structure, adding nodes to the final output while updating their child nodes, as appropriate. If a dictionary is provided as an element, it retrieves its key (the name of the node) and checks if it matches any of the keywords in `node_keywords_map`. Depending on the keyword, it generates PlantUML code for that specific type of node. For example, if the key starts with \"def \", it means it's a function definition, so it creates a new class block and adds its child nodes to it recursively. If the key is just a string, it means it's a regular statement, so it generates PlantUML code for that statement.\r\n\nThe `get_plantUML()` function takes in `file_details`, an input argument obtained by running the `get_code_graph` function (which provides code and graph structure of the file), and returns the entire PlantUML code for the file. It iterates through each element in the control flow structure, calling `get_plantUML_element()` on it to generate PlantUML code for that element with the appropriate indentation level.\r\n\nThe `get_code_graph` function is used to extract the graph structure of a Python file and add it to the `file_details` dictionary. It takes in `file_summary`, which contains information about functions, classes, and their method calls, as well as the AST (Abstract Syntax Tree) of the file. The `code_graph()` function is used to create a directed graph from this data, while `extract_control_flow_tree` generates a control flow tree from the AST nodes. The `reorganize_control_flow` function takes in both of these structures and rearranges them to match each other, and the `get_plantUML` function creates the final PlantUML output string. "
    },
    {
        "instruction": "Returns from `get_plantUML` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in file_details['file_info']['control_flow_structure']:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str",
        "output": "Returns from `get_plantUML`:plantuml_str\n\nPurpose and Significance:\nThe object `'{returns_from get_plantUML}: plantuml_str'` is the output from calling the function `get_plantUML` with `file_details`. This function takes in a dictionary of file details and returns a string containing PlantUML code for the entire file. The purpose of this object is to generate a visual representation of the code's control flow, which can be used as input into an online plantUML tool such as [PlantText](https://www.planttext.com/) or [Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=johannespegler.vscode-plantuml-markdown) to create a visual diagram of the code structure.\r\n\n```python\r\nimport ast\r\nfrom typing import Dict, List, Optional, Union\r\nimport networkx as nx\r\n\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]:\r\n    \"\"\"\r\n    Create a dictionary representation of file details.\r\n    Args:\r\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\r\n    Returns:\r\n        dict: A dictionary with nodes and edges representing the relationships in the code.\r\n    \"\"\"\r\n``` "
    },
    {
        "instruction": "Returns from `get_code_graph` in Python file: `py2dataset.get_code_graph.py`?",
        "input": "def get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    try:\n        file_ast = file_details['file_info']['file_ast']\n        file_details['file_info']['control_flow_structure'] = reorganize_control_flow(file_details['file_info']['entire_code_graph'], extract_control_flow_tree(file_ast.body))\n        file_details['file_info']['plantUML'] = get_plantUML(file_details)\n    except Exception as e:\n        file_details['file_info']['control_flow_structure'] = [str(e)]\n        file_details['file_info']['plantUML'] = str(e)\n    del file_details['file_info']['file_ast']\n    return file_details",
        "output": "Returns from `get_code_graph`:file_details\n\nPurpose and Significance:\nThe `get_code_graph` function returns a dictionary representation of the file details, which includes nodes and edges representing the relationships in the code. It uses NetworkX library to create a directed graph (G) containing the following information: 1. Nodes: All the functions, classes, methods, and variables in the Python source code are added as nodes in G. 2. Edges: Each edge represents a function call or method call between two nodes. The edge data contains the input arguments passed to the target node and any return values from the source node. 3. Control flow tree: A control flow tree is extracted using `extract_control_flow_tree` function, which helps to create an understanding of the overall program structure, like which statement or code block calls another, as per each condition/branch. The reorganized control flow structure is then created using `reorganize_control_flow` function, which helps in visualizing the program structure by grouping similar statements together. Finally, a PlantUML string representation of the entire file is generated using `get_plantUML` function to display the relationships and dependencies between nodes.\r\n\nThe output dictionary from this function can be used for further processing or analysis of the code. "
    },
    {
        "instruction": "1) Describe the Purpose and Processing summary of Python file: `py2dataset.get_code_graph.py`; 2) Summarize the Significance of applicable Function, Class, and Method; 3) Explain what each Input, Output, and Variable does in the code.",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Adds code graph and control flow to file details.\n        b. Returns file details.\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]]\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        \"if\": \"If\",\n        \"while\": \"While\",\n        \"for\": \"For\",\n        \"asyncfor\": \"AsyncFor\",\n        \"with\": \"With\",\n        \"asyncwith\": \"AsyncWith\",\n        \"try\": \"Try\",\n        \"except\": \"ExceptHandler\",\n        \"def\": \"FunctionDef\",\n        \"asyncdef\": \"AsyncFunctionDef\",\n        \"class\": \"ClassDef\",\n        \"return\": \"Return\",\n    }\n    for node in nodes:\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            control_flow_tree.append(\n                {f\"def {node.name}({args_str})\": extract_control_flow_tree(node.body)}\n            )\n        elif isinstance(node, ast.If):\n            if_block = {\n                f\"if {ast.unparse(node.test)}\": extract_control_flow_tree(node.body)\n            }\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                if_block.update(\n                    {\n                        f\"elif {ast.unparse(orelse[0].test)}\": extract_control_flow_tree(\n                            orelse[0].body\n                        )\n                    }\n                )\n                orelse = orelse[0].orelse\n            if orelse:\n                if_block.update({\"else\": extract_control_flow_tree(orelse)})\n            control_flow_tree.append(if_block)\n        elif isinstance(node, ast.Return):\n            if node.value is not None:\n                control_flow_tree.append({\"return\": [ast.unparse(node.value)]})\n            else:\n                control_flow_tree.append(\n                    {\"return\": []}\n                )  # Handle cases with no return value\n        elif isinstance(node, ast.Try):\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                handler_type = (\n                    ast.unparse(handler.type) if handler.type is not None else \"\"\n                )\n                handler_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                except_block.append(\n                    {\n                        f\"except {handler_type} as {handler_name}:\": extract_control_flow_tree(\n                            handler.body\n                        )\n                    }\n                )\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        elif isinstance(node, ast.While):\n            control_flow_tree.append(\n                {\n                    f\"while {ast.unparse(node.test)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.For):\n            control_flow_tree.append(\n                {\n                    f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.With):\n            control_flow_tree.append(\n                {\n                    f\"with {', '.join([ast.unparse(item) for item in node.items])}\": extract_control_flow_tree(\n                        node.body\n                    )\n                }\n            )\n        elif isinstance(node, ast.ClassDef):\n            control_flow_tree.append(\n                {f\"class {node.name}\": extract_control_flow_tree(node.body)}\n            )\n        elif any(\n            isinstance(node, getattr(ast, node_keywords_map[keyword]))\n            for keyword in node_keywords_map.keys()\n        ):\n            control_flow_tree.append({ast.unparse(node): []})\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow sturcture to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(file_details):\n    \"\"\"\n    Get plantUML code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in file_details[\"file_info\"][\"control_flow_structure\"]:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_details):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    file_details[\"file_info\"][\"entire_code_graph\"] = code_graph(\n        file_details[\"file_info\"][\"file_summary\"]\n    )\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(\n        file_details[\"file_info\"][\"file_summary\"]\n    ).replace('\"', \"\")\n\n    # file_code_simplified is the code without comments and docstrings\n    try:\n        file_ast = file_details[\"file_info\"][\"file_ast\"]  # Accessing the AST\n        file_details[\"file_info\"][\"control_flow_structure\"] = reorganize_control_flow(\n            file_details[\"file_info\"][\"entire_code_graph\"],\n            extract_control_flow_tree(file_ast.body)  # Using the AST for control flow extraction\n        )\n        file_details[\"file_info\"][\"plantUML\"] = get_plantUML(file_details)\n    except Exception as e:\n        file_details[\"file_info\"][\"control_flow_structure\"] = [str(e)]\n        file_details[\"file_info\"][\"plantUML\"] = str(e)  \n\n    # remove the AST from the file_details\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "Purpose of Python File: \nThis python file provides functions that extract code details and graph, create control flow trees for python files and convert it to plant UML representation for the visualization purposes.\r\n\nSignificance of Applicable Functions/Classes:\r\n\nFunction `code_graph()`: \r\n    - Takes a dictionary object representing the file summary as input. It creates nodes and edges for functions, class methods and their relationships based on how they call each other and returns them.\r\n    - Each function call is represented as an edge with appropriate label. If it is calling another method within a class or function, it will have additional data in the edge that includes input/output details.\r\n\nFunction `extract_control_flow_tree()`: \r\n    - Extracts control flow tree from AST. It traverses through the AST nodes and creates a list of nested dictionaries to represent the control flow structure.\r\n    - Each dictionary contains either a string or another dictionary with key-value pairs representing different control structures like if, while, for, try, etc. If it is calling other functions or methods within a class or function, those will be added as a key in the respective dictionaries.\r\n\nFunction `reorganize_control_flow()`: \r\n    - It re-arranges the structure to start with functions or class that don't have any parent or ancestors in the control flow tree. This is done recursively by checking if the current element has any parents and adding it to the organized list.\r\n\nFunction `get_plantUML_element()`: \r\n    - It converts each element of the control flow tree into a Plant UML code for better visualization and readability.\r\n\nFunction `get_plantUML()`: \r\n    - It takes the reorganized control flow structure and creates a plant UML representation of the file.\r\n\nFunction `get_code_graph()`: \r\n    - This function adds the code graph and control flow to the file details dictionary. It also removes any nodes that are not either a source or target of an edge in the code graph.\r\n\nInputs to `code_graph`:\r\n- `file_summary` : A dictionary containing various attributes extracted from python file.\r\n    - keys: name, encoding, error_lineno, class_defs, function_defs\r\n\nOutputs of `code_graph`:\r\n- Returns a dictionary with nodes and edges representing the relationships in the code.\r\n\nInputs to `extract_control_flow_tree()`:\r\n- `nodes` : A list of ast.AST objects that represent different parts of the file.\r\n\nOutputs of `extract_control_flow_tree`:\r\n- Returns a control flow tree as a nested dictionary.\r\n\nInputs to `reorganize_control_flow()`:\r\n- `code_graph` : A dictionary containing nodes and edges representing the relationships in the code.\r\n- `control_flow_structure` : Control flow structure extracted from the AST.\r\n\nOutputs of `reorganize_control_flow`:\r\n- Returns a reorganized control flow structure that matches the code graph.\r\n\nInputs to `get_plantUML_element()`:\r\n- `element` : An element in the control flow tree.\r\n- `indentation` : The current level of indentation.\r\nOutputs of `get_plantUML_element`: \r\n- A Plant UML string that can be used to visualize the code structure.\r\n\nInputs to `get_plantUML()`:\r\n- `file_details` : Dictionary containing file details and control flow structure.\r\nOutputs of `get_plantUML`:\r\n- Returns a plantUML string for the entire file.\r\n\nInputs to `get_code_graph()`:\r\n- `file_details` : A dictionary containing various attributes extracted from python file.\r\nOutputs of `get_code_graph`:\r\n- Adds code graph and control flow to file details dictionary. It also removes any nodes that are not either a source or target of an edge in the code graph.\r\n``` \n{\n    \"Code Elements\": {\n        \"Dependencies\": \"json, networkx, typing, ast\",\n        \"Functions defined\": \"code_graph, get_edge_data_from_details, add_edge_with_data, add_edges_for_calls, extract_control_flow_tree, reorganize_control_flow, reorganize_structure, get_plantUML_element, get_plantUML, get_code_graph\",\n        \"`add_edge_with_data` Calls\": \"class_method_details_lookup.get, function_details_lookup.get, G.add_edge, get_edge_data_from_details\",\n        \"`add_edge_with_data` Inputs\": \"source, target, init_method\",\n        \"`add_edge_with_data` Variables\": \"source_details, target_details\",\n        \"`add_edges_for_calls` Calls\": \"list, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, G.add_node\",\n        \"`add_edges_for_calls` Inputs\": \"source_name, calls\",\n        \"`add_edges_for_calls` Variables\": \"class_names, fully_qualified_name, init_method, method_name, init_method_name, called_class_name\",\n        \"`code_graph` Calls\": \"nx.DiGraph, function_details_lookup.update, class_def.items, G.add_node, class_details['method_defs'].items, G.add_edge, target_details.get, list, set, class_method_details_lookup.get, function_details_lookup.get, get_edge_data_from_details, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, function_details_lookup.items, add_edges_for_calls, class_method_details_lookup.items, G[source][target].update, G.edges.data, nodes_to_remove.append\",\n        \"`code_graph` Inputs\": \"file_summary\",\n        \"`code_graph` Returns\": \"{'nodes': nodes, 'edges': edges}, edge_data\",\n        \"`code_graph` Variables\": \"class_names, called_class_name, fully_qualified_name, G, edges, edge_data, method_name, init_method, source_details, class_method_details_lookup, init_method_name, nodes, qualified_method_name, nodes_to_remove, function_details_lookup, target_details\",\n        \"`extract_control_flow_tree` Calls\": \"isinstance, , .join, ast.unparse, control_flow_tree.append, extract_control_flow_tree, if_block.update, except_block.append, any, getattr, node_keywords_map.keys\",\n        \"`extract_control_flow_tree` Inputs\": \"nodes\",\n        \"`extract_control_flow_tree` Returns\": \"control_flow_tree\",\n        \"`extract_control_flow_tree` Variables\": \"try_block, control_flow_tree, handler_name, else_block, args_str, if_block, handler_type, orelse, node_keywords_map, control_flow_dict, except_block, finally_block\",\n        \"`get_code_graph` Calls\": \"code_graph, json.dumps(file_details['file_info']['file_summary']).replace, json.dumps, reorganize_control_flow, extract_control_flow_tree, get_plantUML, str\",\n        \"`get_code_graph` Inputs\": \"file_details\",\n        \"`get_code_graph` Returns\": \"file_details\",\n        \"`get_code_graph` Variables\": \"file_ast\",\n        \"`get_edge_data_from_details` Calls\": \"target_details.get, list, set\",\n        \"`get_edge_data_from_details` Inputs\": \"target_details, source_details, target\",\n        \"`get_edge_data_from_details` Returns\": \"edge_data\",\n        \"`get_edge_data_from_details` Variables\": \"edge_data\",\n        \"`get_plantUML_element` Calls\": \"isinstance, next, iter, key.startswith, get_plantUML_element\",\n        \"`get_plantUML_element` Inputs\": \"element, indentation\",\n        \"`get_plantUML_element` Returns\": \"plantuml_str\",\n        \"`get_plantUML_element` Variables\": \"inner_indentation, value, key, plantuml_str\",\n        \"`get_plantUML` Calls\": \"get_plantUML_element\",\n        \"`get_plantUML` Inputs\": \"file_details\",\n        \"`get_plantUML` Returns\": \"plantuml_str\",\n        \"`get_plantUML` Variables\": \"plantuml_str\",\n        \"`reorganize_control_flow` Calls\": \"set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend, reorganize_structure\",\n        \"`reorganize_control_flow` Inputs\": \"code_graph, control_flow_structure\",\n        \"`reorganize_control_flow` Returns\": \"reorganize_structure(control_flow_structure, starting_points), organized\",\n        \"`reorganize_control_flow` Variables\": \"targets, element_id, key, remaining, starting_points\",\n        \"`reorganize_structure` Calls\": \"set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend\",\n        \"`reorganize_structure` Inputs\": \"structure, start_points\",\n        \"`reorganize_structure` Returns\": \"organized\",\n        \"`reorganize_structure` Variables\": \"remaining, key, element_id\"\n    }\n}"
    }
]