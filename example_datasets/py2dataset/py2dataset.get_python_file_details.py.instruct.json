[
    {
        "instruction": "Dependencies in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n\n    # Remove top-level docstring if present\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = [] \n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node  # Set the parent attribute\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)  \n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": list(\n                {\n                    ast.unparse(target)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Name)\n                }\n            ),\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                ).extend(attributes)\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n        \n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith(\"class_method_\"):\n                    method_defs[method_name[len(\"class_method_\") :]] = {\n                        \"inputs\": details[\"method_inputs\"],\n                        \"calls\": details[\"method_calls\"],\n                        \"call_inputs\": details[\"method_call_inputs\"],\n                        \"returns\": details[\"method_returns\"],\n                    }\n            class_defs.append({class_name: {\"method_defs\": method_defs}})\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node)),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n    file_details = get_code_graph(file_details)\n    return file_details\n\n```",
        "output": "Dependencies:get_code_graph, typing, logging, ast\n\nPurpose and Significance:\nThe `remove_docstring` function is used to remove docstrings from a given Python source code. It takes in a string as input and returns the sanitized code without any comments or docstrings. The `get_all_calls` function recursively finds all function calls within a given node of an AST tree, including those inside classes, list comprehensions, and lambda functions. `CodeVisitor` class inherits from ast.NodeVisitor and implements visit methods to extract information about the code structure using AST traversal. It populates `self.functions`, a dictionary for all the functions present in the given Python code along with their name, documentation, arguments, annotations, variables defined in their context etc. `CodeGraph` takes an object containing information from the source code and creates a directed graph using networkx library. The function `get_python_file_details` accepts a file path as input, reads the content of the file, removes docstrings and comments, extracts details about functions, classes, and their relationships using the `CodeVisitor` class, and returns a dictionary containing all the extracted information along with the code graph. "
    },
    {
        "instruction": "Call code graph in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n\n    # Remove top-level docstring if present\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = [] \n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node  # Set the parent attribute\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)  \n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": list(\n                {\n                    ast.unparse(target)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Name)\n                }\n            ),\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                ).extend(attributes)\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n        \n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith(\"class_method_\"):\n                    method_defs[method_name[len(\"class_method_\") :]] = {\n                        \"inputs\": details[\"method_inputs\"],\n                        \"calls\": details[\"method_calls\"],\n                        \"call_inputs\": details[\"method_call_inputs\"],\n                        \"returns\": details[\"method_returns\"],\n                    }\n            class_defs.append({class_name: {\"method_defs\": method_defs}})\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node)),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n    file_details = get_code_graph(file_details)\n    return file_details\n\n```",
        "output": "{'nodes': ['CodeVisitor', 'CodeVisitor.__init__', 'CodeVisitor.visit_FunctionDef', 'CodeVisitor.visit_ClassDef', 'CodeVisitor.generic_visit', 'CodeVisitor.visit_Assign', 'CodeVisitor.extract_details', 'CodeVisitor.analyze', 'remove_docstring', 'get_all_calls', 'get_python_file_details', 'ast.parse', 'isinstance', 'tree.body.pop', 'ast.walk', 'node.body.pop', 'ast.unparse', 'calls.append', 'ast.iter_child_nodes', 'calls_dict[func].extend', 'open', 'f.read', 'logging.warning', 'visitor.analyze', 'get_code_graph', 'self.visit', 'self.constants.append', 'list', 'next', 'call_data.keys', 'set', \"self.classes[self.current_class].setdefault('class_attributes', []).extend\", 'self.classes[self.current_class].setdefault', 'details.update', 'any', 'self.functions.items', 'self.classes.items', 'class_details.items', 'method_name.startswith', 'len', 'class_defs.append', 'self.functions.keys', 'self.classes.keys'], 'edges': [{'source': 'CodeVisitor', 'target': 'CodeVisitor.__init__', 'target_inputs': ['self', 'code'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_FunctionDef', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_ClassDef', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_Assign', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.analyze', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.generic_visit', 'target': 'ast.iter_child_nodes', 'target_inputs': ['node']}, {'source': 'CodeVisitor.generic_visit', 'target': 'self.visit', 'target_inputs': ['child']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'isinstance', 'target_inputs': ['node.parent', 'ast.Module', 'target', 'ast.Name', 'value', 'ast.Constant', 'value.value', 'str']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'ast.unparse', 'target_inputs': ['value']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'self.constants.append', 'target_inputs': ['constant_assignment']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.extract_details', 'target': 'list', 'target_inputs': ['ast.walk(node)', 'call_data.keys()', '{ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}', '{ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()', '{ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}', '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.walk', 'target_inputs': ['node']}, {'source': 'CodeVisitor.extract_details', 'target': 'get_all_calls', 'target_inputs': ['node'], 'target_returns': ['calls_dict']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.unparse', 'target_inputs': ['node', 'd', 'subnode.value', 'target', 'decorator', 'subnode.annotation', 'subnode', 'base']}, {'source': 'CodeVisitor.extract_details', 'target': 'next', 'target_inputs': ['(n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str))', 'None']}, {'source': 'CodeVisitor.extract_details', 'target': 'isinstance', 'target_inputs': ['n', 'ast.Expr', 'n.value', 'ast.Str', 'subnode', 'ast.Return', 'subnode', 'ast.Assign', 'target', 'ast.Name', 'subnode', 'ast.AnnAssign', 'subnode', 'ast.Attribute', 'subnode.ctx', 'ast.Store', 'subnode', 'ast.Assign', 'target', 'ast.Attribute', 'target.value', 'ast.Name', 'subnode', 'ast.Assign', 'target', 'ast.Attribute', 'subnode', 'ast.FunctionDef', 'subnode', 'ast.FunctionDef', 'decorator', 'ast.Name']}, {'source': 'CodeVisitor.extract_details', 'target': 'call_data.keys', 'target_inputs': []}, {'source': 'CodeVisitor.extract_details', 'target': 'set', 'target_inputs': []}, {'source': 'CodeVisitor.extract_details', 'target': \"self.classes[self.current_class].setdefault('class_attributes', []).extend\", 'target_inputs': ['attributes']}, {'source': 'CodeVisitor.extract_details', 'target': 'self.classes[self.current_class].setdefault', 'target_inputs': [\"'class_attributes'\", '[]']}, {'source': 'CodeVisitor.extract_details', 'target': 'details.update', 'target_inputs': [\"{'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]}\"]}, {'source': 'CodeVisitor.extract_details', 'target': 'any', 'target_inputs': [\"(isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list)\"]}, {'source': 'CodeVisitor.analyze', 'target': 'self.visit', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'list', 'target_inputs': ['ast.walk(node)', 'file_dependencies', 'self.functions.keys()', 'self.classes.keys()', 'file_dependencies']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.walk', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'isinstance', 'target_inputs': ['subnode', 'ast.Import', 'subnode', 'ast.ImportFrom']}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'class_details.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'method_name.startswith', 'target_inputs': [\"'class_method_'\"]}, {'source': 'CodeVisitor.analyze', 'target': 'len', 'target_inputs': [\"'class_method_'\"]}, {'source': 'CodeVisitor.analyze', 'target': 'class_defs.append', 'target_inputs': [\"{class_name: {'method_defs': method_defs}}\"]}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.keys', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.keys', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'remove_docstring', 'target_inputs': ['ast.unparse(node)'], 'target_returns': ['ast.unparse(tree)']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.unparse', 'target_inputs': ['node']}, {'source': 'remove_docstring', 'target': 'ast.parse', 'target_inputs': ['code']}, {'source': 'remove_docstring', 'target': 'isinstance', 'target_inputs': ['tree.body[0]', 'ast.Expr', 'tree.body[0].value', 'ast.Str', 'node', '(ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)', 'first_body_node', 'ast.Expr', 'first_body_node.value', 'ast.Str']}, {'source': 'remove_docstring', 'target': 'tree.body.pop', 'target_inputs': ['0']}, {'source': 'remove_docstring', 'target': 'ast.walk', 'target_inputs': ['tree']}, {'source': 'remove_docstring', 'target': 'node.body.pop', 'target_inputs': ['0']}, {'source': 'remove_docstring', 'target': 'ast.unparse', 'target_inputs': ['tree']}, {'source': 'get_all_calls', 'target': 'isinstance', 'target_inputs': ['node', 'ast.Call', 'node', 'ast.ClassDef', 'body_item', 'ast.Assign', 'body_item.targets[0]', 'ast.Name']}, {'source': 'get_all_calls', 'target': 'calls.append', 'target_inputs': ['(ast.unparse(node.func), [ast.unparse(arg) for arg in node.args])']}, {'source': 'get_all_calls', 'target': 'ast.unparse', 'target_inputs': ['node.func', 'arg']}, {'source': 'get_all_calls', 'target': 'get_all_calls', 'target_inputs': ['body_item.value', 'calls', 'child', 'calls'], 'target_returns': ['calls_dict']}, {'source': 'get_all_calls', 'target': 'ast.iter_child_nodes', 'target_inputs': ['node']}, {'source': 'get_all_calls', 'target': 'calls_dict[func].extend', 'target_inputs': ['args']}, {'source': 'get_python_file_details', 'target': 'open', 'target_inputs': ['file_path', \"'r'\"]}, {'source': 'get_python_file_details', 'target': 'f.read', 'target_inputs': []}, {'source': 'get_python_file_details', 'target': 'ast.parse', 'target_inputs': ['code']}, {'source': 'get_python_file_details', 'target': 'logging.warning', 'target_inputs': [\"f'{e} error in file: {file_path}'\"]}, {'source': 'get_python_file_details', 'target': 'CodeVisitor', 'target_inputs': ['code'], 'target_returns': []}, {'source': 'get_python_file_details', 'target': 'visitor.analyze', 'target_inputs': ['tree']}, {'source': 'get_python_file_details', 'target': 'get_code_graph', 'target_inputs': ['file_details']}]}"
    },
    {
        "instruction": "Functions defined in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n\n    # Remove top-level docstring if present\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = [] \n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node  # Set the parent attribute\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)  \n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": list(\n                {\n                    ast.unparse(target)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Name)\n                }\n            ),\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                ).extend(attributes)\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n        \n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith(\"class_method_\"):\n                    method_defs[method_name[len(\"class_method_\") :]] = {\n                        \"inputs\": details[\"method_inputs\"],\n                        \"calls\": details[\"method_calls\"],\n                        \"call_inputs\": details[\"method_call_inputs\"],\n                        \"returns\": details[\"method_returns\"],\n                    }\n            class_defs.append({class_name: {\"method_defs\": method_defs}})\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node)),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n    file_details = get_code_graph(file_details)\n    return file_details\n\n```",
        "output": "Functions defined:remove_docstring, get_all_calls, get_python_file_details\n\nPurpose and Significance:\nThe `remove_docstring` function removes docstrings from the provided Python code. It does this by first parsing the code into an AST using `ast.parse`, then checking if the first node is a string literal (a docstring) and removing it if so, and finally iterating over all nodes in the tree to remove any other docstrings or comments. The resulting sanitized code is returned as a string.\r\n\nThe `get_all_calls` function recursively finds all function calls in an AST subtree, including those inside class attributes, list comprehensions, and lambda functions. It returns a dictionary of all function calls found, with the keys being the function names and the values being lists of their arguments.\r\n\nThe `CodeVisitor` class is a subclass of `ast.NodeVisitor`, which is used to traverse an AST and extract details about the code. It keeps track of information such as the current class context (`self.current_class`), and the source code, function and class definitions found during traversal (`self.functions` and `self.classes`). The `extract_details` method is called on each node to extract various properties (name, docstring, inputs, defaults, returns, calls, variables, decorators, annotations, etc.) of functions and classes.\r\n\nThe `code_graph` function constructs a directed graph using the networkx library. It takes in the file summary dictionary (`file_details`) and creates nodes for functions, classes, and methods, as well as edges to represent relationships between them (calls). Finally, it returns a dictionary representation of the code call graph.\r\n\nThe `get_python_file_details` function extracts information about Python files using AST and the `CodeVisitor` class. It first removes docstrings from the source code using `remove_docstring`, then uses `ast.parse` to create an AST, which is fed into the visitor object to populate its attributes (`functions`, `classes`, and `file_info`). Finally, it constructs a graph using `get_code_graph`. The resulting dictionary encompasses all extracted file details.\r\n\nThe purpose of these objects within the code is as follows:\r\n- `remove_docstring` removes docstrings from Python source code to simplify parsing and analysis.\r\n- `get_all_calls` finds function calls in an AST subtree, including those inside class attributes, list comprehensions, and lambda functions.\r\n- `CodeVisitor` is a subclass of `ast.NodeVisitor` that visits each node in the AST to gather information about classes and functions in a source code file, populates their definitions and attributes such as name, input variables/annotations/properties, documentation comments (docstring), output values, calls made, and constants.\r\n- `code_graph` constructs a directed graph using networkx library based on the function and class definitions found by `CodeVisitor`. It defines nodes for functions, classes, and methods, and specifies edges to represent relationships between them. The resulting dictionary representation of the code call graph is returned. \r\n- `get_python_file_details` uses these objects to extract information about a Python file, including function definitions, class definitions, and their attributes, as well as dependencies (import statements). It then creates a simplified version of the source code with docstrings removed for easier parsing using `remove_docstring`. The graph representation is created using `code_graph`, and all the details are returned in a dictionary. "
    },
    {
        "instruction": "Classes defined in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n\n    # Remove top-level docstring if present\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = [] \n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node  # Set the parent attribute\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)  \n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": list(\n                {\n                    ast.unparse(target)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Name)\n                }\n            ),\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                ).extend(attributes)\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n        \n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith(\"class_method_\"):\n                    method_defs[method_name[len(\"class_method_\") :]] = {\n                        \"inputs\": details[\"method_inputs\"],\n                        \"calls\": details[\"method_calls\"],\n                        \"call_inputs\": details[\"method_call_inputs\"],\n                        \"returns\": details[\"method_returns\"],\n                    }\n            class_defs.append({class_name: {\"method_defs\": method_defs}})\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node)),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n    file_details = get_code_graph(file_details)\n    return file_details\n\n```",
        "output": "Classes defined:CodeVisitor\n\nPurpose and Significance:\nThe `CodeVisitor` class is a custom visitor implementation that inherits from `ast.NodeVisitor`. It visits each node in an AST (Abstract Syntax Tree) to extract details about functions, classes, and constants. The `get_python_file_details` function uses this class to traverse the AST of a Python file and returns a dictionary containing information such as function names, definitions, inputs, outputs, calls, etc. It also includes the entire code graph in the returned details using the `code_graph` function. "
    },
    {
        "instruction": "Inputs to `remove_docstring` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)",
        "output": "Inputs to `remove_docstring`:code\n\nPurpose and Significance:\nThe `remove_docstrings()` function removes top-level docstrings, docstrings inside functions and class defs as well as all other comments from the given python code string.\r\n\n{inputs to `get_all_calls()`: 'node', 'calls': None}\r\nThis function is used in `CodeVisitor` class to find all function calls recursively in a subtree rooted at the node. It returns a dictionary of all function calls in the subtree with their arguments.\r\n\n{inputs to `CodeVisitor()`: 'code'}\r\nThe `CodeVisitor` class is used to traverse the AST and extract details about functions, classes, constants, and other information from the code. It inherits from `ast.NodeVisitor`. The `visit_FunctionDef()`, `visit_ClassDef()`, and `extract_details()` methods are implemented in this class.\r\n\n{inputs to `code_graph()`: 'file_summary'}\r\nThis function is used to construct a directed graph with nodes and edges using networkx library. It defines elements such as function nodes, class nodes, and method nodes, and specifies relationships between them.\r\n\n{inputs to `get_python_file_details()`: 'file_path'}\r\nThe `get_python_file_details()` function is used to extract information from a Python file using the AST and the `CodeVisitor` class. It includes the entire code graph in the returned details, which contains all functions, classes, constants, and their relationships. "
    },
    {
        "instruction": "Inputs to `get_all_calls` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict",
        "output": "Inputs to `get_all_calls`:node, calls\n\nPurpose and Significance:\nThe purpose of the '{'Inputs to `get_all_calls`' function is to extract all the function calls from a node of type ast.AST and its children nodes recursively. The `calls` parameter is an optional argument that accumulates the found function calls in a list, which will be used as an output for this function.\r\n\nSignificance: This function is used by the `code_graph` function to identify all function calls in a given node of type ast.AST and its children nodes recursively. It also handles class attributes and lambda functions that are present within the code. "
    },
    {
        "instruction": "Inputs to `get_python_file_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details = get_code_graph(file_details)\n    return file_details",
        "output": "Inputs to `get_python_file_details`:file_path\n\nPurpose and Significance:\nThe `get_python_file_details` function takes a file path as input, reads the contents of the file using `open()` method, and then uses the `ast.parse()` method to create an Abstract Syntax Tree (AST) from the code. It then creates an instance of the `CodeVisitor` class with the source code as input and calls its `analyze()` method to populate a dictionary called `file_info` with various details about the file. Finally, it calls the `get_code_graph` function to construct a directed graph with nodes and edges using networkx library representing all function/class definitions in the given file along with their call relationships.\r\n\n```python\r\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\r\n    \"\"\"\r\n    Extract details from a Python file. \r\n    Args:\r\n        file_path (str): The path to the Python file.\r\n    Returns:\r\n        Dict[str, Union[Dict, str]]: The details extracted from the file. "
    },
    {
        "instruction": "Docstring of `remove_docstring` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)",
        "output": "Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed."
    },
    {
        "instruction": "Docstring of `get_all_calls` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict",
        "output": "Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments."
    },
    {
        "instruction": "Docstring of `get_python_file_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details = get_code_graph(file_details)\n    return file_details",
        "output": "Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file."
    },
    {
        "instruction": "Calls made in `remove_docstring` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)",
        "output": "Calls made in `remove_docstring`:ast.parse, isinstance, tree.body.pop, ast.walk, node.body.pop, ast.unparse\n\nPurpose and Significance:\nThe purpose of the `remove_docstring` function is to remove docstrings and comments from a given Python code string. It first parses the code into an AST using `ast.parse`, then checks if the first element in the body of the tree is an expression node containing a string literal (a docstring). If it is, it removes that node from the list of body nodes. Then, it recursively traverses the tree to find all function calls and class attributes and removes any corresponding docstrings. Finally, it returns the sanitized code as a string using `ast.unparse`.\n\nThe `get_all_calls` function is used by the `CodeVisitor` class to extract information about function calls in the AST. It takes an AST node and recursively searches for all function calls, including those in classes, list comprehensions, and lambda functions. The results are stored as a dictionary with function names as keys and their arguments as values.\n\nThe `CodeVisitor` class inherits from `ast.NodeVisitor` to traverse the AST and extract details about the code. It has methods for visiting function definitions (`visit_FunctionDef`), class definitions (`visit_ClassDef`), and generic nodes (`generic_visit`). The `extract_details` method is used to gather information about a given node, such as name, source code, docstring, input parameters, defaults, return statements, annotations, variable assignments, calls, call inputs, properties, etc.\nThe `analyze` method visits each node of the AST and populates a dictionary (`file_info`) with various details about the file: functions, classes, dependencies (imported modules), constants, function summary, class summary, and simplified code without docstrings or comments. It also keeps track of the current class context using the `current_class` attribute to handle nested classes correctly.\nThe `code_graph` function constructs a directed graph with nodes and edges representing functions, classes, methods, and calls between them using the networkx library. The resulting dictionary represents the code call graph.\nFinally, the `get_python_file_details` function takes a file path as input, reads in the contents of the file, removes docstrings using `remove_docstring`, and extracts information about functions, classes, dependencies, constants, and the code call graph using the `CodeVisitor` class. It returns all this information in a dictionary encompassing the extracted file details. "
    },
    {
        "instruction": "Calls made in `get_all_calls` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict",
        "output": "Calls made in `get_all_calls`:isinstance, calls.append, ast.unparse, get_all_calls, ast.iter_child_nodes, calls_dict[func].extend\n\nPurpose and Significance:\nThe purpose of these objects within the code is to provide a list of all function calls in the provided AST and their arguments. \n\nSignificance: These objects are used by `get_all_calls` function to traverse through the AST and find all function calls in the subtree rooted at the node, including those in class attributes, list comprehensions, and lambda functions. It then creates a dictionary of these function calls with their arguments.\r\n\nThe 'Calls made in `get_all_calls`': 'isinstance, calls.append, ast.unparse, get_all_calls, ast.iter_child_nodes, calls_dict[func].extend' refers to the methods called within this function to achieve this functionality.\r\n\nIn `get_python_file_details`, `ast.parse` is used to parse the source code into an AST and `CodeVisitor` class is instantiated with the input file as a string argument. The `visit_FunctionDef` method of this class is called recursively on each function node in the AST, which extracts details about functions using the `extract_details` method. Similarly, `visit_ClassDef` is called for classes to gather information about classes. \r\n\nIn the `extract_details` method, we check if there's a docstring present and then extract it from the node. We also get all function inputs, defaults, returns, calls, call inputs, variables, decorators, annotations, properties, class attributes and inheritance using AST walker methods. The dictionary `details` contains these information as values.\r\n\nIn `analyze` method, we traverse the AST to capture various code details such as function names, docstrings, inputs, returns, calls, call inputs, variables, decorators, annotations, class attributes and inheritance. We also get constants by visiting Assign nodes in the module level of the AST.\r\n\nFinally, we populate `file_info` dictionary with all these details and return it along with function and class dictionaries. "
    },
    {
        "instruction": "Calls made in `get_python_file_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details = get_code_graph(file_details)\n    return file_details",
        "output": "Calls made in `get_python_file_details`:open, f.read, ast.parse, logging.warning, CodeVisitor, visitor.analyze, get_code_graph\n\nPurpose and Significance:\nThe `remove_docstring` function is used to remove docstrings and comments from the provided Python code source code.\r\n\n`get_all_calls` recursively finds all function calls in the subtree rooted at the given node. It takes an AST node as input and returns a dictionary of all function calls in that subtree along with their arguments.\r\n\nThe `CodeVisitor` class is used to traverse the Abstract Syntax Tree (AST) of the Python code and extract details about functions, classes, and methods. It inherits from `ast.NodeVisitor`. The following are the important methods in this class:\r\n- `visit_FunctionDef`: This method visits a function node in the AST and gathers details such as name, code, docstring, inputs, defaults, returns, calls, call inputs, variables, decorators, annotations, and properties.\r\n- `visit_ClassDef`: This method visits a class node in the AST and gathers details about classes. It also sets the current context to be inside a class when visiting its members by updating `current_class`.\r\n- `generic_visit` is a utility method for handling child nodes recursively, if not overwritten it visits all children of the node.\r\n- `extract_details`: This method extracts details about a given AST node based on its type. It returns a dictionary containing information such as name, code, docstring, inputs, defaults, returns, calls, call inputs, variables, decorators, annotations, and properties.\r\n- `analyze` is the main method that populates the `file_info` attribute with details about the file. It visits all nodes in the AST and gathers information using the above methods.\r\n\nThe `code_graph` function takes the file summary as input and constructs a directed graph using NetworkX library. It defines elements such as function nodes, class nodes, and method nodes. Edges are specified to represent relationships between them. The code call graph is returned in dictionary representation.\r\n\nThe `get_python_file_details` function takes a file path as input, extracts information from the Python file using AST and the `CodeVisitor` class, and includes the entire code graph in the returned details.\r\n\nAll these functions are used to extract information about a given Python source code file. "
    },
    {
        "instruction": "Variables defined in `remove_docstring` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)",
        "output": "Variables defined in `remove_docstring`:first_body_node, tree\n\nPurpose and Significance:\nThe `remove_docstring` function is used to remove docstrings from a given Python source code. It takes a string as input and returns the sanitized code without any docstrings or comments. The `get_all_calls` function is used to find all function calls in a subtree rooted at a node of type ast.AST. The `CodeVisitor` class inherits from `ast.NodeVisitor` and implements methods to gather details about functions, classes, and the entire file. The `code_graph` function constructs a directed graph with nodes and edges using networkx library. It defines elements such as function nodes, class nodes, and method nodes, and specifies relationships between them. Finally, the `get_python_file_details` function extracts information from Python files using the AST and the `CodeVisitor` class to include the entire code graph in the returned details dictionary. "
    },
    {
        "instruction": "Variables defined in `get_all_calls` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict",
        "output": "Variables defined in `get_all_calls`:calls, calls_dict\n\nPurpose and Significance:\nThe `get_all_calls` function is used to find all function calls in a given AST node. It returns a dictionary containing the name of each function call and its arguments as a list. The `CodeVisitor` class is used to traverse the AST and extract details about functions, classes, and their methods. The `extract_details` method is used to extract information such as docstrings, inputs, defaults, return values, decorators, etc., from each node type (functions, classes, or methods). The `analyze` method is used to traverse the AST and populate a dictionary with all of the details about the file. The `code_graph` function is used to construct a directed graph using networkx library, representing nodes and edges for functions, classes, and methods. Finally, the `get_python_file_details` function uses these objects to extract information from a Python file and includes the entire code call graph in the returned details dictionary. "
    },
    {
        "instruction": "Variables defined in `get_python_file_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details = get_code_graph(file_details)\n    return file_details",
        "output": "Variables defined in `get_python_file_details`:file_details, code, tree, visitor\n\nPurpose and Significance:\nThe `get_python_file_details` function is responsible for extracting information about a Python file using the AST and the `CodeVisitor` class. It returns a dictionary that contains the entire code graph, including functions, classes, and method calls within the source code. "
    },
    {
        "instruction": "Returns from `remove_docstring` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)",
        "output": "Returns from `remove_docstring`:ast.unparse(tree)\n\nPurpose and Significance:\nThe function `remove_docstring()` removes docstrings from the provided Python code by traversing the Abstract Syntax Tree (AST). It returns the sanitized code string with docstrings and comments removed.\r\n\n{'Returns from `get_all_calls`': 'Dict[str, List[str]]'}: This function recursively finds all function calls in the subtree rooted at the node. It returns a dictionary of all function calls in the subtree rooted at the node with their arguments.\r\n\nThe keys of the dictionary are strings representing the name of each function call and values are lists containing arguments for each call. This is useful when analyzing the relationships between different functions in the code.\r\n\n{'Returns from `CodeVisitor.__init__`': 'None'}: The `__init__()` method initializes a new instance of the class with the source code provided as an argument.\r\n\n{'Returns from `visit_FunctionDef`': 'None'}: This method extracts details about functions by traversing the AST using `self.extract_details()` method and updates `self.functions` dictionary accordingly. If `self.current_class` is not None, it means we are inside a class definition and so it updates the `self.classes` dictionary with the function name as a key and its details as a value.\r\n\n{'Returns from `visit_ClassDef`': 'None'}: This method extracts details about classes by traversing the AST using `self.extract_details()` method and updates `self.classes` dictionary accordingly. It also sets `self.current_class` to the name of the class being visited for which further attribute visit can take place. This resets once exit from that node has been detected in order to find callers only at file-level or another nested class.\r\n\n{'Returns from `extract_details`': 'Dict[str, Union[str, List[str]]]'}: This method extracts details about a node and returns a dictionary with the following keys:\r\n\n- `'function_name'` (or `'class_name'`) representing the name of the function or class.\r\n- `'function_code'` (or `'class_code') representing the code for that function or class.\r\n- `'function_docstring'` (or `'class_docstring')` representing the docstring for that function or class, if any.\r\n- `'function_inputs'` (or `'class_attributes'`) representing a list of input arguments to the function or attributes defined in the class.\r\n- `'function_defaults'` representing default values for the inputs to the function, if any.\r\n- `'function_returns'` representing return statements within the function definition. It returns a string representation of the code instead of the actual AST node for readability purposes.\r\n- `'function_calls'` (or `'class_methods'`) representing all functions called by this function or class respectively\r\n- `'function_call_inputs` represents dictionaries that have callee: inputs mappings in string representation as the key: value pair, and calls to self.variable attributes of a class as the values.\r\n- `'class_static_methods'` representing all static methods defined in the class, if any.\r\n\n{'Returns from `CodeVisitor.visit`': 'None'}: This method is called by `generic_visit()` whenever there is no specific visitor implemented for a particular node type and just visits each child node recursively to ensure AST traversal. \r\n\n{'Returns from `analyze`': 'None'}: This method populates the `self.file_info` dictionary with details about the file by visiting the `node`. The relevant visitor methods (like `visit_FunctionDef`) will get called in a nested structure when a `Module` node is traversed and so we can use it to traverse all nodes of interest.\r\n\n{'Returns from `code_graph`': 'Dict[str, Dict]'}: This function constructs a directed graph with nodes and edges using the networkx library. It defines elements such as function nodes, class nodes, and method nodes and specifies their relationships based on the information extracted by the `CodeVisitor` class.\r\n\n{'Returns from `get_python_file_details`: 'Dict[str, Union[Dict, str]'}: This is the main entry point to get all the file details including function names, class names, and their attributes. It takes a file path as an argument, reads the code using `open()` method, removes docstrings using `remove_docstring()` and constructs AST from the code. The CodeVisitor instance is used to traverse the AST and 'file_info' can be retrieved using the `file_info` attribute. This includes a dictionary representation of the code call graph constructed by the `get_code_graph` function. Finally, it returns a dictionary encompassing all extracted file details.\r\n\nThe purpose of these objects is to provide a way to extract information about Python source code and represent it in a structured format that can be used for further analysis or visualization. The `CodeVisitor` class is responsible for extracting details such as function, class names, arguments, defaults, returns, etc., from the AST, while the `code_graph` function is responsible for generating call-dependency relationships using `networkx`.\r\n "
    },
    {
        "instruction": "Returns from `get_all_calls` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict",
        "output": "Returns from `get_all_calls`:calls_dict\n\nPurpose and Significance:\nThis code contains some basic data types used for Python source code analysis, including a function to remove docstrings and comments from a given string, another function to recursively find all function calls in an AST node, a class `CodeVisitor` that inherits from `ast.NodeVisitor`, and a function `code_graph` which constructs a directed graph using networkx library. The purpose of this code is to provide a way to extract file details from Python source code and generate a call graph for the code. "
    },
    {
        "instruction": "Returns from `get_python_file_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details = get_code_graph(file_details)\n    return file_details",
        "output": "Returns from `get_python_file_details`:file_details, None\n\nPurpose and Significance:\nThe function `get_python_file_details()` returns a dictionary with four keys. \r\n- `'file_info'`: This key contains information about the file such as its code, AST, dependencies, functions, classes, constants and summary.\r\n- `'functions'`: This key contains details about all the functions in the file.\r\n- `'classes'`: This key contains details about all the classes in the file.\r\n- `file_graph` is generated by the function `code_graph()` from `get_python_file_details()['file_info']['functions'], get_python_file_details()['file_info']['classes'] and get_python_file_details()['file_info']['constants']`. This key contains a dictionary representation of the code call graph, which includes nodes and edges. The function calls are represented as nodes, and their relationships with other functions and classes are defined by edges.\r\n\n### Explanation: \r\nThe `get_python_file_details()` function is responsible for extracting information about a Python file using the AST and the `CodeVisitor` class. It accepts a file path as an argument, opens the file in read mode with UTF-8 encoding, reads its contents and uses it to generate a Python Abstract Syntax Tree (AST) which is used to extract various details from the source code. These include: \r\n- Removing docstrings and comments using `remove_docstring()` function.\r\n- Finding all function calls in the AST using `get_all_calls()` function.\r\n- Traversing the AST using `CodeVisitor` class to extract details about functions, classes, their methods, attributes, annotations, static methods, and constants. \r\n- Constructing a directed graph with nodes and edges using networkx library to represent the code call graph. \r\n\nThe `file_details` dictionary returned by this function contains all these extracted information along with the simplified version of the source code without docstrings.\r\n\nIn summary, `get_python_file_details()` is responsible for extracting file details such as code, AST, dependencies, functions, classes, constants and a call graph. "
    },
    {
        "instruction": "Methods defined in `CodeVisitor` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Methods defined in `CodeVisitor`:visit_FunctionDef, visit_ClassDef, generic_visit, visit_Assign, extract_details, analyze\n\nPurpose and Significance:\nThe `remove_docstring` function removes docstrings and comments from a given Python source code string. It is used to remove the top-level module docstring and any docstrings in functions, classes, or async functions.\r\n\nThe `get_all_calls` function recursively finds all function calls in an AST subtree rooted at a given node. It returns a dictionary of function calls with their arguments as lists.\r\n\nThe `CodeVisitor` class is used to traverse the Abstract Syntax Tree (AST) and extract details about the code. It inherits from `ast.NodeVisitor`. The following methods are defined in it:\r\n- `visit_FunctionDef`: Extracts information about a function.\r\n- `visit_ClassDef`: Extracts information about a class.\r\n- `extract_details`: Extracts details about a given node and returns them as a dictionary.\r\n- `analyze`: Traverses the AST to populate the `file_info` attribute with various code details.\r\n\nThe `code_graph` function constructs a directed graph using networkx library, defining nodes for functions, classes, and methods. It also specifies edges between them based on their relationships (calls). \r\n\nThe `get_python_file_details` function is used to extract information about the file, including details about all functions, classes, and constants.\r\n- First, it attempts to open the given Python file at the provided path and read its contents into a string. If there are any permission or syntax errors during this process, an error message will be logged and `None` is returned.\r\n- The AST for the code is generated using `ast.parse`. \r\n- Then, the `remove_docstring` function is called to remove docstrings from the source code.\r\n- An instance of the `CodeVisitor` class is created with the sanitized code as input.\r\n- The `analyze` method is called on this visitor to traverse the AST and populate `file_info`, which will hold various information about the file (including function names, their locations, arguments, and any called functions).\r\n- Finally, the `code_graph` function is called with the `file_info` dictionary as input. It constructs a directed graph and returns it in dictionary format along with all function/class/method calls. \r\n\nOverall, the purpose of these objects is to provide useful information about Python source code, including:\r\n- Function names, locations, arguments, return values, docstrings, and called functions.\r\n- Class names, methods within each class, their input/output types, inheritance relationships, static method status, etc.\r\n- Any constants or globals defined in the file. \r\n- A call graph showing how functions are related to one another (e.g., which function calls other functions). "
    },
    {
        "instruction": "Docstring of `CodeVisitor` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file."
    },
    {
        "instruction": "Attributes of `CodeVisitor` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Attributes of `CodeVisitor`:current_class, current_class, file_info\n\nPurpose and Significance:\nThe attributes of `CodeVisitor` class are used to maintain the context for functions and classes. The `current_class` attribute keeps track of which class we're currently visiting when processing nodes within a `ClassDef`, so that function definitions nested in classes get attributed to the relevant class object instead of being added as top-level functions. The `file_info` dictionary is used to store information about the file, such as the code itself and its dependencies. "
    },
    {
        "instruction": "Variables defined in `CodeVisitor` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Variables defined in `CodeVisitor`:file_dependencies, attributes, function_defs, class_defs, constant_assignment, details, call_data, value, value_repr, node_walk, method_defs\n\nPurpose and Significance:\nThe purpose of these objects within the code is as follows:\r\n- `file_dependencies`: This is a list that contains all the modules imported in the Python file.\r\n- `attributes`: A dictionary that stores class attributes defined using self.attribute notation inside the classes.\r\n- `function_defs`: A dictionary that stores information about each function definition found in the code, including its inputs, calls made within it, and other properties.\r\n- `class_defs`: List containing multiple dictionaries which has method_names, and all related methods present under class defined by `{method_name: {inputs, calls, call_inputs, returns}`.\r\n- `constant_assignment`: A list that stores the constants assigned in the Python file.\r\n- `details`: This is a dictionary that contains various information about functions and classes like name, code, docstring, inputs, defaults, returns, etc. \r\n- `call_data`: It is a dictionary of all function calls found in the subtree rooted at the node with keys as function names and values as lists of arguments passed to them.\r\n- `value` and `value_repr`: These are used to extract docstrings from the code.\r\n- `node_walk`: This is an iterator that traverses through all nodes in the AST. \r\n- `method_defs`: A dictionary containing information about methods defined inside a class, such as inputs, calls made within it, and other properties. "
    },
    {
        "instruction": "Inheritance of `CodeVisitor` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Inheritance of `CodeVisitor`:ast.NodeVisitor\n\nPurpose and Significance:\nThe `CodeVisitor` class inherits from `ast.NodeVisitor`, which is a base class for creating visitors that walk the abstract syntax tree (AST) of Python modules and translate or transform them.\r\n\n`get_all_calls()` finds all function calls in a subtree rooted at `node` and returns a dictionary mapping each function call to its arguments. It also handles class attributes, list comprehensions, and lambda functions.\r\n\n`remove_docstring()` removes docstrings from the provided Python code, including top-level module docstrings and docstrings for functions, classes, and async functions.\r\n\n`CodeVisitor` is a custom visitor class that inherits from `ast.NodeVisitor`. It visits each node in an AST to extract details about functions, classes, and constants defined in the code. The `analyze()` method populates the `file_info` dictionary with information about the file.\r\n\n`code_graph()` constructs a directed graph using networkx library to represent the relationships between nodes (functions, classes, methods) and edges (calls). It returns a dictionary representation of the code call graph. \r\n\n`get_python_file_details()` extracts information from Python files using `CodeVisitor` class and includes the entire code graph in the returned details.\r\n\nThe purpose of these objects is to provide a way to analyze Python source code, extract function definitions, class definitions, and their respective attributes, methods, constants, dependencies, and call graph. "
    },
    {
        "instruction": "Inputs to `__init__` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def __init__(self, code: str):\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None\n    self.constants: List[str] = []",
        "output": "Inputs to `__init__`:self, code\n\nPurpose and Significance:\nThe input signature for `remove_docstring()` function is a string containing python source code. It removes docstrings and comments from the provided Python code using the ast module in the code.\r\n\nThe input signature of `get_all_calls` function takes an AST node as its argument, and returns a dictionary containing all function calls found within the subtree rooted at that node along with their arguments. \r\n\n`CodeVisitor` class inherits from ast.NodeVisitor which is used to traverse the Abstract Syntax Tree (AST) of Python code and extract details about functions, classes and constants. The `__init__()` method takes in a string argument `code`, representing the source code being parsed by this visitor. It has three attributes - `functions` to store information about all functions found in the code, `classes` to store information about all classes found in the code, and `file_info` which stores details about the file.\r\n\nThe `visit_FunctionDef()` method is called when a function definition node is encountered while traversing the AST. It extracts various details such as function name, docstring, input parameters, default values of parameters, return types, calls made within the function, and variables used in the function using the `extract_details()` method.\r\n\nThe `visit_ClassDef()` method is called when a class definition node is encountered while traversing the AST. It extracts various details such as class name, docstring, input parameters for `__init__` method, and calls made within the class using the `extract_details()` method.\r\n\nThe `visit_Assign()` method is called when an assignment statement is encountered while traversing the AST. It extracts all constants defined in the module level.\r\n\nThe `generic_visit()` method is used to traverse the AST and visit all child nodes of a given node.\r\n\nThe `extract_details()` method takes in an AST node and its type as input, and returns a dictionary containing various details about that node. It extracts the name of the function/class, code snippet for the same, docstring if any, inputs, default values for parameters (in case of functions), return types or None for methods (None for classes).\r\n\nThe `analyze()` method is called to traverse the AST and populate the `file_info` dictionary with various details about the file. It visits all nodes in the AST and extracts dependencies, function names, class names, constants defined in the module level, and calls made within the functions and classes.\r\n\nThe `code_graph()` method is responsible for generating a code graph of functions called from different sources - global or non-local level functions as well as from functions of same classes and base class functions that are used.\r\n\nLastly, `get_python_file_details()` function takes in the file path as input, reads the contents of the file using `open()` method, removes docstrings and comments using `remove_docstring()`, parses the code into an AST using `ast.parse()` method, and then visits it using a `CodeVisitor` instance to extract all relevant information.\r\n\nAll this information is returned in a dictionary encompassing the file details. "
    },
    {
        "instruction": "Inputs to `visit_FunctionDef` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)",
        "output": "Inputs to `visit_FunctionDef`:self, node\n\nPurpose and Significance:\nThe purpose of the function is to visit a node in an AST tree. It visits each child node recursively and sets the parent attribute for each node. "
    },
    {
        "instruction": "Inputs to `visit_ClassDef` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "Inputs to `visit_ClassDef`:self, node\n\nPurpose and Significance:\nThe `visit_ClassDef` method is a method from the `ast.NodeVisitor` class that takes two arguments: `self` and `node`. "
    },
    {
        "instruction": "Inputs to `generic_visit` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)",
        "output": "Inputs to `generic_visit`:self, node\n\nPurpose and Significance:\nThe input parameters for generic_visit are self and node. "
    },
    {
        "instruction": "Inputs to `visit_Assign` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)",
        "output": "Inputs to `visit_Assign`:self, node\n\nPurpose and Significance:\nThe purpose of the input parameters in `visit_Assign(node)` is to allow the function to access the current instance of the class (`self`) and the node being visited. The `node` parameter represents a single node in the Abstract Syntax Tree (AST) that was generated from the source code using the `ast.parse()` method. This allows us to extract information about the variable assignments within the AST, such as constants or variables. "
    },
    {
        "instruction": "Inputs to `extract_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "Inputs to `extract_details`:self, node, node_type\n\nPurpose and Significance:\nIn `extract_details` function definition:\n\n`node` : the argument provided for getting the details. \nIt's an AST object of type ast.AST.\n\n`node_type`: It specifies the type of the node (function, method or class) to which we are extracting the details. \nThis is used to differentiate between different types of nodes and create a dictionary with relevant keys for each node type. \n\n### Purpose:\nThe `extract_details` function takes an AST object as input and returns a dictionary containing information about that particular node. The dictionary contains the following details:\n- Name of the node (function or class)\n- Code representation of the node\n- Docstring of the node if present\n- Inputs to the node (if it's a function or method)\n- Default values for inputs if any\n- Return types of the node (if it's a function or method)\n- Calls made within the node\n- Variables defined in the node\n- Decorators used on the node\n- Annotations used in the node\n- Properties of the class (attributes defined as self.attribute) if it's a class node\n\n### Significance:\nThis function is called recursively to extract details about all nodes in the AST and store them in `functions` or `classes` dictionary based on their type (function, method or class). The `analyze` function then uses these dictionaries to populate the `file_info` dictionary with information about the file. "
    },
    {
        "instruction": "Inputs to `analyze` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = []\n    for class_name, class_details in self.classes.items():\n        method_defs = {}\n        for method_name, details in class_details.items():\n            if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n        class_defs.append({class_name: {'method_defs': method_defs}})\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Inputs to `analyze`:self, node\n\nPurpose and Significance:\nThe `analyze` method is a method defined in the `CodeVisitor` class. It takes an AST node as input and traverses it recursively to extract details about the code. It populates the `file_info` dictionary with various information such as function names, their inputs, return types, default arguments, annotations, calls, call inputs, and constants in a Python file.\r\n\n'self': an instance of the `CodeVisitor` class that is used to store all the extracted details about functions, classes, and other attributes of the code. \r\n\n'node': The AST node from which we start the traversal. This represents the entire code and is the root of the tree. "
    },
    {
        "instruction": "Docstring of `__init__` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def __init__(self, code: str):\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None\n    self.constants: List[str] = []",
        "output": "Initialize a new instance of the class.\n        Args:\n            code: str: The source code."
    },
    {
        "instruction": "Docstring of `visit_FunctionDef` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)",
        "output": "Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit."
    },
    {
        "instruction": "Docstring of `visit_ClassDef` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit."
    },
    {
        "instruction": "Docstring of `generic_visit` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)",
        "output": "Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit."
    },
    {
        "instruction": "Docstring of `visit_Assign` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)",
        "output": "Get self.constants \n        Args:\n            node: ast.Assign: The node to visit."
    },
    {
        "instruction": "Docstring of `extract_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node."
    },
    {
        "instruction": "Docstring of `analyze` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = []\n    for class_name, class_details in self.classes.items():\n        method_defs = {}\n        for method_name, details in class_details.items():\n            if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n        class_defs.append({class_name: {'method_defs': method_defs}})\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze."
    },
    {
        "instruction": "Calls made in `visit_FunctionDef` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)",
        "output": "Calls made in `visit_FunctionDef`:self.extract_details, self.generic_visit\n\nPurpose and Significance:\nThe purpose of the `'Calls made in visit_FunctionDef': 'self.extract_details, self.generic_visit'` is to find all function calls that are inside the function and update `calls` dictionary by calling `get_all_calls` method recursively.\r\n\n`'Calls made in visit_ClassDef': 'self.classes[node.name] = self.extract_details, self.generic_visit'`. The purpose of this is to extract details about the class and its methods by calling `self.extract_details` method and then traverse through all nodes recursively using `self.generic_visit` method.\r\n\n`'Calls made in generic_visit': 'child.parent = node'. This line sets the parent attribute of each child node to the current node that is being visited. This is used later on when we need to traverse upwards from a node to its parent and check for certain conditions.` "
    },
    {
        "instruction": "Calls made in `visit_ClassDef` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "Calls made in `visit_ClassDef`:self.extract_details, self.generic_visit\n\nPurpose and Significance:\nThe `visit_ClassDef` method is used to extract details about classes in the AST. It calls the `extract_details` function and then sets the current class context using `self.current_class`. The `generic_visit` method is called recursively on all child nodes of the ClassDef node to traverse the entire subtree rooted at that node. "
    },
    {
        "instruction": "Calls made in `generic_visit` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)",
        "output": "Calls made in `generic_visit`:ast.iter_child_nodes, self.visit\n\nPurpose and Significance:\nThe `self.visit(node)` method is called recursively to traverse all nodes in the AST (Abstract Syntax Tree) and visit each node. The `ast.iter_child_nodes` function is used to iterate over all child nodes of a given node, which are then visited using the `generic_visit` method. This allows us to traverse the entire tree and extract details about functions, classes, and other elements in the code. "
    },
    {
        "instruction": "Calls made in `visit_Assign` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)",
        "output": "Calls made in `visit_Assign`:isinstance, ast.unparse, self.constants.append, self.generic_visit\n\nPurpose and Significance:\nThe function `remove_docstring()` is a helper function that removes docstrings and comments from the provided Python code using an AST object to identify them. \n\nThe `get_all_calls()` function is responsible for identifying all the functions calls within a given node of the AST, including those in class attributes, list comprehensions, and lambda functions. It returns a dictionary with keys as the function names and values as their arguments.\n\nThe `CodeVisitor` class inherits from `ast.NodeVisitor` to traverse the AST and extract details about the code. The `visit_FunctionDef()` method is responsible for gathering information about functions, while the `visit_ClassDef()` method is responsible for gathering information about classes. The `extract_details()` method handles extracting information about a given node. It takes an AST object and a node type as input (function or class) and returns a dictionary of details extracted from it. \n\nThe `code_graph()` function creates a directed graph representing the call structure of functions in a file, based on their relationship with other nodes. This function requires information about classes, functions, and calls made within them to construct the graph. It uses the networkx library to create nodes and edges that represent each component's relationship to each other.\n\nThe `get_python_file_details()` function takes a file path as input and extracts information from the Python file using the AST and the `CodeVisitor` class. It includes the entire code graph in the returned details dictionary, which is constructed by calling the `code_graph()` function with the extracted file summary. "
    },
    {
        "instruction": "Calls made in `extract_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "Calls made in `extract_details`:list, ast.walk, get_all_calls, ast.unparse, next, isinstance, call_data.keys, set, self.classes[self.current_class].setdefault('class_attributes, []).extend, self.classes[self.current_class].setdefault, details.update, any\n\nPurpose and Significance:\nThe purpose of the `remove_docstring` function is to remove docstrings and comments from a given Python code string. It does this by parsing the AST tree of the code using `ast.parse`, then removing top-level module docstrings and docstrings in functions, classes, and async functions. The resulting sanitized code is returned as a string.\r\n\nThe `get_all_calls` function recursively finds all function calls in an AST subtree rooted at the given node. It does this by checking if each node is an instance of `ast.Call`, and then extracting the name and arguments of the called functions. If it encounters a class definition, it looks for assignments to attributes within that class.\r\n\nThe `CodeVisitor` class inherits from `ast.NodeVisitor` and implements methods for visiting various AST nodes such as function definitions (`visit_FunctionDef`), class definitions (`visit_ClassDef`), and generic node visits (`generic_visit`). It also has an instance variable called `file_info`, which will contain details about the file once all AST nodes have been visited. The `extract_details` method extracts various information from a given node, such as its name, code representation, docstring, inputs, defaults, returns, calls, and variables.\r\n\nThe `code_graph` function constructs a directed graph using the `networkx` library based on the provided file summary. It creates nodes for functions, classes, methods, and attributes and edges between them based on their call relationships. Finally, it returns a dictionary representation of the code call graph.\r\n\nThe `get_python_file_details` function takes a file path as input and uses the AST to extract details about the code using the `CodeVisitor` class. It then includes the entire code graph in the returned details by calling `get_code_graph`. "
    },
    {
        "instruction": "Calls made in `analyze` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = []\n    for class_name, class_details in self.classes.items():\n        method_defs = {}\n        for method_name, details in class_details.items():\n            if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n        class_defs.append({class_name: {'method_defs': method_defs}})\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node))}",
        "output": "Calls made in `analyze`:self.visit, list, ast.walk, isinstance, self.functions.items, self.classes.items, class_details.items, method_name.startswith, len, class_defs.append, self.functions.keys, self.classes.keys, remove_docstring, ast.unparse\n\nPurpose and Significance:\nThe `remove_docstring` function is used to remove docstrings and comments from the provided Python code source string.\r\n\n`get_all_calls` recursively finds all function calls in the subtree rooted at a given node. It accepts an AST node as input, checks if it's an instance of `ast.Call`, which is when we find a function call. Then it iterates over its arguments and adds them to a dictionary called `calls_dict`. This dictionary maps each function name to the list of arguments passed in that call.\r\n\n`CodeVisitor` is used by the `analyze()` method, inherited from the base class `ast.NodeVisitor`, which performs AST traversal over nodes in the source code and extracts details about functions, classes, and their methods. It has attributes `code`, `functions`, `classes`, and `file_info`. The `visit_FunctionDef` method is called when a function definition node is encountered, and it populates the `functions` dictionary with information about that function. Similarly, `visit_ClassDef` is called for class definitions and updates the `classes` dictionary. It also sets the `current_class` attribute to indicate which class we're currently inside.\r\n\nThe `extract_details` method takes an AST node as input and returns a dictionary of details about that node, such as its name, code representation, docstring, inputs, defaults, outputs, calls, call inputs, variables, decorators, annotations, and properties. It also handles class-specific attributes like class methods, static methods, and inheritance.\r\n\nThe `analyze` method is called on the root node of the AST to populate the `file_info` dictionary with details about the file as a whole. It visits all nodes in the AST using `generic_visit`, which calls `visit()` on each child node and sets their `parent` attribute for back-references. When we reach a node representing an Assign, we look at it more carefully to gather all variables and constants declared in the module.\r\n\nThe `code_graph` function uses networkx library to construct a directed graph with nodes and edges based on the file details provided by `get_python_file_details`. It defines nodes for functions, classes, and methods, and specifies their relationships using edges. The graph is returned as a dictionary representation.\r\n\nThe `get_python_file_details` function takes a file path as input, reads in the code from that file, parses it into an AST using `ast.parse`, creates a new instance of `CodeVisitor`, and calls its `analyze()` method to populate `visitor.file_info` with file details and updates both dictionaries for function names and classes found by walking through the code. The sanitized, removed-docstring code is stored in `file_details['file_code_simplified']`. Finally, it calls `get_code_graph()` to construct a graph representation of the code call hierarchy.\r\n\nThe purpose of these objects within the code is as follows: \r\n1. 'remove_docstring' function removes docstrings and comments from Python source code\r\n2. 'Calls made in `analyze`': `self.visit`, `list(ast.walk)`, `isinstance()`, `self.functions.items`, `self.classes.items`, `class_details.items`, `method_name.startswith()`, `class_defs.append()`, `self.functions.keys`, and `self.classes.keys` are used to traverse the AST, gather details about functions and classes, and update their respective dictionaries.\r\n3. 'get_code_graph' function constructs a directed graph using networkx library, defines nodes and edges, and specifies relationships between them. It also returns a dictionary representation of the code call hierarchy. "
    },
    {
        "instruction": "Returns from `extract_details` in Python file: `py2dataset.get_python_file_details.py`?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "Returns from `extract_details`:details\n\nPurpose and Significance:\nThe `get_python_file_details` function is responsible for extracting all details related to a given Python source code file, including information about classes, functions, imports, constants, and function calls. The function also uses the `CodeVisitor` class to traverse the Abstract Syntax Tree (AST) of the input code and collects relevant information such as: \r\n1. function definitions (includes docstring and parameters), \r\n2. method/static methods, attributes of a class and\r\n3. variables defined within each function or method.\r\n\nThe `get_all_calls` function is used to extract all the function calls in the code and their arguments. The `remove_docstring` function removes docstrings from the provided Python code. \r\n\nFinally, the `code_graph` function creates a directed graph of the code by specifying nodes and edges representing functions, classes, methods, and calls. This information is included within the output of the `get_python_file_details` function to help understand how different components are related to each other in the source code.\r\n\nThe purpose of this function is to provide a complete representation of the Python file's contents and structure for further analysis or processing. "
    },
    {
        "instruction": "1) Describe the Purpose and Processing summary of Python file: `py2dataset.get_python_file_details.py`; 2) Summarize the Significance of applicable Function, Class, and Method; 3) Explain what each Input, Output, and Variable does in the code.",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n\n    Args:\n        code (str): The source code from which to remove docstrings.\n\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    tree = ast.parse(code)\n\n    # Remove top-level docstring if present\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n\n    Returns:\n        Dict[str, List[str]]: A dictionary mapping function calls (as strings)\n                              to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = [] \n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node  # Set the parent attribute\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants \n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)  \n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": list(\n                {\n                    ast.unparse(target)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Name)\n                }\n            ),\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                ).extend(attributes)\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and subnode.name != \"__init__\"\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n        \n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith(\"class_method_\"):\n                    method_defs[method_name[len(\"class_method_\") :]] = {\n                        \"inputs\": details[\"method_inputs\"],\n                        \"calls\": details[\"method_calls\"],\n                        \"call_inputs\": details[\"method_call_inputs\"],\n                        \"returns\": details[\"method_returns\"],\n                    }\n            class_defs.append({class_name: {\"method_defs\": method_defs}})\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node)),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n    file_details = get_code_graph(file_details)\n    return file_details\n\n```",
        "output": "Purpose of `get_python_file_details`:\r\n- Provides a detailed view of the source Python file through extracting information such as function definitions, class definitions, constants, dependencies, and call graph.\r\n- The `get_python_file_details` function is responsible for extracting all the necessary details from a given Python file using the AST (Abstract Syntax Tree) and the `CodeVisitor` class. It returns a dictionary encompassing the extracted file details, including the entire code call graph.\r\n\nProcessing Summary:\r\n- The function `get_python_file_details` takes in a Python file path as an argument and uses the AST to extract various information about the file.\r\n- It then uses the `CodeVisitor` class to traverse the AST, which inherits from `ast.NodeVisitor`, for obtaining required information on the different components like function and classes within it and calls between these nodes, with attributes defined, parameters accepted etc., based on certain specific rules implemented as requirements.\r\n- The extracted details are then used to construct a directed graph using networkx library which represents the code call graph. Finally, the dictionary representation of the code call graph is returned along with the file information in a single object for further analysis.\r\n\nSignificance of Functions:\r\n- `remove_docstring` function removes docstrings and comments from the provided Python code.\r\n- `get_all_calls` function recursively finds all function calls in the subtree rooted at the node, including those in class attributes, list comprehensions, and lambda functions.\r\n- `CodeVisitor` class inherits from `ast.NodeVisitor` to traverse the AST and extract information about classes and functions present within a file, handling `__init__` method and updating context with regard to classes defined during its execution.\r\n\nFunction Significance:\r\n- `remove_docstring`: Removes docstrings from Python code. It accepts a string as input and returns the sanitized code without docstrings or comments.\r\n- `get_all_calls`: Finds all function calls in the subtree rooted at a given node, including those in class attributes, list comprehensions, and lambda functions.\r\n- `CodeVisitor` is a subclass of ast.NodeVisitor that provides information about the code like classes, functions, constants, dependencies, etc., by traversing the AST and inheriting from it.\r\n\nInputs:\r\n- `file_path`: The path to the Python file being analyzed.\r\nOutputs:\r\n- `file_details`: Dictionary containing information about the file including the entire code call graph.\r\nVariables:\r\n- `file_dependencies`: List of dependencies extracted from the file.\r\n- `function_defs`: List of function definitions found in the file.\r\n- `class_defs`: List of class definitions found in the file.\r\n- `constant_assignment`: String containing constant assignments within a Python file.\r\n- `details`: Dictionary containing information about each function and class.\r\n- `call_data`: Dictionary mapping function calls to their arguments.\r\n- `node_walk`: List of nodes in the AST.\r\n\nSignificance of Classes:\r\n- `CodeVisitor` is a subclass of ast.NodeVisitor that provides information about the code like classes, functions, constants, dependencies, etc., by traversing the AST and inheriting from it.\r\nMethods Significance:\r\n- `visit_FunctionDef`: Extracts details about a function such as name, code, docstring, inputs, defaults, returns, calls, arguments, call inputs, variables, decorators, and annotations. If it's within a class context, the method updates the current class dictionary with the extracted information.\r\n- `visit_ClassDef`: Extracts details about a class such as name, code, docstring, attributes, methods, inheritance, static methods, and call inputs.\r\n- `generic_visit`: Traverses the AST to extract various information from nodes like assignments, imports, etc., and updates the current context with regard to classes defined during its execution.\r\n- `extract_details`: Extracts details about a node based on the provided type such as function, class or module.\r\n- `analyze`: Traverses the AST, populates the file information dictionary, and constructs a directed graph using networkx library. It also maintains a current class context to keep track of classes while traversing the AST.\r\n\nSignificance of Variables:\r\n- `current_class`: Indicates whether we are inside a class definition or not.\r\n- `functions`: Dictionary containing details about functions found in the file.\r\n- `classes`: Dictionary containing details about classes found in the file.\r\n- `file_info`: Final dictionary with information on file contents.\r\n- `file_details`: Returns both file content and graph representation as a dictionary object.\r\n\nThe purpose of this code is to provide an in-depth view of a Python file by extracting relevant information like function definitions, class definitions, dependencies, and call graph. The input parameter for the function is a Python file path and the output returns a dictionary encompassing all the required details about the file including the entire code call graph.\r\n\nThe `remove_docstring` function removes docstrings from the provided Python code by parsing it using AST, while `get_all_calls` recursively finds all function calls in the subtree rooted at a given node. The `CodeVisitor` class inherits from `ast.NodeVisitor` to traverse the AST and extract information about classes and functions present within a file.\r\n\nThe `CodeVisitor` class has methods like `visit_FunctionDef`, `visit_ClassDef`, `extract_details`, and `analyze` that are responsible for populating the `file_info` dictionary with details such as function name, code, docstring, inputs, defaults, returns, calls, arguments, call inputs, variables, decorators, annotations, etc. It also maintains a current class context using the attribute 'current_class' to keep track of classes while traversing the AST.\r\n\nFinally, `get_python_file_details` uses these methods to construct a directed graph with nodes and edges representing functions, classes, and method calls. The function returns this dictionary representation of the code call graph along with the file information. \n{\n    \"Code Elements\": {\n        \"Classes defined\": \"CodeVisitor\",\n        \"Dependencies\": \"get_code_graph, typing, logging, ast\",\n        \"Functions defined\": \"remove_docstring, get_all_calls, get_python_file_details\",\n        \"`CodeVisitor` Attributes\": \"current_class, current_class, file_info\",\n        \"`CodeVisitor` Inheritance\": \"ast.NodeVisitor\",\n        \"`CodeVisitor` Methods\": \"visit_FunctionDef, visit_ClassDef, generic_visit, visit_Assign, extract_details, analyze\",\n        \"`CodeVisitor` Variables\": \"file_dependencies, attributes, function_defs, class_defs, constant_assignment, details, call_data, value, value_repr, node_walk, method_defs\",\n        \"`__init__` Inputs\": \"self, code\",\n        \"`analyze` Calls\": \"self.visit, list, ast.walk, isinstance, self.functions.items, self.classes.items, class_details.items, method_name.startswith, len, class_defs.append, self.functions.keys, self.classes.keys, remove_docstring, ast.unparse\",\n        \"`analyze` Inputs\": \"self, node\",\n        \"`extract_details` Calls\": \"list, ast.walk, get_all_calls, ast.unparse, next, isinstance, call_data.keys, set, self.classes[self.current_class].setdefault('class_attributes, []).extend, self.classes[self.current_class].setdefault, details.update, any\",\n        \"`extract_details` Inputs\": \"self, node, node_type\",\n        \"`extract_details` Returns\": \"details\",\n        \"`generic_visit` Calls\": \"ast.iter_child_nodes, self.visit\",\n        \"`generic_visit` Inputs\": \"self, node\",\n        \"`get_all_calls` Calls\": \"isinstance, calls.append, ast.unparse, get_all_calls, ast.iter_child_nodes, calls_dict[func].extend\",\n        \"`get_all_calls` Inputs\": \"node, calls\",\n        \"`get_all_calls` Returns\": \"calls_dict\",\n        \"`get_all_calls` Variables\": \"calls, calls_dict\",\n        \"`get_python_file_details` Calls\": \"open, f.read, ast.parse, logging.warning, CodeVisitor, visitor.analyze, get_code_graph\",\n        \"`get_python_file_details` Inputs\": \"file_path\",\n        \"`get_python_file_details` Returns\": \"file_details, None\",\n        \"`get_python_file_details` Variables\": \"file_details, code, tree, visitor\",\n        \"`remove_docstring` Calls\": \"ast.parse, isinstance, tree.body.pop, ast.walk, node.body.pop, ast.unparse\",\n        \"`remove_docstring` Inputs\": \"code\",\n        \"`remove_docstring` Returns\": \"ast.unparse(tree)\",\n        \"`remove_docstring` Variables\": \"first_body_node, tree\",\n        \"`visit_Assign` Calls\": \"isinstance, ast.unparse, self.constants.append, self.generic_visit\",\n        \"`visit_Assign` Inputs\": \"self, node\",\n        \"`visit_ClassDef` Calls\": \"self.extract_details, self.generic_visit\",\n        \"`visit_ClassDef` Inputs\": \"self, node\",\n        \"`visit_FunctionDef` Calls\": \"self.extract_details, self.generic_visit\",\n        \"`visit_FunctionDef` Inputs\": \"self, node\"\n    }\n}"
    }
]