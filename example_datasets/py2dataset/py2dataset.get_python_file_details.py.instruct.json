[
    {
        "instruction": "Dependencies of Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "\"\"\"\nUse AST to extract details from a Python file, determine the code call graph and return it as a dictionary.\nRequirements:\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node with the function names as keys and their respective arguments as values.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the `visit_FunctionDef` method to gather details about functions.\n        e. Implement the `visit_ClassDef` method to gather details about classes.\n        f. Implement the `extract_details` method to parse information about a given node and return a dictionary containing relevant details.\n        g. Implement the `analyze` method to traverse the AST, list all nodes within the current file, and populate the 'file_info' attribute with comprehensive file details.\n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges that illustrate code relationships using the networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships like function calls, method calls, and class inheritance.\n        e. Return a dictionary representation of the code graph, aiding in understanding the code's structure and inter-relationships.\n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract detailed information from the specified Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details or None if there's an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n\"\"\"\nimport ast\nimport re\nimport json\nimport astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\ndef remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    \n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n    \n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f'{node_type}_name': node.name, \n            f'{node_type}_code': ast.unparse(node),\n            f'{node_type}_ast': ast.dump(node), \n            f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None),\n            f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f'{node_type}_calls': list(call_data.keys()),\n            f'{node_type}_call_inputs': call_data, \n            f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}),\n            f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()),\n            f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}),\n        }  \n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class: # find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({\n                    'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            'file_code': self.code,\n            'file_ast' : ast.dump(node),\n            'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            'file_functions': list(self.functions.keys()),\n            'file_classes': list(self.classes.keys()),\n        }\n        \n        # add file_summary to file_info\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = { 'dependencies': self.file_info['file_dependencies'], 'function_defs' : function_defs, 'class_defs' : class_defs}\n        \n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified\n\n\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items(): # Extract class name and details\n            G.add_node(class_name) # Add class as a graph node\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}' # Create method fully qualified name\n                G.add_node(qualified_method_name) # Add method as a graph node\n                class_method_details_lookup[qualified_method_name] = method_details  # Store method details \n                G.add_edge(class_name, qualified_method_name) # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and target in source_details['call_inputs']:\n            edge_data['target_inputs'] = source_details['call_inputs'][target]     \n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str] = None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup or \n                called in class_method_details_lookup or \n                f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()]\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f\"Permission denied or syntax error in file: {file_path}\")\n        return None \n\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\\\"','')\n    return file_details",
        "output": "typing, networkx, logging, astor, ast, re, json"
    },
    {
        "instruction": "Call code graph of Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "\"\"\"\nUse AST to extract details from a Python file, determine the code call graph and return it as a dictionary.\nRequirements:\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node with the function names as keys and their respective arguments as values.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the `visit_FunctionDef` method to gather details about functions.\n        e. Implement the `visit_ClassDef` method to gather details about classes.\n        f. Implement the `extract_details` method to parse information about a given node and return a dictionary containing relevant details.\n        g. Implement the `analyze` method to traverse the AST, list all nodes within the current file, and populate the 'file_info' attribute with comprehensive file details.\n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges that illustrate code relationships using the networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships like function calls, method calls, and class inheritance.\n        e. Return a dictionary representation of the code graph, aiding in understanding the code's structure and inter-relationships.\n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract detailed information from the specified Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details or None if there's an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n\"\"\"\nimport ast\nimport re\nimport json\nimport astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\ndef remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    \n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n    \n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f'{node_type}_name': node.name, \n            f'{node_type}_code': ast.unparse(node),\n            f'{node_type}_ast': ast.dump(node), \n            f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None),\n            f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f'{node_type}_calls': list(call_data.keys()),\n            f'{node_type}_call_inputs': call_data, \n            f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}),\n            f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()),\n            f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}),\n        }  \n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class: # find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({\n                    'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            'file_code': self.code,\n            'file_ast' : ast.dump(node),\n            'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            'file_functions': list(self.functions.keys()),\n            'file_classes': list(self.classes.keys()),\n        }\n        \n        # add file_summary to file_info\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = { 'dependencies': self.file_info['file_dependencies'], 'function_defs' : function_defs, 'class_defs' : class_defs}\n        \n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified\n\n\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items(): # Extract class name and details\n            G.add_node(class_name) # Add class as a graph node\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}' # Create method fully qualified name\n                G.add_node(qualified_method_name) # Add method as a graph node\n                class_method_details_lookup[qualified_method_name] = method_details  # Store method details \n                G.add_edge(class_name, qualified_method_name) # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and target in source_details['call_inputs']:\n            edge_data['target_inputs'] = source_details['call_inputs'][target]     \n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str] = None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup or \n                called in class_method_details_lookup or \n                f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()]\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f\"Permission denied or syntax error in file: {file_path}\")\n        return None \n\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\\\"','')\n    return file_details",
        "output": "{'nodes': ['CodeVisitor', 'CodeVisitor.__init__', 'CodeVisitor.visit_FunctionDef', 'CodeVisitor.visit_ClassDef', 'CodeVisitor.extract_details', 'CodeVisitor.analyze', 'remove_docs_and_comments', 'get_all_calls', 'code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'get_python_file_details', 'ast.parse', 'ast.walk', 'isinstance', 'ast.Constant', 'node.value.replace(\\'\"\"\"\\', \\'\\').replace', 'node.value.replace', 'astor.to_source(parsed).strip', 'astor.to_source', 'ast.iter_child_nodes', 'ast.unparse', 'calls.update', 'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', \"class_details['method_defs'].items\", 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'function_details_lookup.keys', 'function_details_lookup.items', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'open', 'f.read', 'logging.warning', 'visitor.analyze', \"json.dumps(file_details['file_info']['file_summary']).replace\", 'json.dumps', 'self.generic_visit', 'ast.dump', 'next', 'call_data.keys', \"self.classes[self.current_class].setdefault('class_attributes', []).extend\", 'self.classes[self.current_class].setdefault', 'details.update', 'any', 'self.visit', 'self.functions.keys', 'self.classes.keys', 'self.functions.items', 'self.classes.items', 'class_details.items', 'method_name.startswith', 'len', 'class_defs.append'], 'edges': [{'source': 'CodeVisitor', 'target': 'CodeVisitor.__init__', 'target_inputs': ['self', 'code'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_FunctionDef', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_ClassDef', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.analyze', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'self.generic_visit', 'target_inputs': ['node']}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'self.generic_visit', 'target_inputs': ['node']}, {'source': 'CodeVisitor.extract_details', 'target': 'list', 'target_inputs': ['{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.walk', 'target_inputs': ['node']}, {'source': 'CodeVisitor.extract_details', 'target': 'get_all_calls', 'target_inputs': ['node'], 'target_returns': ['calls']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.unparse', 'target_inputs': ['base']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.dump', 'target_inputs': ['node']}, {'source': 'CodeVisitor.extract_details', 'target': 'next', 'target_inputs': ['(n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str))', 'None']}, {'source': 'CodeVisitor.extract_details', 'target': 'isinstance', 'target_inputs': ['decorator', 'ast.Name']}, {'source': 'CodeVisitor.extract_details', 'target': 'call_data.keys', 'target_inputs': []}, {'source': 'CodeVisitor.extract_details', 'target': 'set', 'target_inputs': []}, {'source': 'CodeVisitor.extract_details', 'target': \"self.classes[self.current_class].setdefault('class_attributes', []).extend\", 'target_inputs': ['attributes']}, {'source': 'CodeVisitor.extract_details', 'target': 'self.classes[self.current_class].setdefault', 'target_inputs': [\"'class_attributes'\", '[]']}, {'source': 'CodeVisitor.extract_details', 'target': 'details.update', 'target_inputs': [\"{'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]}\"]}, {'source': 'CodeVisitor.extract_details', 'target': 'any', 'target_inputs': [\"(isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list)\"]}, {'source': 'CodeVisitor.analyze', 'target': 'list', 'target_inputs': ['self.classes.keys()']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.walk', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'self.visit', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.dump', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'isinstance', 'target_inputs': ['subnode', 'ast.ImportFrom']}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.keys', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.keys', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'class_details.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'method_name.startswith', 'target_inputs': [\"'class_method_'\"]}, {'source': 'CodeVisitor.analyze', 'target': 'len', 'target_inputs': [\"'class_method_'\"]}, {'source': 'CodeVisitor.analyze', 'target': 'class_defs.append', 'target_inputs': [\"{class_name: {'method_defs': method_defs}}\"]}, {'source': 'CodeVisitor.analyze', 'target': 'remove_docs_and_comments', 'target_inputs': ['ast.unparse(node)'], 'target_returns': ['astor.to_source(parsed).strip()']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.unparse', 'target_inputs': ['node']}, {'source': 'remove_docs_and_comments', 'target': 'ast.parse', 'target_inputs': ['code']}, {'source': 'remove_docs_and_comments', 'target': 'ast.walk', 'target_inputs': ['parsed']}, {'source': 'remove_docs_and_comments', 'target': 'isinstance', 'target_inputs': ['node.value', 'str']}, {'source': 'remove_docs_and_comments', 'target': 'ast.Constant', 'target_inputs': []}, {'source': 'remove_docs_and_comments', 'target': 'node.value.replace(\\'\"\"\"\\', \\'\\').replace', 'target_inputs': ['\"\\'\\'\\'\"', \"''\"]}, {'source': 'remove_docs_and_comments', 'target': 'node.value.replace', 'target_inputs': ['\\'\"\"\"\\'', \"''\"]}, {'source': 'remove_docs_and_comments', 'target': 'astor.to_source(parsed).strip', 'target_inputs': []}, {'source': 'remove_docs_and_comments', 'target': 'astor.to_source', 'target_inputs': ['parsed']}, {'source': 'get_all_calls', 'target': 'ast.iter_child_nodes', 'target_inputs': ['node']}, {'source': 'get_all_calls', 'target': 'isinstance', 'target_inputs': ['child', 'ast.Call']}, {'source': 'get_all_calls', 'target': 'ast.unparse', 'target_inputs': ['arg']}, {'source': 'get_all_calls', 'target': 'calls.update', 'target_inputs': ['get_all_calls(child)']}, {'source': 'get_all_calls', 'target': 'get_all_calls', 'target_inputs': ['child'], 'target_returns': ['calls']}, {'source': 'code_graph', 'target': 'nx.DiGraph', 'target_inputs': []}, {'source': 'code_graph', 'target': 'function_details_lookup.update', 'target_inputs': ['function_def']}, {'source': 'code_graph', 'target': 'class_def.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_node', 'target_inputs': ['function_name']}, {'source': 'code_graph', 'target': \"class_details['method_defs'].items\", 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'code_graph', 'target': 'target_details.get', 'target_inputs': [\"'returns'\", '[]']}, {'source': 'code_graph', 'target': 'list', 'target_inputs': ['G.nodes']}, {'source': 'code_graph', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'code_graph', 'target': 'class_method_details_lookup.get', 'target_inputs': ['source']}, {'source': 'code_graph', 'target': 'function_details_lookup.get', 'target_inputs': ['source']}, {'source': 'code_graph', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'code_graph', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'code_graph', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'code_graph', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'code_graph', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'code_graph', 'target': 'source_name.split', 'target_inputs': [\"'.'\"]}, {'source': 'code_graph', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'called'], 'target_returns': []}, {'source': 'code_graph', 'target': 'function_details_lookup.keys', 'target_inputs': []}, {'source': 'code_graph', 'target': 'function_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'add_edges_for_calls', 'target_inputs': ['qualified_method_name', \"details['calls']\"], 'target_returns': []}, {'source': 'code_graph', 'target': 'class_method_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G[source][target].update', 'target_inputs': ['edge_data']}, {'source': 'code_graph', 'target': 'G.edges.data', 'target_inputs': []}, {'source': 'get_edge_data_from_details', 'target': 'target_details.get', 'target_inputs': [\"'returns'\", '[]']}, {'source': 'get_edge_data_from_details', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\"]}, {'source': 'get_edge_data_from_details', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'add_edge_with_data', 'target': 'class_method_details_lookup.get', 'target_inputs': ['source']}, {'source': 'add_edge_with_data', 'target': 'function_details_lookup.get', 'target_inputs': ['source']}, {'source': 'add_edge_with_data', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'add_edge_with_data', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'add_edges_for_calls', 'target': 'list', 'target_inputs': ['class_def.keys()']}, {'source': 'add_edges_for_calls', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'add_edges_for_calls', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'add_edges_for_calls', 'target': 'source_name.split', 'target_inputs': [\"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'called'], 'target_returns': []}, {'source': 'add_edges_for_calls', 'target': 'G.add_node', 'target_inputs': ['called']}, {'source': 'get_python_file_details', 'target': 'open', 'target_inputs': ['file_path', \"'r'\"]}, {'source': 'get_python_file_details', 'target': 'f.read', 'target_inputs': []}, {'source': 'get_python_file_details', 'target': 'ast.parse', 'target_inputs': ['code']}, {'source': 'get_python_file_details', 'target': 'logging.warning', 'target_inputs': [\"f'Permission denied or syntax error in file: {file_path}'\"]}, {'source': 'get_python_file_details', 'target': 'CodeVisitor', 'target_inputs': ['code'], 'target_returns': []}, {'source': 'get_python_file_details', 'target': 'visitor.analyze', 'target_inputs': ['tree']}, {'source': 'get_python_file_details', 'target': 'code_graph', 'target_inputs': [\"file_details['file_info']['file_summary']\"], 'target_returns': [\"{'nodes': nodes, 'edges': edges}\", 'edge_data']}, {'source': 'get_python_file_details', 'target': \"json.dumps(file_details['file_info']['file_summary']).replace\", 'target_inputs': ['\\'\"\\'', \"''\"]}, {'source': 'get_python_file_details', 'target': 'json.dumps', 'target_inputs': [\"file_details['file_info']['file_summary']\"]}]}"
    },
    {
        "instruction": "Functions defined in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "\"\"\"\nUse AST to extract details from a Python file, determine the code call graph and return it as a dictionary.\nRequirements:\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node with the function names as keys and their respective arguments as values.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the `visit_FunctionDef` method to gather details about functions.\n        e. Implement the `visit_ClassDef` method to gather details about classes.\n        f. Implement the `extract_details` method to parse information about a given node and return a dictionary containing relevant details.\n        g. Implement the `analyze` method to traverse the AST, list all nodes within the current file, and populate the 'file_info' attribute with comprehensive file details.\n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges that illustrate code relationships using the networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships like function calls, method calls, and class inheritance.\n        e. Return a dictionary representation of the code graph, aiding in understanding the code's structure and inter-relationships.\n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract detailed information from the specified Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details or None if there's an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n\"\"\"\nimport ast\nimport re\nimport json\nimport astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\ndef remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    \n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n    \n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f'{node_type}_name': node.name, \n            f'{node_type}_code': ast.unparse(node),\n            f'{node_type}_ast': ast.dump(node), \n            f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None),\n            f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f'{node_type}_calls': list(call_data.keys()),\n            f'{node_type}_call_inputs': call_data, \n            f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}),\n            f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()),\n            f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}),\n        }  \n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class: # find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({\n                    'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            'file_code': self.code,\n            'file_ast' : ast.dump(node),\n            'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            'file_functions': list(self.functions.keys()),\n            'file_classes': list(self.classes.keys()),\n        }\n        \n        # add file_summary to file_info\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = { 'dependencies': self.file_info['file_dependencies'], 'function_defs' : function_defs, 'class_defs' : class_defs}\n        \n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified\n\n\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items(): # Extract class name and details\n            G.add_node(class_name) # Add class as a graph node\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}' # Create method fully qualified name\n                G.add_node(qualified_method_name) # Add method as a graph node\n                class_method_details_lookup[qualified_method_name] = method_details  # Store method details \n                G.add_edge(class_name, qualified_method_name) # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and target in source_details['call_inputs']:\n            edge_data['target_inputs'] = source_details['call_inputs'][target]     \n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str] = None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup or \n                called in class_method_details_lookup or \n                f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()]\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f\"Permission denied or syntax error in file: {file_path}\")\n        return None \n\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\\\"','')\n    return file_details",
        "output": "code_graph, get_python_file_details, get_edge_data_from_details, add_edge_with_data, remove_docs_and_comments, get_all_calls, add_edges_for_calls"
    },
    {
        "instruction": "Classes defined in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "\"\"\"\nUse AST to extract details from a Python file, determine the code call graph and return it as a dictionary.\nRequirements:\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node with the function names as keys and their respective arguments as values.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the `visit_FunctionDef` method to gather details about functions.\n        e. Implement the `visit_ClassDef` method to gather details about classes.\n        f. Implement the `extract_details` method to parse information about a given node and return a dictionary containing relevant details.\n        g. Implement the `analyze` method to traverse the AST, list all nodes within the current file, and populate the 'file_info' attribute with comprehensive file details.\n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges that illustrate code relationships using the networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships like function calls, method calls, and class inheritance.\n        e. Return a dictionary representation of the code graph, aiding in understanding the code's structure and inter-relationships.\n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract detailed information from the specified Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details or None if there's an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n\"\"\"\nimport ast\nimport re\nimport json\nimport astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\ndef remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    \n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n    \n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f'{node_type}_name': node.name, \n            f'{node_type}_code': ast.unparse(node),\n            f'{node_type}_ast': ast.dump(node), \n            f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None),\n            f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f'{node_type}_calls': list(call_data.keys()),\n            f'{node_type}_call_inputs': call_data, \n            f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}),\n            f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()),\n            f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}),\n        }  \n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class: # find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({\n                    'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            'file_code': self.code,\n            'file_ast' : ast.dump(node),\n            'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            'file_functions': list(self.functions.keys()),\n            'file_classes': list(self.classes.keys()),\n        }\n        \n        # add file_summary to file_info\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = { 'dependencies': self.file_info['file_dependencies'], 'function_defs' : function_defs, 'class_defs' : class_defs}\n        \n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified\n\n\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items(): # Extract class name and details\n            G.add_node(class_name) # Add class as a graph node\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}' # Create method fully qualified name\n                G.add_node(qualified_method_name) # Add method as a graph node\n                class_method_details_lookup[qualified_method_name] = method_details  # Store method details \n                G.add_edge(class_name, qualified_method_name) # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and target in source_details['call_inputs']:\n            edge_data['target_inputs'] = source_details['call_inputs'][target]     \n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str] = None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup or \n                called in class_method_details_lookup or \n                f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()]\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f\"Permission denied or syntax error in file: {file_path}\")\n        return None \n\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\\\"','')\n    return file_details",
        "output": "CodeVisitor"
    },
    {
        "instruction": "Inputs to function: 'remove_docs_and_comments' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()",
        "output": "code"
    },
    {
        "instruction": "Inputs to function: 'get_all_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls",
        "output": "node"
    },
    {
        "instruction": "Inputs to function: 'code_graph' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "file_summary"
    },
    {
        "instruction": "Inputs to function: 'get_edge_data_from_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "target, target_details, source_details"
    },
    {
        "instruction": "Inputs to function: 'add_edge_with_data' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))",
        "output": "target, init_method, source"
    },
    {
        "instruction": "Inputs to function: 'add_edges_for_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)",
        "output": "calls, source_name"
    },
    {
        "instruction": "Inputs to function: 'get_python_file_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f'Permission denied or syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    return file_details",
        "output": "file_path"
    },
    {
        "instruction": "Docstring of function: 'remove_docs_and_comments' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()",
        "output": "Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code."
    },
    {
        "instruction": "Docstring of function: 'get_all_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls",
        "output": "Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values."
    },
    {
        "instruction": "Docstring of function: 'code_graph' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code."
    },
    {
        "instruction": "Docstring of function: 'get_python_file_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f'Permission denied or syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    return file_details",
        "output": "Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file."
    },
    {
        "instruction": "Calls made in function: 'remove_docs_and_comments' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()",
        "output": "node.value.replace, astor.to_source, ast.parse, astor.to_sourceparsed.strip, ast.walk, ast.Constant, .replace, isinstance"
    },
    {
        "instruction": "Calls made in function: 'get_all_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls",
        "output": "ast.unparse, ast.iter_child_nodes, calls.update, get_all_calls, isinstance"
    },
    {
        "instruction": "Calls made in function: 'code_graph' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "class_method_details_lookup.items, set, class_def.keys, class_detailsmethod_defs.items, G.add_edge, G.add_node, G.edges.data, called.startswith, function_details_lookup.keys, called.split, target_details.get, function_details_lookup.get, class_def.items, function_details_lookup.update, called.replace, class_method_details_lookup.get, add_edge_with_data, nx.DiGraph, list, function_details_lookup.items, Gsourcetarget.update, get_edge_data_from_details, source_name.split, add_edges_for_calls"
    },
    {
        "instruction": "Calls made in function: 'get_edge_data_from_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "target_details.get, set, list"
    },
    {
        "instruction": "Calls made in function: 'add_edge_with_data' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))",
        "output": "class_method_details_lookup.get, function_details_lookup.get, G.add_edge, get_edge_data_from_details"
    },
    {
        "instruction": "Calls made in function: 'add_edges_for_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)",
        "output": "called.replace, called.startswith, source_name.split, add_edge_with_data, list, class_def.keys, called.split, G.add_node"
    },
    {
        "instruction": "Calls made in function: 'get_python_file_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f'Permission denied or syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    return file_details",
        "output": "code_graph, json.dumpsfile_detailsfile_infofile_summary.replace, visitor.analyze, open, json.dumps, CodeVisitor, ast.parse, f.read, logging.warning"
    },
    {
        "instruction": "Variables defined in function: 'remove_docs_and_comments' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()",
        "output": "parsed"
    },
    {
        "instruction": "Variables defined in function: 'get_all_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls",
        "output": "calls"
    },
    {
        "instruction": "Variables defined in function: 'code_graph' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "qualified_method_name, method_name, function_details_lookup, nodes, fully_qualified_name, edges, init_method_name, target_details, source_details, edge_data, class_method_details_lookup, G, class_names, init_method, called_class_name"
    },
    {
        "instruction": "Variables defined in function: 'get_edge_data_from_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "edge_data"
    },
    {
        "instruction": "Variables defined in function: 'add_edge_with_data' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))",
        "output": "target_details, source_details"
    },
    {
        "instruction": "Variables defined in function: 'add_edges_for_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)",
        "output": "method_name, fully_qualified_name, init_method_name, class_names, init_method, called_class_name"
    },
    {
        "instruction": "Variables defined in function: 'get_python_file_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f'Permission denied or syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    return file_details",
        "output": "tree, visitor, file_details, code"
    },
    {
        "instruction": "Returned items from function: 'remove_docs_and_comments' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()",
        "output": "astor.to_sourceparsed.strip"
    },
    {
        "instruction": "Returned items from function: 'get_all_calls' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls",
        "output": "calls"
    },
    {
        "instruction": "Returned items from function: 'code_graph' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "edge_data, nodes: nodes, edges: edges"
    },
    {
        "instruction": "Returned items from function: 'get_edge_data_from_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data",
        "output": "edge_data"
    },
    {
        "instruction": "Returned items from function: 'get_python_file_details' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f'Permission denied or syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\"', '')\n    return file_details",
        "output": "file_details, None"
    },
    {
        "instruction": "Methods defined in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "analyze, extract_details, visit_FunctionDef, visit_ClassDef"
    },
    {
        "instruction": "Docstring of class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file."
    },
    {
        "instruction": "Attributes of class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "current_class, file_info"
    },
    {
        "instruction": "Variables defined in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "details, method_defs, function_defs, node_walk, call_data, class_defs, attributes, file_code_simplified"
    },
    {
        "instruction": "Inheritance of class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "ast.NodeVisitor"
    },
    {
        "instruction": "Inputs to method: '__init__' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def __init__(self, code: str):\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None",
        "output": "code, self"
    },
    {
        "instruction": "Inputs to method: 'visit_FunctionDef' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)",
        "output": "node, self"
    },
    {
        "instruction": "Inputs to method: 'visit_ClassDef' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "node, self"
    },
    {
        "instruction": "Inputs to method: 'extract_details' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "node, node_type, self"
    },
    {
        "instruction": "Inputs to method: 'analyze' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    self.visit(node)\n    self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = []\n    for class_name, class_details in self.classes.items():\n        method_defs = {}\n        for method_name, details in class_details.items():\n            if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n        class_defs.append({class_name: {'method_defs': method_defs}})\n    self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n    file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n    self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "node, self"
    },
    {
        "instruction": "Docstring of method: '__init__' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def __init__(self, code: str):\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None",
        "output": "Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None"
    },
    {
        "instruction": "Docstring of method: 'visit_FunctionDef' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)",
        "output": "Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None"
    },
    {
        "instruction": "Docstring of method: 'visit_ClassDef' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None"
    },
    {
        "instruction": "Docstring of method: 'extract_details' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node."
    },
    {
        "instruction": "Docstring of method: 'analyze' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    self.visit(node)\n    self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = []\n    for class_name, class_details in self.classes.items():\n        method_defs = {}\n        for method_name, details in class_details.items():\n            if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n        class_defs.append({class_name: {'method_defs': method_defs}})\n    self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n    file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n    self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None"
    },
    {
        "instruction": "Calls made in method: 'visit_FunctionDef' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)",
        "output": "self.generic_visit, self.extract_details"
    },
    {
        "instruction": "Calls made in method: 'visit_ClassDef' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "self.generic_visit, self.extract_details"
    },
    {
        "instruction": "Calls made in method: 'extract_details' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "call_data.keys, any, ast.unparse, next, self.classesself.current_class.setdefaultclass_attributes, details.update, list, ast.dump, set, self.classesself.current_class.setdefault, ast.walk, get_all_calls, .extend, isinstance"
    },
    {
        "instruction": "Calls made in method: 'analyze' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    self.visit(node)\n    self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys())}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = []\n    for class_name, class_details in self.classes.items():\n        method_defs = {}\n        for method_name, details in class_details.items():\n            if method_name.startswith('class_method_'):\n                method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n        class_defs.append({class_name: {'method_defs': method_defs}})\n    self.file_info['file_summary'] = {'dependencies': self.file_info['file_dependencies'], 'function_defs': function_defs, 'class_defs': class_defs}\n    file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n    self.file_info['file_code_simplified'] = file_code_simplified",
        "output": "method_name.startswith, self.classes.keys, ast.unparse, self.classes.items, self.visit, len, self.functions.keys, list, ast.dump, class_details.items, ast.walk, remove_docs_and_comments, self.functions.items, class_defs.append, isinstance"
    },
    {
        "instruction": "Returns from method: 'extract_details' in class: 'CodeVisitor' in Python file: 'py2dataset.get_python_file_details.py'?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}), f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "details"
    },
    {
        "instruction": "1) DESCRIBE the purpose and processing summary of Python file: 'py2dataset.get_python_file_details.py'; 2) PROVIDE an itemized and detailed description of each applicable function, class, and method; 3) EXPLAIN what each input, output, and variable does in the code.",
        "input": "\"\"\"\nUse AST to extract details from a Python file, determine the code call graph and return it as a dictionary.\nRequirements:\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node with the function names as keys and their respective arguments as values.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement the `visit_FunctionDef` method to gather details about functions.\n        e. Implement the `visit_ClassDef` method to gather details about classes.\n        f. Implement the `extract_details` method to parse information about a given node and return a dictionary containing relevant details.\n        g. Implement the `analyze` method to traverse the AST, list all nodes within the current file, and populate the 'file_info' attribute with comprehensive file details.\n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges that illustrate code relationships using the networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships like function calls, method calls, and class inheritance.\n        e. Return a dictionary representation of the code graph, aiding in understanding the code's structure and inter-relationships.\n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract detailed information from the specified Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details or None if there's an issue reading the file or parsing its content.\n[req05] The `remove_docs_and_comments` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n\"\"\"\nimport ast\nimport re\nimport json\nimport astor\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\ndef remove_docs_and_comments(code: str) -> str:\n    \"\"\"\n    Remove docstrings and comments from the provided code.\n    Args:\n        code: str: The source code.\n    Returns:\n        str: The sanitized code.\n    \"\"\"\n    parsed = ast.parse(code)\n    for node in ast.walk(parsed):\n        if isinstance(node, (ast.Expr, ast.Constant)) and isinstance(node.value, (ast.Str, ast.Bytes)):\n            node.value = ast.Constant(value='')\n        elif isinstance(node, ast.Constant) and isinstance(node.value, str):\n            node.value = node.value.replace('\"\"\"', '').replace(\"'''\", '')\n    return astor.to_source(parsed).strip()\n\n\ndef get_all_calls(node: ast.AST) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    Args:\n        node (ast.AST): The node to start the search from.\n    Returns:\n        Dict[str, List[str]]: A dictionary with function calls as keys and their arguments as values.\n    \"\"\"\n    calls = {}\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls[ast.unparse(child.func)] = [ast.unparse(arg) for arg in child.args]\n        calls.update(get_all_calls(child))\n    return calls\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: \n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: \n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]: \n            Extract details about a node.\n        analyze(node: ast.AST) -> None: \n            Populate file_info with details about the file.\n    \"\"\"\n    def __init__(self, code: str):\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        Returns:\n            None\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    \n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        Returns:\n            None\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n    \n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        details = {\n            f'{node_type}_name': node.name, \n            f'{node_type}_code': ast.unparse(node),\n            f'{node_type}_ast': ast.dump(node), \n            f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None),\n            f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f'{node_type}_calls': list(call_data.keys()),\n            f'{node_type}_call_inputs': call_data, \n            f'{node_type}_variables': list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}),\n            f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()),\n            f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}),\n            f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}),\n        }  \n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class: # find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                self.classes[self.current_class].setdefault('class_attributes', []).extend(attributes)\n            if node_type == 'class':\n                details.update({\n                    'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        Args:\n            node: ast.AST: The node to analyze.\n        Returns:\n            None\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            'file_code': self.code,\n            'file_ast' : ast.dump(node),\n            'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            'file_functions': list(self.functions.keys()),\n            'file_classes': list(self.classes.keys()),\n        }\n        \n        # add file_summary to file_info\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = []\n        for class_name, class_details in self.classes.items():\n            method_defs = {}\n            for method_name, details in class_details.items():\n                if method_name.startswith('class_method_'):\n                    method_defs[method_name[len('class_method_'):]] = {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']}\n            class_defs.append({class_name: {'method_defs': method_defs}})\n        self.file_info['file_summary'] = { 'dependencies': self.file_info['file_dependencies'], 'function_defs' : function_defs, 'class_defs' : class_defs}\n        \n        file_code_simplified = remove_docs_and_comments(ast.unparse(node))\n        self.file_info['file_code_simplified'] = file_code_simplified\n\n\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items(): # Extract class name and details\n            G.add_node(class_name) # Add class as a graph node\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}' # Create method fully qualified name\n                G.add_node(qualified_method_name) # Add method as a graph node\n                class_method_details_lookup[qualified_method_name] = method_details  # Store method details \n                G.add_edge(class_name, qualified_method_name) # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and target in source_details['call_inputs']:\n            edge_data['target_inputs'] = source_details['call_inputs'][target]     \n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str] = None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup or \n                called in class_method_details_lookup or \n                f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup.keys():\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()]\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except:\n        logging.warning(f\"Permission denied or syntax error in file: {file_path}\")\n        return None \n\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details['file_info']['file_summary'])\n    file_details['file_info']['file_summary'] = json.dumps(file_details['file_info']['file_summary']).replace('\\\"','')\n    return file_details",
        "output": "Summary/Processing of the file `get_python_file_details` purpose: Python program used for analysis, transformation and summarizing details of Python code. This program contains methods that parse Python source code to extract various details like functions, classes, their arguments, returns, inputs, variables, call relationships etc., and create a directed graph representation of the code structure using networkx library.\n\nFunctions:\n- `remove_docs_and_comments` - removes docstrings and comments from provided python code\n- `get_all_calls` - Recursively finds all function calls in given ast subtree node \n- `code_graph` - Generate the code graph, determining relations like method/class inheritances, function calls etc. using networkx library\n- `get_python_file_details` - Extracts details from Python file and includes entire code graph as well in the output dictionary\n\nClasses:\n- `CodeVisitor` - Inherits ast.NodeVisitor to extract information about classes and functions"
    }
]