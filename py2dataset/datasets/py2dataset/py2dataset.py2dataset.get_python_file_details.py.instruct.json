[
    {
        "instruction": "Dependencies of file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "\"\"\"\nUse AST to extract details from Python a file and return as a dictionary.\nRequirements:\n[req01] The ControlFlowVisitor class shall inherit from ast.NodeVisitor and be\n        used to visit nodes in the AST (Abstract Syntax Tree). It extracts \n        control flow keywords to give a high-level understanding of the \n        program flow.\n[req02] The CodeVisitor class shall inherit from ast.NodeVisitor and be used\n        to traverse an AST (Abstract Syntax Tree) and extract details about the\n        code.\n[req03] The CodeVisitor class shall have methods to visit FunctionDef and \n        ClassDef nodes and extract details about a function or a class.\n[req04] The CodeVisitor class shall have a method to analyze a node and \n        populate file_info with details about the file.\n[req05] The get_control_flow function shall accept a string of source code as\n        an argument and return the control flow keywords in the code.\n[req06] The get_python_file_details function shall accept a file path as an\n        argument and return a dictionary of the details extracted from the file.\n[req07] The CodeVisitor class shall store details about functions and classes,\n        including their code, AST, docstring, inputs, defaults, returns, calls,\n        variables, decorators, annotations, and properties.\n[req08] For classes, the CodeVisitor class shall also store details about class\n        attributes, methods, inheritance, and static methods.\n[req09] The analyze function in the CodeVisitor class shall also populate\n        file_info with the file's code, AST, dependencies, functions, classes,\n        and control flow.\n[req10] The code_graph function shall create a dictionary representation of \n        file details, including nodes and edges representing the relationships\n        in the code. It shall include function nodes, class nodes, method\n        nodes, and edges for function calls, method calls, and class\n        inheritance.\n[req11] The get_python_file_details function shall also add a graph to\n        file_info in the returned file_details dictionary. It shall add an\n        internal file graph (only including function calls where both the\n        caller and called function are within the file) and an entire file\n        graph (including all function calls).\n\"\"\"\nimport ast\nimport re\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\n\nclass ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {\n        ast.If: \"if\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.AsyncWith: \"with\",\n        ast.Try: \"try\",\n        ast.With: \"with\",\n        ast.ExceptHandler: \"except\",\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.Module: \"module\",\n    }\n    def __init__(self):\n        self.control_flow = []\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)\n\ndef get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n    def __init__(self, code: str):\n        # initialize dictionaries to store function, class, and file definitions\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class: # If we're inside a class, add this function as a method of the class\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else: # populate function dictionary when function definition found in AST\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node) # continue AST traversal to the next node\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # Set current_class to indicate that we're inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # Reset current_class after we've finished with this class\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {\n            f\"{node_type}_name\": node.name, \n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_ast\": ast.dump(node, include_attributes=True), \n            f\"{node_type}_docstring\": ast.get_docstring(node),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_returns\": [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f\"{node_type}_calls\": list(set([ast.unparse(n.func) for n in get_all_calls(node)])),\n            f\"{node_type}_variables\": list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])),\n            f\"{node_type}_decorators\": list(set(ast.unparse(decorator) for decorator in node.decorator_list)) if node.decorator_list else [],\n            f\"{node_type}_annotations\": list(set(ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None)),\n            f\"{node_type}_properties\": list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)])),\n        }  \n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class: # Find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                if attributes: # If this class already has some attributes, add to them\n                    if \"class_attributes\" in self.classes[self.current_class]:\n                        self.classes[self.current_class][\"class_attributes\"].extend(attributes)\n                    else: # Otherwise, start a new list of attributes for this class\n                        self.classes[self.current_class][\"class_attributes\"] = attributes\n            if node_type == 'class':\n                details.update({\n                    \"class_attributes\": [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    \"class_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    \"class_inheritance\": [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    \"class_static_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        # travere the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : ast.dump(node),\n            \"file_dependencies\": list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_control_flow\": get_control_flow(self.code),\n        }\n\ndef get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()\n\n\ndef code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool = True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Add function nodes to graph\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n\n    # Add class nodes and method nodes to graph\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                # Remove the 'class_method_' prefix to get the actual method name\n                actual_method_name = method_name[len('class_method_'):]\n                # Use the format 'ClassName.methodName' to represent methods\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                # Add edge between class and its method\n                G.add_edge(class_name, qualified_method_name)\n        \n        # Add edges for class inheritance\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n\n    # Add edges for function calls\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n\n    # Add edges for method calls\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:  # The called function is a method\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:  # The called function is a standalone function\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n\n    nodes = list(G.nodes)        \n    edges = [{\"source\": str(edge[0]), \"target\": str(edge[1]), **edge[2]} for edge in G.edges.data()]\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges,\n    }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f\"Permission denied: {file_path}\")\n        return None \n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f\"Syntax error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    \n    # add graph to file_info in file_details\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "typing, ast, networkx, re, logging"
    },
    {
        "instruction": "Structural graph of the relationships between the functions and classes defined in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "\"\"\"\nUse AST to extract details from Python a file and return as a dictionary.\nRequirements:\n[req01] The ControlFlowVisitor class shall inherit from ast.NodeVisitor and be\n        used to visit nodes in the AST (Abstract Syntax Tree). It extracts \n        control flow keywords to give a high-level understanding of the \n        program flow.\n[req02] The CodeVisitor class shall inherit from ast.NodeVisitor and be used\n        to traverse an AST (Abstract Syntax Tree) and extract details about the\n        code.\n[req03] The CodeVisitor class shall have methods to visit FunctionDef and \n        ClassDef nodes and extract details about a function or a class.\n[req04] The CodeVisitor class shall have a method to analyze a node and \n        populate file_info with details about the file.\n[req05] The get_control_flow function shall accept a string of source code as\n        an argument and return the control flow keywords in the code.\n[req06] The get_python_file_details function shall accept a file path as an\n        argument and return a dictionary of the details extracted from the file.\n[req07] The CodeVisitor class shall store details about functions and classes,\n        including their code, AST, docstring, inputs, defaults, returns, calls,\n        variables, decorators, annotations, and properties.\n[req08] For classes, the CodeVisitor class shall also store details about class\n        attributes, methods, inheritance, and static methods.\n[req09] The analyze function in the CodeVisitor class shall also populate\n        file_info with the file's code, AST, dependencies, functions, classes,\n        and control flow.\n[req10] The code_graph function shall create a dictionary representation of \n        file details, including nodes and edges representing the relationships\n        in the code. It shall include function nodes, class nodes, method\n        nodes, and edges for function calls, method calls, and class\n        inheritance.\n[req11] The get_python_file_details function shall also add a graph to\n        file_info in the returned file_details dictionary. It shall add an\n        internal file graph (only including function calls where both the\n        caller and called function are within the file) and an entire file\n        graph (including all function calls).\n\"\"\"\nimport ast\nimport re\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\n\nclass ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {\n        ast.If: \"if\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.AsyncWith: \"with\",\n        ast.Try: \"try\",\n        ast.With: \"with\",\n        ast.ExceptHandler: \"except\",\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.Module: \"module\",\n    }\n    def __init__(self):\n        self.control_flow = []\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)\n\ndef get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n    def __init__(self, code: str):\n        # initialize dictionaries to store function, class, and file definitions\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class: # If we're inside a class, add this function as a method of the class\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else: # populate function dictionary when function definition found in AST\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node) # continue AST traversal to the next node\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # Set current_class to indicate that we're inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # Reset current_class after we've finished with this class\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {\n            f\"{node_type}_name\": node.name, \n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_ast\": ast.dump(node, include_attributes=True), \n            f\"{node_type}_docstring\": ast.get_docstring(node),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_returns\": [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f\"{node_type}_calls\": list(set([ast.unparse(n.func) for n in get_all_calls(node)])),\n            f\"{node_type}_variables\": list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])),\n            f\"{node_type}_decorators\": list(set(ast.unparse(decorator) for decorator in node.decorator_list)) if node.decorator_list else [],\n            f\"{node_type}_annotations\": list(set(ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None)),\n            f\"{node_type}_properties\": list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)])),\n        }  \n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class: # Find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                if attributes: # If this class already has some attributes, add to them\n                    if \"class_attributes\" in self.classes[self.current_class]:\n                        self.classes[self.current_class][\"class_attributes\"].extend(attributes)\n                    else: # Otherwise, start a new list of attributes for this class\n                        self.classes[self.current_class][\"class_attributes\"] = attributes\n            if node_type == 'class':\n                details.update({\n                    \"class_attributes\": [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    \"class_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    \"class_inheritance\": [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    \"class_static_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        # travere the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : ast.dump(node),\n            \"file_dependencies\": list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_control_flow\": get_control_flow(self.code),\n        }\n\ndef get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()\n\n\ndef code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool = True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Add function nodes to graph\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n\n    # Add class nodes and method nodes to graph\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                # Remove the 'class_method_' prefix to get the actual method name\n                actual_method_name = method_name[len('class_method_'):]\n                # Use the format 'ClassName.methodName' to represent methods\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                # Add edge between class and its method\n                G.add_edge(class_name, qualified_method_name)\n        \n        # Add edges for class inheritance\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n\n    # Add edges for function calls\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n\n    # Add edges for method calls\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:  # The called function is a method\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:  # The called function is a standalone function\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n\n    nodes = list(G.nodes)        \n    edges = [{\"source\": str(edge[0]), \"target\": str(edge[1]), **edge[2]} for edge in G.edges.data()]\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges,\n    }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f\"Permission denied: {file_path}\")\n        return None \n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f\"Syntax error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    \n    # add graph to file_info in file_details\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "{'nodes': ['get_all_calls', 'get_control_flow', 'code_graph', 'get_python_file_details', 'ControlFlowVisitor', 'ControlFlowVisitor.__init__', 'ControlFlowVisitor.generic_visit', 'ControlFlowVisitor.get_control_flow', 'CodeVisitor', 'CodeVisitor.__init__', 'CodeVisitor.visit_FunctionDef', 'CodeVisitor.visit_ClassDef', 'CodeVisitor.extract_details', 'CodeVisitor.analyze'], 'edges': [{'source': 'get_all_calls', 'target': 'get_all_calls', 'target_input': ['node'], 'target_returns': ['calls']}, {'source': 'get_control_flow', 'target': 'ControlFlowVisitor'}, {'source': 'get_python_file_details', 'target': 'CodeVisitor'}, {'source': 'get_python_file_details', 'target': 'code_graph', 'target_input': ['file_details', 'internal_only'], 'target_returns': [\"{'nodes': nodes, 'edges': edges}\"]}, {'source': 'ControlFlowVisitor', 'target': 'ControlFlowVisitor.__init__'}, {'source': 'ControlFlowVisitor', 'target': 'ControlFlowVisitor.generic_visit'}, {'source': 'ControlFlowVisitor', 'target': 'ControlFlowVisitor.get_control_flow'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.__init__'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_FunctionDef'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_ClassDef'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.extract_details'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.analyze'}, {'source': 'CodeVisitor.extract_details', 'target': 'get_all_calls', 'target_input': ['node'], 'target_returns': ['calls']}, {'source': 'CodeVisitor.analyze', 'target': 'get_control_flow', 'target_input': ['code'], 'target_returns': ['visitor.get_control_flow()']}]}"
    },
    {
        "instruction": "Structural graph of the relationships between the functions and classes defined and used in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "\"\"\"\nUse AST to extract details from Python a file and return as a dictionary.\nRequirements:\n[req01] The ControlFlowVisitor class shall inherit from ast.NodeVisitor and be\n        used to visit nodes in the AST (Abstract Syntax Tree). It extracts \n        control flow keywords to give a high-level understanding of the \n        program flow.\n[req02] The CodeVisitor class shall inherit from ast.NodeVisitor and be used\n        to traverse an AST (Abstract Syntax Tree) and extract details about the\n        code.\n[req03] The CodeVisitor class shall have methods to visit FunctionDef and \n        ClassDef nodes and extract details about a function or a class.\n[req04] The CodeVisitor class shall have a method to analyze a node and \n        populate file_info with details about the file.\n[req05] The get_control_flow function shall accept a string of source code as\n        an argument and return the control flow keywords in the code.\n[req06] The get_python_file_details function shall accept a file path as an\n        argument and return a dictionary of the details extracted from the file.\n[req07] The CodeVisitor class shall store details about functions and classes,\n        including their code, AST, docstring, inputs, defaults, returns, calls,\n        variables, decorators, annotations, and properties.\n[req08] For classes, the CodeVisitor class shall also store details about class\n        attributes, methods, inheritance, and static methods.\n[req09] The analyze function in the CodeVisitor class shall also populate\n        file_info with the file's code, AST, dependencies, functions, classes,\n        and control flow.\n[req10] The code_graph function shall create a dictionary representation of \n        file details, including nodes and edges representing the relationships\n        in the code. It shall include function nodes, class nodes, method\n        nodes, and edges for function calls, method calls, and class\n        inheritance.\n[req11] The get_python_file_details function shall also add a graph to\n        file_info in the returned file_details dictionary. It shall add an\n        internal file graph (only including function calls where both the\n        caller and called function are within the file) and an entire file\n        graph (including all function calls).\n\"\"\"\nimport ast\nimport re\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\n\nclass ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {\n        ast.If: \"if\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.AsyncWith: \"with\",\n        ast.Try: \"try\",\n        ast.With: \"with\",\n        ast.ExceptHandler: \"except\",\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.Module: \"module\",\n    }\n    def __init__(self):\n        self.control_flow = []\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)\n\ndef get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n    def __init__(self, code: str):\n        # initialize dictionaries to store function, class, and file definitions\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class: # If we're inside a class, add this function as a method of the class\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else: # populate function dictionary when function definition found in AST\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node) # continue AST traversal to the next node\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # Set current_class to indicate that we're inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # Reset current_class after we've finished with this class\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {\n            f\"{node_type}_name\": node.name, \n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_ast\": ast.dump(node, include_attributes=True), \n            f\"{node_type}_docstring\": ast.get_docstring(node),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_returns\": [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f\"{node_type}_calls\": list(set([ast.unparse(n.func) for n in get_all_calls(node)])),\n            f\"{node_type}_variables\": list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])),\n            f\"{node_type}_decorators\": list(set(ast.unparse(decorator) for decorator in node.decorator_list)) if node.decorator_list else [],\n            f\"{node_type}_annotations\": list(set(ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None)),\n            f\"{node_type}_properties\": list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)])),\n        }  \n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class: # Find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                if attributes: # If this class already has some attributes, add to them\n                    if \"class_attributes\" in self.classes[self.current_class]:\n                        self.classes[self.current_class][\"class_attributes\"].extend(attributes)\n                    else: # Otherwise, start a new list of attributes for this class\n                        self.classes[self.current_class][\"class_attributes\"] = attributes\n            if node_type == 'class':\n                details.update({\n                    \"class_attributes\": [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    \"class_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    \"class_inheritance\": [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    \"class_static_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        # travere the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : ast.dump(node),\n            \"file_dependencies\": list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_control_flow\": get_control_flow(self.code),\n        }\n\ndef get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()\n\n\ndef code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool = True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Add function nodes to graph\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n\n    # Add class nodes and method nodes to graph\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                # Remove the 'class_method_' prefix to get the actual method name\n                actual_method_name = method_name[len('class_method_'):]\n                # Use the format 'ClassName.methodName' to represent methods\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                # Add edge between class and its method\n                G.add_edge(class_name, qualified_method_name)\n        \n        # Add edges for class inheritance\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n\n    # Add edges for function calls\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n\n    # Add edges for method calls\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:  # The called function is a method\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:  # The called function is a standalone function\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n\n    nodes = list(G.nodes)        \n    edges = [{\"source\": str(edge[0]), \"target\": str(edge[1]), **edge[2]} for edge in G.edges.data()]\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges,\n    }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f\"Permission denied: {file_path}\")\n        return None \n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f\"Syntax error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    \n    # add graph to file_info in file_details\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "{'nodes': ['get_all_calls', 'get_control_flow', 'code_graph', 'get_python_file_details', 'ControlFlowVisitor', 'ControlFlowVisitor.__init__', 'ControlFlowVisitor.generic_visit', 'ControlFlowVisitor.get_control_flow', 'ast.NodeVisitor', 'CodeVisitor', 'CodeVisitor.__init__', 'CodeVisitor.visit_FunctionDef', 'CodeVisitor.visit_ClassDef', 'CodeVisitor.extract_details', 'CodeVisitor.analyze', 'ast.iter_child_nodes', 'isinstance', 'calls.append', 'calls.extend', 'visitor.visit', 'visitor.get_control_flow', 'ast.parse', 'called_func.rsplit', \"file_details['classes'].get(called_class_name, {}).get\", 'str', \"file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get\", 'list', 'nx.DiGraph', \"file_details['classes'].get\", 'base_class.strip', 'class_details.items', 'G.add_node', \"file_details['functions'].get(called_func, {}).get\", 'G.add_edge', 'len', \"file_details['classes'].items\", 'called_func.strip', 'class_details.keys', 'G.edges.data', 'method_name.startswith', \"file_details['functions'].get\", \"file_details['functions'].keys\", \"file_details['functions'].items\", 'logging.warning', 'f.read', 'open', 'visitor.analyze', 'super', 'super().generic_visit', 'type', 'self.node_type_to_keyword.get', 'self.control_flow.append', \"' -> '.join\", 'self.generic_visit', 'self.extract_details', 'ast.dump', 'details.update', 'ast.unparse', 'set', \"self.classes[self.current_class]['class_attributes'].extend\", 'ast.get_docstring', 'ast.walk', 'any', 'self.visit', 'self.classes.keys', 'self.functions.keys'], 'edges': [{'source': 'get_all_calls', 'target': 'ast.iter_child_nodes'}, {'source': 'get_all_calls', 'target': 'isinstance'}, {'source': 'get_all_calls', 'target': 'calls.append'}, {'source': 'get_all_calls', 'target': 'get_all_calls', 'target_input': ['node'], 'target_returns': ['calls']}, {'source': 'get_all_calls', 'target': 'calls.extend'}, {'source': 'get_control_flow', 'target': 'visitor.visit'}, {'source': 'get_control_flow', 'target': 'visitor.get_control_flow'}, {'source': 'get_control_flow', 'target': 'ControlFlowVisitor'}, {'source': 'get_control_flow', 'target': 'ast.parse'}, {'source': 'code_graph', 'target': 'called_func.rsplit'}, {'source': 'code_graph', 'target': \"file_details['classes'].get(called_class_name, {}).get\"}, {'source': 'code_graph', 'target': 'str'}, {'source': 'code_graph', 'target': \"file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get\"}, {'source': 'code_graph', 'target': 'list'}, {'source': 'code_graph', 'target': 'nx.DiGraph'}, {'source': 'code_graph', 'target': \"file_details['classes'].get\"}, {'source': 'code_graph', 'target': 'base_class.strip'}, {'source': 'code_graph', 'target': 'class_details.items'}, {'source': 'code_graph', 'target': 'G.add_node'}, {'source': 'code_graph', 'target': \"file_details['functions'].get(called_func, {}).get\"}, {'source': 'code_graph', 'target': 'G.add_edge'}, {'source': 'code_graph', 'target': 'len'}, {'source': 'code_graph', 'target': \"file_details['classes'].items\"}, {'source': 'code_graph', 'target': 'called_func.strip'}, {'source': 'code_graph', 'target': 'class_details.keys'}, {'source': 'code_graph', 'target': 'G.edges.data'}, {'source': 'code_graph', 'target': 'method_name.startswith'}, {'source': 'code_graph', 'target': \"file_details['functions'].get\"}, {'source': 'code_graph', 'target': \"file_details['functions'].keys\"}, {'source': 'code_graph', 'target': \"file_details['functions'].items\"}, {'source': 'get_python_file_details', 'target': 'logging.warning'}, {'source': 'get_python_file_details', 'target': 'f.read'}, {'source': 'get_python_file_details', 'target': 'ast.parse'}, {'source': 'get_python_file_details', 'target': 'open'}, {'source': 'get_python_file_details', 'target': 'CodeVisitor'}, {'source': 'get_python_file_details', 'target': 'code_graph', 'target_input': ['file_details', 'internal_only'], 'target_returns': [\"{'nodes': nodes, 'edges': edges}\"]}, {'source': 'get_python_file_details', 'target': 'visitor.analyze'}, {'source': 'ControlFlowVisitor', 'target': 'ControlFlowVisitor.__init__'}, {'source': 'ControlFlowVisitor', 'target': 'ControlFlowVisitor.generic_visit'}, {'source': 'ControlFlowVisitor', 'target': 'ControlFlowVisitor.get_control_flow'}, {'source': 'ControlFlowVisitor', 'target': 'ast.NodeVisitor'}, {'source': 'ControlFlowVisitor.generic_visit', 'target': 'super'}, {'source': 'ControlFlowVisitor.generic_visit', 'target': 'super().generic_visit'}, {'source': 'ControlFlowVisitor.generic_visit', 'target': 'isinstance'}, {'source': 'ControlFlowVisitor.generic_visit', 'target': 'type'}, {'source': 'ControlFlowVisitor.generic_visit', 'target': 'self.node_type_to_keyword.get'}, {'source': 'ControlFlowVisitor.generic_visit', 'target': 'self.control_flow.append'}, {'source': 'ControlFlowVisitor.get_control_flow', 'target': \"' -> '.join\"}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.__init__'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_FunctionDef'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_ClassDef'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.extract_details'}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.analyze'}, {'source': 'CodeVisitor', 'target': 'ast.NodeVisitor'}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'self.generic_visit'}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'self.extract_details'}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'self.generic_visit'}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'self.extract_details'}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.dump'}, {'source': 'CodeVisitor.extract_details', 'target': 'details.update'}, {'source': 'CodeVisitor.extract_details', 'target': 'isinstance'}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.unparse'}, {'source': 'CodeVisitor.extract_details', 'target': 'set'}, {'source': 'CodeVisitor.extract_details', 'target': \"self.classes[self.current_class]['class_attributes'].extend\"}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.get_docstring'}, {'source': 'CodeVisitor.extract_details', 'target': 'list'}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.walk'}, {'source': 'CodeVisitor.extract_details', 'target': 'any'}, {'source': 'CodeVisitor.extract_details', 'target': 'get_all_calls', 'target_input': ['node'], 'target_returns': ['calls']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.dump'}, {'source': 'CodeVisitor.analyze', 'target': 'self.visit'}, {'source': 'CodeVisitor.analyze', 'target': 'isinstance'}, {'source': 'CodeVisitor.analyze', 'target': 'get_control_flow', 'target_input': ['code'], 'target_returns': ['visitor.get_control_flow()']}, {'source': 'CodeVisitor.analyze', 'target': 'list'}, {'source': 'CodeVisitor.analyze', 'target': 'ast.walk'}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.keys'}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.keys'}]}"
    },
    {
        "instruction": "Funtions in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "\"\"\"\nUse AST to extract details from Python a file and return as a dictionary.\nRequirements:\n[req01] The ControlFlowVisitor class shall inherit from ast.NodeVisitor and be\n        used to visit nodes in the AST (Abstract Syntax Tree). It extracts \n        control flow keywords to give a high-level understanding of the \n        program flow.\n[req02] The CodeVisitor class shall inherit from ast.NodeVisitor and be used\n        to traverse an AST (Abstract Syntax Tree) and extract details about the\n        code.\n[req03] The CodeVisitor class shall have methods to visit FunctionDef and \n        ClassDef nodes and extract details about a function or a class.\n[req04] The CodeVisitor class shall have a method to analyze a node and \n        populate file_info with details about the file.\n[req05] The get_control_flow function shall accept a string of source code as\n        an argument and return the control flow keywords in the code.\n[req06] The get_python_file_details function shall accept a file path as an\n        argument and return a dictionary of the details extracted from the file.\n[req07] The CodeVisitor class shall store details about functions and classes,\n        including their code, AST, docstring, inputs, defaults, returns, calls,\n        variables, decorators, annotations, and properties.\n[req08] For classes, the CodeVisitor class shall also store details about class\n        attributes, methods, inheritance, and static methods.\n[req09] The analyze function in the CodeVisitor class shall also populate\n        file_info with the file's code, AST, dependencies, functions, classes,\n        and control flow.\n[req10] The code_graph function shall create a dictionary representation of \n        file details, including nodes and edges representing the relationships\n        in the code. It shall include function nodes, class nodes, method\n        nodes, and edges for function calls, method calls, and class\n        inheritance.\n[req11] The get_python_file_details function shall also add a graph to\n        file_info in the returned file_details dictionary. It shall add an\n        internal file graph (only including function calls where both the\n        caller and called function are within the file) and an entire file\n        graph (including all function calls).\n\"\"\"\nimport ast\nimport re\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\n\nclass ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {\n        ast.If: \"if\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.AsyncWith: \"with\",\n        ast.Try: \"try\",\n        ast.With: \"with\",\n        ast.ExceptHandler: \"except\",\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.Module: \"module\",\n    }\n    def __init__(self):\n        self.control_flow = []\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)\n\ndef get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n    def __init__(self, code: str):\n        # initialize dictionaries to store function, class, and file definitions\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class: # If we're inside a class, add this function as a method of the class\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else: # populate function dictionary when function definition found in AST\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node) # continue AST traversal to the next node\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # Set current_class to indicate that we're inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # Reset current_class after we've finished with this class\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {\n            f\"{node_type}_name\": node.name, \n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_ast\": ast.dump(node, include_attributes=True), \n            f\"{node_type}_docstring\": ast.get_docstring(node),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_returns\": [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f\"{node_type}_calls\": list(set([ast.unparse(n.func) for n in get_all_calls(node)])),\n            f\"{node_type}_variables\": list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])),\n            f\"{node_type}_decorators\": list(set(ast.unparse(decorator) for decorator in node.decorator_list)) if node.decorator_list else [],\n            f\"{node_type}_annotations\": list(set(ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None)),\n            f\"{node_type}_properties\": list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)])),\n        }  \n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class: # Find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                if attributes: # If this class already has some attributes, add to them\n                    if \"class_attributes\" in self.classes[self.current_class]:\n                        self.classes[self.current_class][\"class_attributes\"].extend(attributes)\n                    else: # Otherwise, start a new list of attributes for this class\n                        self.classes[self.current_class][\"class_attributes\"] = attributes\n            if node_type == 'class':\n                details.update({\n                    \"class_attributes\": [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    \"class_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    \"class_inheritance\": [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    \"class_static_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        # travere the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : ast.dump(node),\n            \"file_dependencies\": list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_control_flow\": get_control_flow(self.code),\n        }\n\ndef get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()\n\n\ndef code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool = True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Add function nodes to graph\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n\n    # Add class nodes and method nodes to graph\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                # Remove the 'class_method_' prefix to get the actual method name\n                actual_method_name = method_name[len('class_method_'):]\n                # Use the format 'ClassName.methodName' to represent methods\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                # Add edge between class and its method\n                G.add_edge(class_name, qualified_method_name)\n        \n        # Add edges for class inheritance\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n\n    # Add edges for function calls\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n\n    # Add edges for method calls\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:  # The called function is a method\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:  # The called function is a standalone function\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n\n    nodes = list(G.nodes)        \n    edges = [{\"source\": str(edge[0]), \"target\": str(edge[1]), **edge[2]} for edge in G.edges.data()]\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges,\n    }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f\"Permission denied: {file_path}\")\n        return None \n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f\"Syntax error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    \n    # add graph to file_info in file_details\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "get_all_calls, get_python_file_details, code_graph, get_control_flow"
    },
    {
        "instruction": "Classes in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "\"\"\"\nUse AST to extract details from Python a file and return as a dictionary.\nRequirements:\n[req01] The ControlFlowVisitor class shall inherit from ast.NodeVisitor and be\n        used to visit nodes in the AST (Abstract Syntax Tree). It extracts \n        control flow keywords to give a high-level understanding of the \n        program flow.\n[req02] The CodeVisitor class shall inherit from ast.NodeVisitor and be used\n        to traverse an AST (Abstract Syntax Tree) and extract details about the\n        code.\n[req03] The CodeVisitor class shall have methods to visit FunctionDef and \n        ClassDef nodes and extract details about a function or a class.\n[req04] The CodeVisitor class shall have a method to analyze a node and \n        populate file_info with details about the file.\n[req05] The get_control_flow function shall accept a string of source code as\n        an argument and return the control flow keywords in the code.\n[req06] The get_python_file_details function shall accept a file path as an\n        argument and return a dictionary of the details extracted from the file.\n[req07] The CodeVisitor class shall store details about functions and classes,\n        including their code, AST, docstring, inputs, defaults, returns, calls,\n        variables, decorators, annotations, and properties.\n[req08] For classes, the CodeVisitor class shall also store details about class\n        attributes, methods, inheritance, and static methods.\n[req09] The analyze function in the CodeVisitor class shall also populate\n        file_info with the file's code, AST, dependencies, functions, classes,\n        and control flow.\n[req10] The code_graph function shall create a dictionary representation of \n        file details, including nodes and edges representing the relationships\n        in the code. It shall include function nodes, class nodes, method\n        nodes, and edges for function calls, method calls, and class\n        inheritance.\n[req11] The get_python_file_details function shall also add a graph to\n        file_info in the returned file_details dictionary. It shall add an\n        internal file graph (only including function calls where both the\n        caller and called function are within the file) and an entire file\n        graph (including all function calls).\n\"\"\"\nimport ast\nimport re\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\n\nclass ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {\n        ast.If: \"if\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.AsyncWith: \"with\",\n        ast.Try: \"try\",\n        ast.With: \"with\",\n        ast.ExceptHandler: \"except\",\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.Module: \"module\",\n    }\n    def __init__(self):\n        self.control_flow = []\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)\n\ndef get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n    def __init__(self, code: str):\n        # initialize dictionaries to store function, class, and file definitions\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class: # If we're inside a class, add this function as a method of the class\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else: # populate function dictionary when function definition found in AST\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node) # continue AST traversal to the next node\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # Set current_class to indicate that we're inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # Reset current_class after we've finished with this class\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {\n            f\"{node_type}_name\": node.name, \n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_ast\": ast.dump(node, include_attributes=True), \n            f\"{node_type}_docstring\": ast.get_docstring(node),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_returns\": [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f\"{node_type}_calls\": list(set([ast.unparse(n.func) for n in get_all_calls(node)])),\n            f\"{node_type}_variables\": list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])),\n            f\"{node_type}_decorators\": list(set(ast.unparse(decorator) for decorator in node.decorator_list)) if node.decorator_list else [],\n            f\"{node_type}_annotations\": list(set(ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None)),\n            f\"{node_type}_properties\": list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)])),\n        }  \n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class: # Find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                if attributes: # If this class already has some attributes, add to them\n                    if \"class_attributes\" in self.classes[self.current_class]:\n                        self.classes[self.current_class][\"class_attributes\"].extend(attributes)\n                    else: # Otherwise, start a new list of attributes for this class\n                        self.classes[self.current_class][\"class_attributes\"] = attributes\n            if node_type == 'class':\n                details.update({\n                    \"class_attributes\": [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    \"class_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    \"class_inheritance\": [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    \"class_static_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        # travere the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : ast.dump(node),\n            \"file_dependencies\": list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_control_flow\": get_control_flow(self.code),\n        }\n\ndef get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()\n\n\ndef code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool = True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Add function nodes to graph\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n\n    # Add class nodes and method nodes to graph\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                # Remove the 'class_method_' prefix to get the actual method name\n                actual_method_name = method_name[len('class_method_'):]\n                # Use the format 'ClassName.methodName' to represent methods\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                # Add edge between class and its method\n                G.add_edge(class_name, qualified_method_name)\n        \n        # Add edges for class inheritance\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n\n    # Add edges for function calls\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n\n    # Add edges for method calls\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:  # The called function is a method\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:  # The called function is a standalone function\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n\n    nodes = list(G.nodes)        \n    edges = [{\"source\": str(edge[0]), \"target\": str(edge[1]), **edge[2]} for edge in G.edges.data()]\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges,\n    }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f\"Permission denied: {file_path}\")\n        return None \n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f\"Syntax error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    \n    # add graph to file_info in file_details\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "CodeVisitor, ControlFlowVisitor"
    },
    {
        "instruction": "Control Flow in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "\"\"\"\nUse AST to extract details from Python a file and return as a dictionary.\nRequirements:\n[req01] The ControlFlowVisitor class shall inherit from ast.NodeVisitor and be\n        used to visit nodes in the AST (Abstract Syntax Tree). It extracts \n        control flow keywords to give a high-level understanding of the \n        program flow.\n[req02] The CodeVisitor class shall inherit from ast.NodeVisitor and be used\n        to traverse an AST (Abstract Syntax Tree) and extract details about the\n        code.\n[req03] The CodeVisitor class shall have methods to visit FunctionDef and \n        ClassDef nodes and extract details about a function or a class.\n[req04] The CodeVisitor class shall have a method to analyze a node and \n        populate file_info with details about the file.\n[req05] The get_control_flow function shall accept a string of source code as\n        an argument and return the control flow keywords in the code.\n[req06] The get_python_file_details function shall accept a file path as an\n        argument and return a dictionary of the details extracted from the file.\n[req07] The CodeVisitor class shall store details about functions and classes,\n        including their code, AST, docstring, inputs, defaults, returns, calls,\n        variables, decorators, annotations, and properties.\n[req08] For classes, the CodeVisitor class shall also store details about class\n        attributes, methods, inheritance, and static methods.\n[req09] The analyze function in the CodeVisitor class shall also populate\n        file_info with the file's code, AST, dependencies, functions, classes,\n        and control flow.\n[req10] The code_graph function shall create a dictionary representation of \n        file details, including nodes and edges representing the relationships\n        in the code. It shall include function nodes, class nodes, method\n        nodes, and edges for function calls, method calls, and class\n        inheritance.\n[req11] The get_python_file_details function shall also add a graph to\n        file_info in the returned file_details dictionary. It shall add an\n        internal file graph (only including function calls where both the\n        caller and called function are within the file) and an entire file\n        graph (including all function calls).\n\"\"\"\nimport ast\nimport re\nimport logging\nimport networkx as nx\nfrom typing import Dict, List, Optional, Union\n\n\nclass ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {\n        ast.If: \"if\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.AsyncWith: \"with\",\n        ast.Try: \"try\",\n        ast.With: \"with\",\n        ast.ExceptHandler: \"except\",\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.Module: \"module\",\n    }\n    def __init__(self):\n        self.control_flow = []\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)\n\ndef get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n    def __init__(self, code: str):\n        # initialize dictionaries to store function, class, and file definitions\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class: # If we're inside a class, add this function as a method of the class\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else: # populate function dictionary when function definition found in AST\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node) # continue AST traversal to the next node\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class') # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # Set current_class to indicate that we're inside a class\n        self.generic_visit(node) # continue AST traversal to the next node\n        self.current_class = None  # Reset current_class after we've finished with this class\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {\n            f\"{node_type}_name\": node.name, \n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_ast\": ast.dump(node, include_attributes=True), \n            f\"{node_type}_docstring\": ast.get_docstring(node),\n            f\"{node_type}_inputs\": [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None,\n            f\"{node_type}_returns\": [ast.unparse(subnode.value) if subnode.value is not None else \"None\" for subnode in node_walk if isinstance(subnode, ast.Return)],\n            f\"{node_type}_calls\": list(set([ast.unparse(n.func) for n in get_all_calls(node)])),\n            f\"{node_type}_variables\": list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])),\n            f\"{node_type}_decorators\": list(set(ast.unparse(decorator) for decorator in node.decorator_list)) if node.decorator_list else [],\n            f\"{node_type}_annotations\": list(set(ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None)),\n            f\"{node_type}_properties\": list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)])),\n        }  \n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class: # Find attributes defined as self.attribute\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and target.value.id == 'self']\n                if attributes: # If this class already has some attributes, add to them\n                    if \"class_attributes\" in self.classes[self.current_class]:\n                        self.classes[self.current_class][\"class_attributes\"].extend(attributes)\n                    else: # Otherwise, start a new list of attributes for this class\n                        self.classes[self.current_class][\"class_attributes\"] = attributes\n            if node_type == 'class':\n                details.update({\n                    \"class_attributes\": [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)],\n                    \"class_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\"],\n                    \"class_inheritance\": [ast.unparse(base) for base in node.bases] if node.bases else [],\n                    \"class_static_methods\": [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != \"__init__\" and any(isinstance(decorator, ast.Name) and decorator.id == \"staticmethod\" for decorator in subnode.decorator_list)],\n                    })\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        # travere the AST rooted at 'node', create a list of all nodes within the current file, and populate 'file_info' with file details\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\" : ast.dump(node),\n            \"file_dependencies\": list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_control_flow\": get_control_flow(self.code),\n        }\n\ndef get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()\n\n\ndef code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool = True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Add function nodes to graph\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n\n    # Add class nodes and method nodes to graph\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                # Remove the 'class_method_' prefix to get the actual method name\n                actual_method_name = method_name[len('class_method_'):]\n                # Use the format 'ClassName.methodName' to represent methods\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                # Add edge between class and its method\n                G.add_edge(class_name, qualified_method_name)\n        \n        # Add edges for class inheritance\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n\n    # Add edges for function calls\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n\n    # Add edges for method calls\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:  # The called function is a method\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:  # The called function is a standalone function\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n\n    nodes = list(G.nodes)        \n    edges = [{\"source\": str(edge[0]), \"target\": str(edge[1]), **edge[2]} for edge in G.edges.data()]\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges,\n    }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f\"Permission denied: {file_path}\")\n        return None \n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f\"Syntax error in file: {file_path}\")\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    \n    # add graph to file_info in file_details\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "module -> class -> def __init__ -> def generic_visit -> if -> if -> def get_control_flow -> def get_all_calls -> for -> if -> class -> def __init__ -> def visit_FunctionDef -> if -> def visit_ClassDef -> def extract_details -> if -> if -> if -> if -> if -> def analyze -> def get_control_flow -> def code_graph -> for -> for -> for -> if -> if -> for -> if -> for -> for -> if -> if -> if -> for -> for -> if -> for -> if -> if -> if -> if -> def get_python_file_details -> try -> with -> except -> try -> except"
    },
    {
        "instruction": "Inputs to function: (get_all_calls) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls",
        "output": "node"
    },
    {
        "instruction": "Inputs to function: (get_control_flow) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()",
        "output": "code"
    },
    {
        "instruction": "Inputs to function: (code_graph) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool=True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                G.add_edge(class_name, qualified_method_name)\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': str(edge[0]), 'target': str(edge[1]), **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "file_details, internal_only"
    },
    {
        "instruction": "Inputs to function: (get_python_file_details) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f'Permission denied: {file_path}')\n        return None\n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f'Syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "file_path"
    },
    {
        "instruction": "Docstring of function: (get_all_calls) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls",
        "output": "Recursively find all function calls in the subtree rooted at node."
    },
    {
        "instruction": "Docstring of function: (get_control_flow) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()",
        "output": "Extract control flow keywords from source code. Args: code: str: The source code to extract from. Returns: str: The control flow keywords in the code."
    },
    {
        "instruction": "Docstring of function: (code_graph) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool=True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                G.add_edge(class_name, qualified_method_name)\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': str(edge[0]), 'target': str(edge[1]), **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "only include function calls where both the caller and called function are within the file. Returns: dict: A dictionary with nodes and edges representing the relationships in the code., UnionDict, str: The details extracted from the file. internal_only: bool: If True, Create a dictionary representation of file details. Args: file_details: Dictstr"
    },
    {
        "instruction": "Docstring of function: (get_python_file_details) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f'Permission denied: {file_path}')\n        return None\n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f'Syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "str: The details extracted from the file., Extract details from a Python file. Args: file_path: str: The path to the Python file. Returns: Dictstr, UnionDict"
    },
    {
        "instruction": "Calls in function: (get_all_calls) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls",
        "output": "ast.iter_child_nodes, isinstance, calls.append, get_all_calls, calls.extend"
    },
    {
        "instruction": "Calls in function: (get_control_flow) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()",
        "output": "visitor.visit, visitor.get_control_flow, ControlFlowVisitor, ast.parse"
    },
    {
        "instruction": "Calls in function: (code_graph) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool=True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                G.add_edge(class_name, qualified_method_name)\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': str(edge[0]), 'target': str(edge[1]), **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "called_func.rsplit, file_detailsfunctions.get, str, list, nx.DiGraph, file_detailsfunctions.getcalled_func, base_class.strip, class_details.items, file_detailsfunctions.keys, G.add_node, .get, file_detailsfunctions.items, len, G.add_edge, called_func.strip, class_details.keys, G.edges.data, method_name.startswith, .getfclass_method_called_method_name, file_detailsclasses.getcalled_class_name, file_detailsclasses.get, file_detailsclasses.items"
    },
    {
        "instruction": "Calls in function: (get_python_file_details) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f'Permission denied: {file_path}')\n        return None\n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f'Syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "logging.warning, f.read, ast.parse, open, CodeVisitor, code_graph, visitor.analyze"
    },
    {
        "instruction": "Variables in function: (get_all_calls) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls",
        "output": "calls"
    },
    {
        "instruction": "Variables in function: (get_control_flow) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()",
        "output": "visitor, tree"
    },
    {
        "instruction": "Variables in function: (code_graph) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool=True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                G.add_edge(class_name, qualified_method_name)\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': str(edge[0]), 'target': str(edge[1]), **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "G, edge_data, target_input, qualified_method_name, target_returns, edges, actual_method_name, nodes"
    },
    {
        "instruction": "Variables in function: (get_python_file_details) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f'Permission denied: {file_path}')\n        return None\n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f'Syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "file_details, visitor, code, tree"
    },
    {
        "instruction": "Returns from function: (get_all_calls) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_all_calls(node):\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`.\n    \"\"\"\n    calls = []\n    for child in ast.iter_child_nodes(node):\n        if isinstance(child, ast.Call):\n            calls.append(child)\n        calls.extend(get_all_calls(child))\n    return calls",
        "output": "calls"
    },
    {
        "instruction": "Returns from function: (get_control_flow) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(code: str) -> str:\n    \"\"\"\n    Extract control flow keywords from source code.\n    Args:\n        code: str: The source code to extract from.\n    Returns:\n        str: The control flow keywords in the code.\n    \"\"\"\n    visitor = ControlFlowVisitor()\n    tree = ast.parse(code)\n    visitor.visit(tree)\n    return visitor.get_control_flow()",
        "output": "visitor.get_control_flow"
    },
    {
        "instruction": "Returns from function: (code_graph) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def code_graph(file_details: Dict[str, Union[Dict, str]], internal_only: bool=True) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_details: Dict[str, Union[Dict, str]]: The details extracted from the file.\n        internal_only: bool: If True, only include function calls where both the caller and called function are within the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships\n            in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    for function_name in file_details['functions'].keys():\n        G.add_node(function_name)\n    for class_name, class_details in file_details['classes'].items():\n        G.add_node(class_name)\n        for method_name in class_details.keys():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                G.add_node(qualified_method_name)\n                G.add_edge(class_name, qualified_method_name)\n        if 'class_inheritance' in class_details and class_details['class_inheritance']:\n            for base_class in class_details['class_inheritance']:\n                if not internal_only or base_class in G.nodes:\n                    G.add_edge(class_name, base_class.strip())\n    for function_name, function_details in file_details['functions'].items():\n        for called_func in function_details['function_calls']:\n            if not internal_only or called_func in G.nodes:\n                edge_data = {}\n                target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                if target_input:\n                    edge_data['target_input'] = target_input\n                if target_returns:\n                    edge_data['target_returns'] = target_returns\n                G.add_edge(function_name, called_func.strip(), **edge_data)\n    for class_name, class_details in file_details['classes'].items():\n        for method_name, method_details in class_details.items():\n            if method_name.startswith('class_method_'):\n                actual_method_name = method_name[len('class_method_'):]\n                qualified_method_name = f'{class_name}.{actual_method_name}'\n                for called_func in method_details['method_calls']:\n                    if not internal_only or called_func in G.nodes:\n                        edge_data = {}\n                        if '.' in called_func:\n                            called_class_name, called_method_name = called_func.rsplit('.', 1)\n                            target_input = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_inputs', [])\n                            target_returns = file_details['classes'].get(called_class_name, {}).get(f'class_method_{called_method_name}', {}).get('method_returns', [])\n                        else:\n                            target_input = file_details['functions'].get(called_func, {}).get('function_inputs', [])\n                            target_returns = file_details['functions'].get(called_func, {}).get('function_returns', [])\n                        if target_input:\n                            edge_data['target_input'] = target_input\n                        if target_returns:\n                            edge_data['target_returns'] = target_returns\n                        G.add_edge(qualified_method_name, called_func.strip(), **edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': str(edge[0]), 'target': str(edge[1]), **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}",
        "output": "edges: edges, nodes: nodes"
    },
    {
        "instruction": "Returns from function: (get_python_file_details) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n    except PermissionError:\n        logging.warning(f'Permission denied: {file_path}')\n        return None\n    try:\n        tree = ast.parse(code)\n    except SyntaxError:\n        logging.warning(f'Syntax error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_details['file_info']['internal_code_graph'] = code_graph(file_details)\n    file_details['file_info']['entire_code_graph'] = code_graph(file_details, internal_only=False)\n    return file_details",
        "output": "file_details, None"
    },
    {
        "instruction": "Methods in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {ast.If: 'if', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.AsyncWith: 'with', ast.Try: 'try', ast.With: 'with', ast.ExceptHandler: 'except', ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.Module: 'module'}\n\n    def __init__(self):\n        self.control_flow = []\n\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)",
        "output": "generic_visit, get_control_flow"
    },
    {
        "instruction": "Methods in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else:\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                if attributes:\n                    if 'class_attributes' in self.classes[self.current_class]:\n                        self.classes[self.current_class]['class_attributes'].extend(attributes)\n                    else:\n                        self.classes[self.current_class]['class_attributes'] = attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "analyze, visit_FunctionDef, visit_ClassDef, extract_details"
    },
    {
        "instruction": "Docstring of class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {ast.If: 'if', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.AsyncWith: 'with', ast.Try: 'try', ast.With: 'with', ast.ExceptHandler: 'except', ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.Module: 'module'}\n\n    def __init__(self):\n        self.control_flow = []\n\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)",
        "output": "it is added to the control_flow list. The method then calls the inherited generic_visit to continue visiting other nodes. get_control_flow: Returns a string representing the control flow of the program. The control flow keywords are joined in the order they were encountered during the AST visit., This class inherits from ast.NodeVisitor and is used to visit nodes in the AST Abstract Syntax Tree.It extracts control flow keywords to give a high-level understanding of the program flow. Attributes: node_type_to_keyword dict: A dictionary mapping AST node types to corresponding control flow keywords. control_flow list: A list storing the sequence of control flow keywords encountered in the AST. Methods: __init__: Initializes a new instance of the class, setting up the control flow list. generic_visitnode: Method to visit a node. If the node type corresponds to a control flow keyword"
    },
    {
        "instruction": "Docstring of class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else:\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                if attributes:\n                    if 'class_attributes' in self.classes[self.current_class]:\n                        self.classes[self.current_class]['class_attributes'].extend(attributes)\n                    else:\n                        self.classes[self.current_class]['class_attributes'] = attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "Visitor class for traversing an AST Abstract Syntax Tree and extracting details about the code. Attributes: code str: The source code. functionsDict: details about functions in the code. classes Dict: details about classes in the code. file_info Dict: details about the file. Methods: visit_FunctionDefnode: ast.FunctionDef -> None: Extract details about a function. visit_ClassDefnode: ast.ClassDef -> None: Extract details about a class. extract_detailsnode: ast.AST, node_type: str -> Dictstr, Unionstr, Liststr: Extract details about a node. analyzenode: ast.AST -> None: Populate file_info with details about the file."
    },
    {
        "instruction": "Attributes of class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {ast.If: 'if', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.AsyncWith: 'with', ast.Try: 'try', ast.With: 'with', ast.ExceptHandler: 'except', ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.Module: 'module'}\n\n    def __init__(self):\n        self.control_flow = []\n\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)",
        "output": "control_flow"
    },
    {
        "instruction": "Attributes of class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else:\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                if attributes:\n                    if 'class_attributes' in self.classes[self.current_class]:\n                        self.classes[self.current_class]['class_attributes'].extend(attributes)\n                    else:\n                        self.classes[self.current_class]['class_attributes'] = attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "file_info, current_class"
    },
    {
        "instruction": "Variables in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {ast.If: 'if', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.AsyncWith: 'with', ast.Try: 'try', ast.With: 'with', ast.ExceptHandler: 'except', ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.Module: 'module'}\n\n    def __init__(self):\n        self.control_flow = []\n\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)",
        "output": "keyword, node_type_to_keyword"
    },
    {
        "instruction": "Variables in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else:\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                if attributes:\n                    if 'class_attributes' in self.classes[self.current_class]:\n                        self.classes[self.current_class]['class_attributes'].extend(attributes)\n                    else:\n                        self.classes[self.current_class]['class_attributes'] = attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "attributes, node_walk, details"
    },
    {
        "instruction": "Inheritance of class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class ControlFlowVisitor(ast.NodeVisitor):\n    \"\"\"\n    This class inherits from ast.NodeVisitor and is used to visit nodes in the\n    AST (Abstract Syntax Tree).It extracts control flow keywords to give a \n    high-level understanding of the program flow.\n    Attributes:\n        node_type_to_keyword (dict): A dictionary mapping AST node types to \n            corresponding control flow keywords.\n        control_flow (list): A list storing the sequence of control flow \n            keywords encountered in the AST.\n    Methods:\n        __init__(): Initializes a new instance of the class, setting up the\n            control flow list.\n        generic_visit(node): Method to visit a node. If the node type \n            corresponds to a control flow keyword, it is added to the \n            control_flow list. The method then calls the inherited\n            generic_visit to continue visiting other nodes.\n        get_control_flow(): Returns a string representing the control flow of\n            the program. The control flow keywords are joined in the order they\n            were encountered during the AST visit.\n    \"\"\"\n    node_type_to_keyword = {ast.If: 'if', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.AsyncWith: 'with', ast.Try: 'try', ast.With: 'with', ast.ExceptHandler: 'except', ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.Module: 'module'}\n\n    def __init__(self):\n        self.control_flow = []\n\n    def generic_visit(self, node):\n        keyword = self.node_type_to_keyword.get(type(node))\n        if keyword:\n            if isinstance(node, ast.FunctionDef):\n                self.control_flow.append(keyword + ' ' + node.name)\n            else:\n                self.control_flow.append(keyword)\n        super().generic_visit(node)\n\n    def get_control_flow(self):\n        return ' -> '.join(self.control_flow)",
        "output": "ast.NodeVisitor"
    },
    {
        "instruction": "Inheritance of class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting\n    details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None: Extract details \n            about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None: Extract details about a \n            class.\n        extract_details(node: ast.AST, node_type: str) -> \n            Dict[str, Union[str, List[str]]]: Extract details about a node.\n        analyze(node: ast.AST) -> None: Populate file_info with details about\n                the file.\n    \"\"\"\n\n    def __init__(self, code: str):\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n        else:\n            self.functions[node.name] = self.extract_details(node, 'function')\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n        if node_type == 'class' or node_type == 'method':\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                if attributes:\n                    if 'class_attributes' in self.classes[self.current_class]:\n                        self.classes[self.current_class]['class_attributes'].extend(attributes)\n                    else:\n                        self.classes[self.current_class]['class_attributes'] = attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        node_walk = list(ast.walk(node))\n        self.visit(node)\n        self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "ast.NodeVisitor"
    },
    {
        "instruction": "Inputs to method: (__init__) in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def __init__(self):\n    self.control_flow = []",
        "output": "self"
    },
    {
        "instruction": "Inputs to method: (generic_visit) in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def generic_visit(self, node):\n    keyword = self.node_type_to_keyword.get(type(node))\n    if keyword:\n        if isinstance(node, ast.FunctionDef):\n            self.control_flow.append(keyword + ' ' + node.name)\n        else:\n            self.control_flow.append(keyword)\n    super().generic_visit(node)",
        "output": "node, self"
    },
    {
        "instruction": "Inputs to method: (get_control_flow) in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(self):\n    return ' -> '.join(self.control_flow)",
        "output": "self"
    },
    {
        "instruction": "Inputs to method: (__init__) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def __init__(self, code: str):\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None",
        "output": "code, self"
    },
    {
        "instruction": "Inputs to method: (visit_FunctionDef) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n    else:\n        self.functions[node.name] = self.extract_details(node, 'function')\n    self.generic_visit(node)",
        "output": "node, self"
    },
    {
        "instruction": "Inputs to method: (visit_ClassDef) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "node, self"
    },
    {
        "instruction": "Inputs to method: (extract_details) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    node_walk = list(ast.walk(node))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n    if node_type == 'class' or node_type == 'method':\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            if attributes:\n                if 'class_attributes' in self.classes[self.current_class]:\n                    self.classes[self.current_class]['class_attributes'].extend(attributes)\n                else:\n                    self.classes[self.current_class]['class_attributes'] = attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "node, self, node_type"
    },
    {
        "instruction": "Inputs to method: (analyze) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    node_walk = list(ast.walk(node))\n    self.visit(node)\n    self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "node, self"
    },
    {
        "instruction": "Calls in method: (generic_visit) in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def generic_visit(self, node):\n    keyword = self.node_type_to_keyword.get(type(node))\n    if keyword:\n        if isinstance(node, ast.FunctionDef):\n            self.control_flow.append(keyword + ' ' + node.name)\n        else:\n            self.control_flow.append(keyword)\n    super().generic_visit(node)",
        "output": "super, isinstance, super.generic_visit, type, self.node_type_to_keyword.get, self.control_flow.append"
    },
    {
        "instruction": "Calls in method: (get_control_flow) in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(self):\n    return ' -> '.join(self.control_flow)",
        "output": "-> .join"
    },
    {
        "instruction": "Calls in method: (visit_FunctionDef) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = self.extract_details(node, 'method')\n    else:\n        self.functions[node.name] = self.extract_details(node, 'function')\n    self.generic_visit(node)",
        "output": "self.extract_details, self.generic_visit"
    },
    {
        "instruction": "Calls in method: (visit_ClassDef) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None",
        "output": "self.extract_details, self.generic_visit"
    },
    {
        "instruction": "Calls in method: (extract_details) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    node_walk = list(ast.walk(node))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n    if node_type == 'class' or node_type == 'method':\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            if attributes:\n                if 'class_attributes' in self.classes[self.current_class]:\n                    self.classes[self.current_class]['class_attributes'].extend(attributes)\n                else:\n                    self.classes[self.current_class]['class_attributes'] = attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "ast.dump, details.update, isinstance, get_all_calls, ast.unparse, set, ast.get_docstring, list, ast.walk, any, self.classesself.current_classclass_attributes.extend"
    },
    {
        "instruction": "Calls in method: (analyze) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def analyze(self, node: ast.AST) -> None:\n    node_walk = list(ast.walk(node))\n    self.visit(node)\n    self.file_info = {'file_code': self.code, 'file_ast': ast.dump(node), 'file_dependencies': list({alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_control_flow': get_control_flow(self.code)}",
        "output": "ast.dump, self.visit, isinstance, get_control_flow, list, ast.walk, self.classes.keys, self.functions.keys"
    },
    {
        "instruction": "Returns from method: (get_control_flow) in class: (ControlFlowVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def get_control_flow(self):\n    return ' -> '.join(self.control_flow)",
        "output": "-> .joinself.control_flow"
    },
    {
        "instruction": "Returns from method: (extract_details) in class: (CodeVisitor) in file: (py2dataset.py2dataset.get_python_file_details.py)?",
        "input": "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    node_walk = list(ast.walk(node))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_ast': ast.dump(node, include_attributes=True), f'{node_type}_docstring': ast.get_docstring(node), f'{node_type}_inputs': [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(set([ast.unparse(n.func) for n in get_all_calls(node)])), f'{node_type}_variables': list(set([ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)])), f'{node_type}_decorators': list(set((ast.unparse(decorator) for decorator in node.decorator_list))) if node.decorator_list else [], f'{node_type}_annotations': list(set((ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None))), f'{node_type}_properties': list(set([ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)]))}\n    if node_type == 'class' or node_type == 'method':\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            if attributes:\n                if 'class_attributes' in self.classes[self.current_class]:\n                    self.classes[self.current_class]['class_attributes'].extend(attributes)\n                else:\n                    self.classes[self.current_class]['class_attributes'] = attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__'], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and subnode.name != '__init__' and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details",
        "output": "details"
    }
]